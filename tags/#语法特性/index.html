<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>AWei’s Kernel Tour | #语法特性</title>
    <meta name="description"
        content=" ">
    <link rel="canonical" href="https://cnjslw.github.io/tags/#%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/" />
    <link rel="icon" type="image/x-icon" href="/images/linux_pic.ico">
    <meta property="og:title" content="#语法特性" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cnjslw.github.io/tags/#%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/" />


    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="#语法特性"/>
<meta name="twitter:description" content=""/>

    
    
    

    <link rel="stylesheet" href='/css/style.css' />
    <link rel="stylesheet" href='/css/search.css' />
    <link rel="stylesheet" href='/css/md_nb.css' />
    <link rel="stylesheet" href='/css/list.css' />
    <link rel="stylesheet" href='/css/terms.css' />
    <link rel="stylesheet" href='/css/taxonomy.css' />
    <link rel="stylesheet" href='/css/font-awesome-4.7.0/css/font-awesome.min.css' />
    <link rel="stylesheet" href='/css/home.css' />
    <link rel="stylesheet" href='/css/syntax.css' />
    
    <link rel="stylesheet" href='/css/shortcode.css' />

    
    <link rel="stylesheet" href='/css/_custom.css' />
    <style>
        {
                {
                if eq .Kind "404"
            }
        }

        body::after {
            display: none;
        }

            {
                {
                end
            }
        }
    </style>
    
    
    
    
    <script src="/js/lazysizes.min.js" async=""></script>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/search.js"></script>
    <script src="/js/md_nb.js"></script>
    <script src="/js/yes.js"></script>
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
</head><body style="font-family: ,'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Heiti SC', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;">
        <div class="loading">
            <div class="loading-bg"></div>
            <div class="loading-long">
                <div class="loading-short"></div>
            </div>
        </div>

        <header>
    <nav class="navbar">
        <div class="navbar-brand">
            <a href="/">
                <span class="logo">AWei’s Kernel Tour</span>
            </a>
        </div>
        <div class="navbar-menu">
            
                <a href="/">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-home'></i> 主页</div>
                        </div>
                    </div>
                </a>
            
                <a href="/posts">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-book'></i> 文章</div>
                        </div>
                    </div>
                </a>
            
                <a href="/categories">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-folder-open'></i> 分类</div>
                        </div>
                    </div>
                </a>
            
                <a href="/series">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-gears'></i> 系列</div>
                        </div>
                    </div>
                </a>
            
                <a href="/tags">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-tags'></i> 标签</div>
                        </div>
                    </div>
                </a>
            
                <a href="/about">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-info-circle'></i> 简历</div>
                        </div>
                    </div>
                </a>
            
            <div class="navbar-burger">
                <div class="burger-btn"><span><i class="fa fa-navicon"></i></span></div>
            </div>
            
            
            <div class="search-in"><span><i class="fa fa-search"></i></span></div>
            
                <div class="mode">
                    <span class="sun"><i class="fa fa-sun-o"></i></span>
                    <span class="moon"><i class="fa fa-moon-o"></i></span>
                </div>
            
        </div>
    </nav>
    <div class="burger-items">
        
        <a href="/">
            <div class="burger-item">
                <i class='fa fa-home'></i> 主页
            </div>
        </a>
        
        <a href="/posts">
            <div class="burger-item">
                <i class='fa fa-book'></i> 文章
            </div>
        </a>
        
        <a href="/categories">
            <div class="burger-item">
                <i class='fa fa-folder-open'></i> 分类
            </div>
        </a>
        
        <a href="/series">
            <div class="burger-item">
                <i class='fa fa-gears'></i> 系列
            </div>
        </a>
        
        <a href="/tags">
            <div class="burger-item">
                <i class='fa fa-tags'></i> 标签
            </div>
        </a>
        
        <a href="/about">
            <div class="burger-item">
                <i class='fa fa-info-circle'></i> 简历
            </div>
        </a>
        
    </div>
    <div class="header-rest"></div>
</header>


        <div id="content">
    






    
        
    




    <div class="hero">
        
            
                <div class="hero-img">
                    <img class="lazyload" src="/images/thumbnail.gif" data-src="" alt="">
                </div>
            
        <div class="hero-content">
            <h1 class="hero-title">标签: #语法特性</h1>
        </div>
    </div>




<div class="zhuti-0">
    <div class="container">
        <div class="zhuti">
            <div class="zhuti-l">
                




    


<div class="terms-body">
    <div class="long">
        <button class="tosides-1 text-wbd">
            <i class="fa fa-arrow-right"></i>
        </button>
        <button class="tosides-2 text-wbd">
            <i class="fa fa-arrow-left"></i>
        </button>
        <button class="toup text-wbd">
            <i class="fa fa-arrow-up"></i>
        </button>
    </div>
    
        <div class="terms-row">
            
            <div class="terms-root">
                
                


<div class="card-large">
    <div class="card-large-img">

        
                <img class="lazyload" src="/images/thumbnail.gif" data-src="" alt='图片加载失败'>
        
    </div>
    <div class="card-large-content">
        <div class="up-title"><a href="https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">【模板与泛型编程01】函数模板</a></div>
        <div class="up-date">
            <span class="no-wrap"><i class="fa fa-calendar"></i> 发布于: 2022-6-8 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> 更新于: 2022-6-8 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-folder"></i>
                
                    收录于:
                    
                        <a href='
                                        /categories/cpp
                                    '>
                                Cpp
                            </a>
                
            </span>
        </div>
        <div class="down-summary">函数模板</div>
    </div>
    <div class="card-readmore">
        <a href="https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">
            <span><i class="fa fa-arrow-right"></i></span>
        </a>
    </div>
</div>



    


    <div class="down-type">
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/cpp
                        '>
                    <i class="fa fa-tag"></i> Cpp
                </a>
            </div>
        </span>
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7
                        '>
                    <i class="fa fa-tag"></i> #语法特性
                </a>
            </div>
        </span>
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/%E7%BC%96%E7%A8%8B
                        '>
                    <i class="fa fa-tag"></i> 编程
                </a>
            </div>
        </span>
        
    </div>

<div class="dang"></div>
            </div>
            
            <div class="terms-root">
                
                


<div class="card-large">
    <div class="card-large-img">

        
                <img class="lazyload" src="/images/thumbnail.gif" data-src="" alt='图片加载失败'>
        
    </div>
    <div class="card-large-content">
        <div class="up-title"><a href="https://cnjslw.github.io/posts/%E7%B1%BB/">【C&#43;&#43; Primer(edition 5) 07】类</a></div>
        <div class="up-date">
            <span class="no-wrap"><i class="fa fa-calendar"></i> 发布于: 2021-9-20 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> 更新于: 2021-9-20 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-folder"></i>
                
                    收录于:
                    
                        <a href='
                                        /categories/cpp
                                    '>
                                Cpp
                            </a>
                
            </span>
        </div>
        <div class="down-summary">类</div>
    </div>
    <div class="card-readmore">
        <a href="https://cnjslw.github.io/posts/%E7%B1%BB/">
            <span><i class="fa fa-arrow-right"></i></span>
        </a>
    </div>
</div>



    


    <div class="down-type">
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#cpp
                        '>
                    <i class="fa fa-tag"></i> #Cpp
                </a>
            </div>
        </span>
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7
                        '>
                    <i class="fa fa-tag"></i> #语法特性
                </a>
            </div>
        </span>
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#%E7%BC%96%E7%A8%8B
                        '>
                    <i class="fa fa-tag"></i> #编程
                </a>
            </div>
        </span>
        
    </div>

<div class="dang"></div>
            </div>
            
            <div class="terms-root">
                
                


<div class="card-large">
    <div class="card-large-img">

        
                <img class="lazyload" src="/images/thumbnail.gif" data-src="" alt='图片加载失败'>
        
    </div>
    <div class="card-large-content">
        <div class="up-title"><a href="https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0/">【C&#43;&#43; Primer(edition 5) 06】函数</a></div>
        <div class="up-date">
            <span class="no-wrap"><i class="fa fa-calendar"></i> 发布于: 2021-9-13 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> 更新于: 2021-9-13 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-folder"></i>
                
                    收录于:
                    
                        <a href='
                                        /categories/cpp
                                    '>
                                Cpp
                            </a>
                
            </span>
        </div>
        <div class="down-summary">函数</div>
    </div>
    <div class="card-readmore">
        <a href="https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0/">
            <span><i class="fa fa-arrow-right"></i></span>
        </a>
    </div>
</div>



    


    <div class="down-type">
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#cpp
                        '>
                    <i class="fa fa-tag"></i> #Cpp
                </a>
            </div>
        </span>
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7
                        '>
                    <i class="fa fa-tag"></i> #语法特性
                </a>
            </div>
        </span>
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#%E7%BC%96%E7%A8%8B
                        '>
                    <i class="fa fa-tag"></i> #编程
                </a>
            </div>
        </span>
        
    </div>

<div class="dang"></div>
            </div>
            
            <div class="terms-root">
                
                


<div class="card-large">
    <div class="card-large-img">

        
                <img class="lazyload" src="/images/thumbnail.gif" data-src="" alt='图片加载失败'>
        
    </div>
    <div class="card-large-content">
        <div class="up-title"><a href="https://cnjslw.github.io/posts/%E8%AF%AD%E5%8F%A5/">【C&#43;&#43; Primer(edition 5) 05】语句</a></div>
        <div class="up-date">
            <span class="no-wrap"><i class="fa fa-calendar"></i> 发布于: 2021-9-12 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> 更新于: 2021-9-12 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-folder"></i>
                
                    收录于:
                    
                        <a href='
                                        /categories/cpp
                                    '>
                                Cpp
                            </a>
                
            </span>
        </div>
        <div class="down-summary">语句</div>
    </div>
    <div class="card-readmore">
        <a href="https://cnjslw.github.io/posts/%E8%AF%AD%E5%8F%A5/">
            <span><i class="fa fa-arrow-right"></i></span>
        </a>
    </div>
</div>



    


    <div class="down-type">
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#cpp
                        '>
                    <i class="fa fa-tag"></i> #Cpp
                </a>
            </div>
        </span>
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7
                        '>
                    <i class="fa fa-tag"></i> #语法特性
                </a>
            </div>
        </span>
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#%E7%BC%96%E7%A8%8B
                        '>
                    <i class="fa fa-tag"></i> #编程
                </a>
            </div>
        </span>
        
    </div>

<div class="dang"></div>
            </div>
            
            <div class="terms-root">
                
                


<div class="card-large">
    <div class="card-large-img">

        
                <img class="lazyload" src="/images/thumbnail.gif" data-src="" alt='图片加载失败'>
        
    </div>
    <div class="card-large-content">
        <div class="up-title"><a href="https://cnjslw.github.io/posts/%E8%A1%A8%E8%BE%BE%E5%BC%8F/">【C&#43;&#43; Primer(edition 5) 04】表达式</a></div>
        <div class="up-date">
            <span class="no-wrap"><i class="fa fa-calendar"></i> 发布于: 2021-9-9 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> 更新于: 2021-9-9 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-folder"></i>
                
                    收录于:
                    
                        <a href='
                                        /categories/cpp
                                    '>
                                Cpp
                            </a>
                
            </span>
        </div>
        <div class="down-summary">表达式</div>
    </div>
    <div class="card-readmore">
        <a href="https://cnjslw.github.io/posts/%E8%A1%A8%E8%BE%BE%E5%BC%8F/">
            <span><i class="fa fa-arrow-right"></i></span>
        </a>
    </div>
</div>



    


    <div class="down-type">
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#cpp
                        '>
                    <i class="fa fa-tag"></i> #Cpp
                </a>
            </div>
        </span>
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7
                        '>
                    <i class="fa fa-tag"></i> #语法特性
                </a>
            </div>
        </span>
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#%E7%BC%96%E7%A8%8B
                        '>
                    <i class="fa fa-tag"></i> #编程
                </a>
            </div>
        </span>
        
    </div>

<div class="dang"></div>
            </div>
            
            <div class="terms-root">
                
                


<div class="card-large">
    <div class="card-large-img">

        
                <img class="lazyload" src="/images/thumbnail.gif" data-src="" alt='图片加载失败'>
        
    </div>
    <div class="card-large-content">
        <div class="up-title"><a href="https://cnjslw.github.io/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/">【C&#43;&#43; Primer(edition 5) 03】字符串、向量和数组</a></div>
        <div class="up-date">
            <span class="no-wrap"><i class="fa fa-calendar"></i> 发布于: 2021-9-8 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> 更新于: 2021-9-8 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-folder"></i>
                
                    收录于:
                    
                        <a href='
                                        /categories/cpp
                                    '>
                                Cpp
                            </a>
                
            </span>
        </div>
        <div class="down-summary">字符串、向量和数组</div>
    </div>
    <div class="card-readmore">
        <a href="https://cnjslw.github.io/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/">
            <span><i class="fa fa-arrow-right"></i></span>
        </a>
    </div>
</div>



    


    <div class="down-type">
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#cpp
                        '>
                    <i class="fa fa-tag"></i> #Cpp
                </a>
            </div>
        </span>
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7
                        '>
                    <i class="fa fa-tag"></i> #语法特性
                </a>
            </div>
        </span>
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#%E7%BC%96%E7%A8%8B
                        '>
                    <i class="fa fa-tag"></i> #编程
                </a>
            </div>
        </span>
        
    </div>

<div class="dang"></div>
            </div>
            
            <div class="terms-root">
                
                


<div class="card-large">
    <div class="card-large-img">

        
                <img class="lazyload" src="/images/thumbnail.gif" data-src="" alt='图片加载失败'>
        
    </div>
    <div class="card-large-content">
        <div class="up-title"><a href="https://cnjslw.github.io/posts/%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/">【C&#43;&#43; Primer(edition 5) 02】复合类型</a></div>
        <div class="up-date">
            <span class="no-wrap"><i class="fa fa-calendar"></i> 发布于: 2021-9-6 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> 更新于: 2021-9-6 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-folder"></i>
                
                    收录于:
                    
                        <a href='
                                        /categories/cpp
                                    '>
                                Cpp
                            </a>
                
            </span>
        </div>
        <div class="down-summary">复合类型</div>
    </div>
    <div class="card-readmore">
        <a href="https://cnjslw.github.io/posts/%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/">
            <span><i class="fa fa-arrow-right"></i></span>
        </a>
    </div>
</div>



    


    <div class="down-type">
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#cpp
                        '>
                    <i class="fa fa-tag"></i> #Cpp
                </a>
            </div>
        </span>
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7
                        '>
                    <i class="fa fa-tag"></i> #语法特性
                </a>
            </div>
        </span>
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#%E7%BC%96%E7%A8%8B
                        '>
                    <i class="fa fa-tag"></i> #编程
                </a>
            </div>
        </span>
        
    </div>

<div class="dang"></div>
            </div>
            
            <div class="terms-root">
                
                


<div class="card-large">
    <div class="card-large-img">

        
                <img class="lazyload" src="/images/thumbnail.gif" data-src="" alt='图片加载失败'>
        
    </div>
    <div class="card-large-content">
        <div class="up-title"><a href="https://cnjslw.github.io/posts/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/">【C&#43;&#43; Primer(edition 5) 01】变量和基本类型</a></div>
        <div class="up-date">
            <span class="no-wrap"><i class="fa fa-calendar"></i> 发布于: 2021-9-4 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> 更新于: 2021-9-4 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-folder"></i>
                
                    收录于:
                    
                        <a href='
                                        /categories/cpp
                                    '>
                                Cpp
                            </a>
                
            </span>
        </div>
        <div class="down-summary">变量和基本类型</div>
    </div>
    <div class="card-readmore">
        <a href="https://cnjslw.github.io/posts/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/">
            <span><i class="fa fa-arrow-right"></i></span>
        </a>
    </div>
</div>



    


    <div class="down-type">
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#cpp
                        '>
                    <i class="fa fa-tag"></i> #Cpp
                </a>
            </div>
        </span>
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7
                        '>
                    <i class="fa fa-tag"></i> #语法特性
                </a>
            </div>
        </span>
        
        <span class="down-type-item">
            <div class="shuxian-root">
                <div class="shuxian"></div>
            </div>
            <div class="type-text">
                <a href='
                            /tags/#%E7%BC%96%E7%A8%8B
                        '>
                    <i class="fa fa-tag"></i> #编程
                </a>
            </div>
        </span>
        
    </div>

<div class="dang"></div>
            </div>
            
        </div>
    
</div>


            </div>
            <div class="zhuti-r">
                
<div class="zhuti-r-0">
    <div class="zhuti-r-1">
        
        <div id="r1">
            

<div class="about-zuozhe">
    <div class="zuozhe">
        
            <div class="datou">
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/author.png" alt="">
            </div>
        
        <div class="name-jianjie">
            <div class="name">AWei</div>
            <div class="jianjie">
                Be Water, My Friend.
            </div>
        </div>
    </div>

    <div class="type">
        <a href='
                    /posts/
                '>
            <p>文章</p>
            <p>8</p>
        </a>
        <a href='
                    /categories/
                '>
            <p>分类</p>
            <p>1</p>
        </a>
        <a href='
                    /tags/
                '>
            <p>标签</p>
            <p>5</p>
        </a>
    </div>

    <a href="https://github.com/cnjslw">
        <div class="follow">Follow Me</div>
    </a>
    <div class="link">
        
        <a href="https://github.com/cnjslw" class="link-item is-hidden-desktop" title="GitHub">
            <span class="icon"><i class='fa fa-github'></i></span>
        </a>
        
        <a href="https://www.youtube.com" class="link-item is-hidden-desktop" title="YouTube">
            <span class="icon"><i class='fa fa-youtube'></i></span>
        </a>
        
    </div>
</div>
            <div class="mulu">
    <div class="dong"></div>
    <div class="zhi">
        <div class="wenzi">
            <div class="zhi-mulu text-wbd">目录</div>
            <div class="mulu-items">
            </div>
        </div>
    </div>
</div>
            




<div class="other">
    <div class="other-up">
        <div class="other-qita text-wbd">最新文章</div>
        <div class="xian"></div>
    </div>
    <div class="list">
        
            <a href="https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">
                
<a href="https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【模板与泛型编程01】函数模板
            </div>
            <div class="other-summary">函数模板</div>
            <div class="other-date">2022-6-8</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cnjslw.github.io/posts/%E7%B1%BB/">
                
<a href="https://cnjslw.github.io/posts/%E7%B1%BB/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【C&#43;&#43; Primer(edition 5) 07】类
            </div>
            <div class="other-summary">类</div>
            <div class="other-date">2021-9-20</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0/">
                
<a href="https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【C&#43;&#43; Primer(edition 5) 06】函数
            </div>
            <div class="other-summary">函数</div>
            <div class="other-date">2021-9-13</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cnjslw.github.io/posts/%E8%AF%AD%E5%8F%A5/">
                
<a href="https://cnjslw.github.io/posts/%E8%AF%AD%E5%8F%A5/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【C&#43;&#43; Primer(edition 5) 05】语句
            </div>
            <div class="other-summary">语句</div>
            <div class="other-date">2021-9-12</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cnjslw.github.io/posts/%E8%A1%A8%E8%BE%BE%E5%BC%8F/">
                
<a href="https://cnjslw.github.io/posts/%E8%A1%A8%E8%BE%BE%E5%BC%8F/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【C&#43;&#43; Primer(edition 5) 04】表达式
            </div>
            <div class="other-summary">表达式</div>
            <div class="other-date">2021-9-9</div>
        </div>
    </div>
</a>
            </a>
        
    </div>
</div>
        </div>
        <div id="r2">
            
        </div> 
    </div>
</div>

            </div>
        </div>
    </div>
</div>


        </div>

        <footer class="footer">
    
        <div class="container">
            <div class="footer-items">
                
                    <div class="footer-item">
                        <i class="fa fa-user"></i> <span id="busuanzi_value_site_pv"></span> |
                        <i class="fa fa-eye"></i> <span id="busuanzi_value_site_uv"></span>
                    </div>
                
                
                    <div class="footer-item">
                        © 2022-2023 <a href="https://github.com/cnjslw">AWei</a>
                    </div>
                
                
                    <div class="footer-item">
                        Theme by <a href="https://github.com/xioyito/NewBee">NewBee</a> | Powered by <a href="https://gohugo.io/">Hugo</a>
                    </div>
                
            </div>
        </div>
    

    
</footer>


        
        <div class="search-root">
    <div class="search-zz"></div>
    <div class="search">
        <div class="sheader anniu">
            <div class="sh-l">
                <input type="text" placeholder='请输入关键词' id="search-key">
                <span class="sclear"><i class="fa fa-close"></i></span>
            </div>
            <div class="sh-r">
                <button>搜索</button>
            </div>
        </div>
        <div class="sbody">
            <div class="sbody-1">
                <div class="stip"></div>
            </div>
        </div>
    </div>
</div>
        









    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    


<script type="text/javascript">
    var mode_custom = "auto";
    var postsCount =  8 ;
    var arrPosts = [{"link":"https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/","plain":"一、定义函数模板 1、基本范例 1 2 3 4 5 6 7 template \u0026lt;typename T\u0026gt; int compare(const T \u0026amp;v1 , const T \u0026amp;v2) { if(v1 \u0026lt; v2) return -1; if(v2 \u0026lt; v1) return 1; return 0; } 模板定义以关键字 template开始，后接模板形参表，模板形参表是用尖括号\u0026lt;\u0026gt;括住的一个或多个模板形参的列表，用逗号分隔，不能为空。\n模板程序应该尽量减少对实参类型的要求。 函数模板和类模板成员函数的定义通常放在头文件中。 2、模板参数 2.1 类型参数 类型参数前必须使用关键字class或者typename，这两个关键字含义相同，可以互换使用。旧的程序只能使用class。但是有些时候，class并不合适\n2.2 默认参数 1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename T , typename F = FunType\u0026gt; void TestFunc(T i , T j , F funcpoint=mf) { cout\u0026lt;\u0026lt;funcpoint(i,j)\u0026lt;\u0026lt;endl; } int main() { TestFunc(15,16); return 0; } 调用testfunc()函数的时候，不用指定第3个实参，因为第3个参数有默认值。要注意默认参数的写法：针对当前的范例，类型模板参数F给了默认值，函数的形参也给了默认值。默认模板参数F是一个函数指针类型（FuncType），函数参数funcpoint = mf中的mf是函数名，代表函数首地址\n另外，函数模板的默认模板参数可以放在前面（这一点类模板默认模板参数不一样，类模板的模板参数一旦有一个是默认参数，则其后续的参数都需要是默认参数）。\n2.3 非类型参数 除了定义类型参数，还可以在模板中定义非类型参数(nontype parameter) 表示一个值而非一个类型。 当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达，从而允许编译器在编译时实例化模板。\n1 2 3 4 5 6 7 8 9 template\u0026lt;unsigned N , unsigned M\u0026gt; int compare(const char (\u0026amp;p1)[N] , const char (\u0026amp;p2)[M]) { return strcmp(p1,p2); } compare(\u0026#34;hi\u0026#34; , \u0026#34;mom\u0026#34;); //实例化模板 //int compare(const char (\u0026amp;p1)[3] , const char (\u0026amp;p2)[4]) 一个非类型参数可以是一个整形，或者是一个指向对象或函数类型的指针或引用，绑定到非类型整数参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参，必须具有静态的生存期。\n但是，并不是任何类型的参数都可以作为非类型模板参数，一般有以下一些是允许的 （1）整型或枚举类型。 （2）指针类型。 （3）左值引用类型。 （4）auto或decltype(auto)。对于decltype(auto)这个用法，其中的auto理解成要推导的类型，而decltype理解成推导过程采用decltype推导。 （5）可能还有其他类型，请读者自行在学习或阅读他人代码的过程中收集和总结。\n二、 实例化函数模板 这里可以给实例化一个定义：用具体的“类型”代替“类型模板参数”的过程就叫作实例化（也称为代码生成器）。\n1、一个错误的实例化示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template \u0026lt;typename T\u0026gt; T sub(T tv1 , T tv2) { return tv1 - tv2; } int main() { int v1 = 1; int v2 = 2; sub(v1,v2);//return -1 string s1 = \u0026#34;Hello\u0026#34;; string s2 = \u0026#34;World\u0026#34;; sub(s1,s2);//报错 return 0; } 所以，同样一个函数模板，可能以某种方式进行调用是合法的，而换一种方式调用就不合法了。尤其值得注意的是，这种合法性，在==编译阶段就可以由编译器判断出来==，因为这些对Sub()函数模板的调用代码就在这里摆着，编译器有能力在编译时就从这些调用代码中去推断Sub()函数模板中的模板参数T的类型。根据模板参数T的类型，编译器就能够判断出这个类型是否支持减法运算。\n2、编译器视角的实例化 1 2 sub(1,2); sub(1.1 , 2.2); 1 2 //.obj int __cdecl sub\u0026lt;int\u0026gt;(int,int) double __cdecl sub\u0026lt; double \u0026gt;( double, double) 这说明在编译阶段，在对模板进行具体针对某类型的实例化之前，编译器需要查看函数模板的函数体，确定能否针对该类型进行实例化\n当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码\n当编译器遇到类和普通函数\n普通函数 当我们调用一个函数时，编译器只需要掌握函数的声明 类 当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现 我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中 为了生成个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义，所以函数模板与类模板成员函数的定义通常放在头文件中。\n3、模板参数的实例化 1 2 3 4 5 template\u0026lt;typename T\u0026gt; T mydouble(T tmpvalue) { return tmpvalue * 2; } 3.1 显示实例化 1 2 int result = mydouble\u0026lt;int\u0026gt;(16); int result = mydouble\u0026lt;int\u0026gt;(17.7);//warning C4244: “参数”: 从“double”转换到“T”，可能丢失数据 3.2 隐式实例化 1 2 3 cout \u0026lt;\u0026lt; compare(1,0) \u0026lt;\u0026lt; endl; //实例化出一个特别版本的函数 //compare(const int\u0026amp; , const int\u0026amp;); 编译器用函数实参来为我们推断模板实参，实参类型是int。编译器会推断出模板实参为int , 并将它绑定到模板参数T。 编译器用推断出的模板参数来为我们实例化(instantiate) 一个特定版本的函数\n隐式实例化下的空参数列表\n1 auto result = mydouble\u0026lt;\u0026gt;(16.9); \u0026lt; \u0026gt;的作用：\u0026lt; \u0026gt;没什么用处，但是当有一个也叫作mydouble()的普通函数存在时，\u0026lt; \u0026gt;也许就会发挥作用\n3.3 部分实例化 1 2 3 4 5 6 7 8 9 10 11 12 template \u0026lt;typename V,typename T,typename U\u0026gt; V Add(T tv1, U tv2) { return tv1 + tv2; } int main() { Add(15,17.8);//error C2672: “Add”\u0026#34;: 找到匹配的重载函数 error C2783: “V Add(T,U)”: 未能为“V”推导模板参数 Add\u0026lt;double\u0026gt;(1.1 , 2); // return 3.1 return 0; } 通过尖括号指定一部分模板参数，另外一部分模板参数可以让编译器去推断。但是，一旦从某个模板参数开始推断，后续的所有模板参数都需要让编译器推断，==不可以自己指定第1个类型V和第3个类型U，然后推断中间第2个类型T，编译器不支持这种语法。==\n3.4 特化 1 2 3 4 5 6 7 template \u0026lt;typename T, typename U\u0026gt; void tfunc(T\u0026amp; tmprv, U\u0026amp; tmprv2) { cout \u0026lt;\u0026lt; \u0026#34;tfunc泛化版本\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; tmprv \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; tmprv2 \u0026lt;\u0026lt; endl; } 3.4.1 全特化 所谓全特化，就是把tfunc()这个泛化版本中的所有模板参数都用具体的类型代替，构成一个特殊的版本（全特化版本），既然所有模板参数都用具体的类型代替了，那么tfunc()泛化版本中template后面尖括号中的内容就变成空了。\n1 2 3 4 5 template\u0026lt;\u0026gt; void tfunc\u0026lt;int , double\u0026gt;(int\u0026amp; tmprv, double\u0026amp; tmprv2) { cout\u0026lt;\u0026lt;\u0026#34;tfunc特化\u0026#34;\u0026lt;\u0026lt;endl; } 全特化实际上等价于实例化一个函数模板，并不等价于一个函数重载\n1 2 3 4 void tfunc(int\u0026amp; tmprv, double\u0026amp; tmprv2) { cout\u0026lt;\u0026lt;\u0026#34;tfunc函数重载\u0026#34;\u0026lt;\u0026lt;endl; } ==调用优先级：普通函数 \u0026gt; 函数模板特化 \u0026gt; 函数模板泛化==\n3.4.2 偏特化 （1）模板参数数量上的偏特化 What is : 特化第1个模板参数类型为double类型，但第2个模板参数不特化\n实际上，从模板参数数量上来讲，函数模板不能偏特化，只有类模板才能偏特化\n（2）模板参数范围上的偏特化 What is : 所谓“参数范围”，比如原来是int类型，如果变成const int类型，那么与int类型相比，const int类型的范围就变小了；再比如，如果原来是任意类型T，现在变成T *（从任意类型缩小为任意指针类型），那这个类型的范围也是变小了；还有T \u0026amp;（左值引用）、T\u0026amp;\u0026amp;（右值引用），对于T，从类型范围上都属于变小了。\n对于函数模板，也不存在模板参数范围上的偏特化。因为这种所谓模板参数范围上的偏特化，实际上是函数模板的重载\n1 2 3 4 5 template \u0026lt;typename T , typename U\u0026gt; void tfunc(const T\u0026amp; tmprv1, U\u0026amp; tmprv2) { cout\u0026lt;\u0026lt;\u0026#34;函数模板的参数范围偏特化本质上是函数模板的重载\u0026#34;\u0026lt;\u0026lt;endl; } 3.5 实例化模板的返回值问题 显示实例化 1 Add\u0026lt;double\u0026gt;(1.1 , 3); auto 使用auto结合decltype完成返回值类型推断 1 2 3 4 5 6 template \u0026lt;typename V,typename T,typename U\u0026gt; auto Add(T tv1, U tv2) //auto Add(T tv1, U tv2) -\u0026gt; decltype(tv1 + tv2) { return tv1 + tv2; } 三、特异的语法 1、省略参数 不管是类型模板参数还是非类型模板参数，如果在代码中没有用到这个参数，则参数名可以省略\n1 2 3 template \u0026lt;typename T ,int value\u0026gt; auto Add2() {return 100;} 可以做如下省略\n1 2 3 template \u0026lt;typename ,int\u0026gt; auto Add2() {return 100;} 2、\u0026ldquo;无用\u0026quot;的typename 类型前面可以增加一个typename修饰以明确标识一个类型。有的时候为了表明其后面是一个类型，也需要用typename修饰\n1 2 3 4 5 template \u0026lt;typename T , typename int value\u0026gt; auto Add() { return 100; } 四、模板函数在工程中 1、inline和constexpr的含函数模板 inline或 constexpr说明符放在模板参数列表之后，返回类型之前：\n1 2 template \u0026lt;typename T\u0026gt; inline T min(const T\u0026amp;, const T\u0026amp;); template \u0026lt;typename T\u0026gt; constexpr T min(const T\u0026amp; , const T\u0026amp;); 2、编写与类型无关的代码 1 2 3 4 5 6 template \u0026lt;typename T\u0026gt; int compare(const T \u0026amp;v1 , const T \u0026amp;v2) { if(less\u0026lt;T\u0026gt;()(v1,v2)) return -1; if(less\u0026lt;T\u0026gt;()(v2,v1)) return 1; return 0; } 这样写的好处\nconst T \u0026amp;作为函数参数可以避免实参是不可调用类型 less\u0026lt;T\u0026gt;()使用标准库可以避免有些类型没有定义\u0026gt;的比较 ","pubDate":"2022-06-08","title":"【模板与泛型编程01】函数模板"},{"link":"https://cnjslw.github.io/posts/%E7%B1%BB/","plain":" 类背后的基本思想：数据抽象（data abstraction）和封装（encapsulation）。 数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程技术。 封装实现了类的接口和实现的分离 一、定义抽象数据类型 1 2 3 class CLASSNAME{ //类成员 }; 1、类成员 （Member） 必须在类的内部声明，不能在其他地方增加成员。 成员可以是数据，函数，类型别名。 使用点运算符 . 调用成员函数 1.1 类的成员函数 成员函数的声明必须在类的内部。 成员函数的定义既可以在类的内部也可以在外部。 1 2 3 4 5 6 7 8 class ClassExample{ //... double avg_price() const; }; double ClassExample::avg_price() const{ //... } 必须对任何const或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。\n默认实参： Sales_item(const std::string \u0026amp;book): isbn(book), units_sold(0), revenue(0.0) { } 1.2 非成员函数 和类相关的非成员函数，定义和声明都应该在类的外部。\n1.3 常成员 1.3.1 常成员函数 若将成员函数设置为常成员函数，则只能引用本类中的数据成员，而不能修改它；常成员函数可以引用const数据成员，也可以引用非const的数据成员；常成员函数的一般形式为：\n1 类型名 函数名(形参列表) const 这里的const关键字是函数类型的一部分，在函数声明和函数定义时都要带const关键字，否则被编译器认为是不同的两个函数，但是在函数调用的时候不必带const；\n1 bool same_isbn(const Sales_item \u0026amp;rhs) const 这种函数称为“常量成员函数”（this指向的当前对象是常量）。\n这样做的好处是\n既可以将this绑定到常量对象上，也可以绑定到普通对象上（[[变量和基本类型#3、指针和const|指针与const的特殊性]]），提高了函数的灵活性 程序是安全的 ⚠️C++ 中常对象只能调用类中的常方法，但是常成员方法可以使用非常量数据成员 这是正确的。常对象是不能修改对象状态的，因此只能调用类中标记为常的方法，即常方法。如果试图调用非常方法，编译器会生成错误。因此，常对象可以保证对象状态不会被意外修改。常成员函数可以引用const数据成员，也可以引用非const的数据成员\n1 2 3 4 5 6 7 8 9 10 11 12 13 class A { public: A(){} void test1(){} void test2()const{} }; const A a; A b; a.test1(); //× a.test2(); //√ b.test1(); //√ b.test2(); //√ 常方法返回的任何值都具有常性 常方法返回的任何值都具有常性，不论是指针还是引用。这意味着，不能通过常方法返回的指针或引用来修改对象的值。然而，非常量方法则允许通过其返回的指针或引用来修改对象的值。\n1.3.2 常数据成员 如果我们希望在创建对象后，该对象的某个数据成员就保持不变，我们可以将这个数据成员设置为常数据成员；常数据成员只能通过构造函数初始化列表进行初始化，其他形式的函数均不能进行数据的赋值；\n数据成员 非const的普通成员函数 const成员函数 非const的普通数据成员 可以引用，也可以改变值 可以引用，但是不可以改变值 const数据成员 可以引用，但是不能改变值 可以引用，但是不可以改变值 const对象 不允许 可以引用，但是不可以改变值 1.4 this 每个成员函数都有一个额外的，隐含的形参this。 this总是指向当前对象，因此this是一个常量指针。 return *this;可以让成员函数连续调用。 1 2 3 4 5 6 Sale_data \u0026amp;Sales_data::combine(const Sales_data \u0026amp;rhs) { units_sold += rhs.units_sold; // revenue += rhs.revenue; return *this; } 形参表后面的const，改变了隐含的this形参的类型，如普通成员函数中的this类型为 CLASSNAME *const，而当声明常量成员函数后this类型为 const CLASSNAME *const\n普通的非const成员函数：this是指向类类型的const指针（可以改变this所指向的值，不能改变this保存的地址）。 const成员函数：this是指向const类类型的const指针（既不能改变this所指向的值，也不能改变this保存的地址）。 1.5 类的静态成员 非static数据成员存在于类类型的每个对象中。 static数据成员独立于该类的任意对象而存在。 每个static数据成员是与类关联的对象，并不与该类的对象相关联。\n声明 声明之前加上关键词static。\n使用 使用作用域运算符::直接访问静态成员:r = Account::rate(); 也可以使用对象访问：r = ac.rate();\n定义 在类外部定义时不用加static\n初始化 静态数据成员通常不在类的内部初始化，而是在定义时进行初始化，如 double Account::interestRate = initRate(); 如果一定要在类内部定义，则要求必须是字面值常量类型的constexpr。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Account ( public: void calculate() ( amount += amount * interestRate; ) static double rate() ( return interestRate; } static void rate(double); private: std::string owner; double amount； static double interestRate; static double initRate(); }; //静态成员函数的内外定义 void Account::rate(double newRate) {interestRate = newRate;} //静态数据成员的定义 double Account::interestRate = initRate(); //可以直接访问私有成员函数 double r ; r = Account::rate(); Account ac1; Account *ac2 = \u0026amp;ac1; r = ac1.rate(); r=ac2-\u0026gt;rate(); interestRate被所有Account对象共享 rate不包含this指针，不能声明成const 2、类的构造函数 类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。\n构造函数是特殊的成员函数。 构造函数放在类的public部分。 与类同名的成员函数。 2.1 默认构造函数 类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数(default constructor)，默认构造函数无须任何实参。编译器创建的构造函称为合成的默认构造函数。只有当类没有构造函数时，编译器才会这样做。 默认构造函数按照如下规则初始化类\n如果类内存在成员的初始值，则用它来初始化成员\n否则，默认初始化成员\n=default要求编译器合成默认的构造函数。(C++11)\n2.2 构造函数初始值列表 1 Sales_item(const std::string \u0026amp;s):bookNo(s),units_sold(0), revenue(0.0) { } 总之，没有出现在构造函数初始值列表中的成员将通过相应的类内初始值（如果存在）初始化，或者执行默认初始化\n1. const、引用类型的成员初始化 但还需要注意一个问题，有些时候有成员是必须通过初始值列表来初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class ConstRef{ public: ConstRef(int ii); private: int i ; const int ci; int \u0026amp;ri; } ConstRef::ConstRef(int ii) { i=ii; ci=ii; //WRONG ri=i; //WRONG } 随着构造函数体一开始执行，初始化就完成了!! 初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值\n1 ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) { } 2. 初始化顺序问题 构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序，执行顺序与其在类定义中出现的顺序一致 ^172c2c\n1 2 3 4 5 6 class X{ int i; int j; public: X(int val):j(val),i(j){} //真实的顺序为先初始化i，然后j，所以报错 } 2.3 委托构造函数 （delegating constructor, C++11） 委托构造函数将自己的职责委托给了其他构造函数。\nSale_data(): Sale_data(\u0026quot;\u0026quot;, 0, 0) {}\n2.4 转换构造函数 如果类的构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，这种构造函数成为转换构造函数\n在Sales_data类中，接受string的构造函数和接受istream的构造函数分别定义了从这面一种类型向Sales_data隐式转换的规则。 也就是说，在需要使用 Sales_data的地方，我们可以使用string或者istream作为替代：\n1 2 3 4 string null_book = \u0026#34;9-999-99999-9”; //构造一个临时的Sales_data时象 // 该时象的 units_sold 和 revenue 等于 0, bookNo 等于 null_book item.combine(null_book); 在这里我们用一个string实参调用了 Sales_data的combine成员。该调用是合法 的，编译器用给定的string自动创建了一个Sales_data对象。新生成的这个(临时) Sales_data对象被传递给combine。因为combine的参数是一个常引用，所以我们可以给该参数传递一个临时量\n但是只允许一步类类型转换\n1 item.combine(\u0026#34;9-999-99999-9”); 这种就是错误的，因为暗含了两种类型的转换，\u0026ldquo;9-999-99999-9”转换为string，string转换为Sales_data\n1 2 item.combine(string(\u0026#34;9-999-99999-9”)); item.combine(Sales_data(\u0026#34;9-999-99999-9”)); explicit抑制构造函数定义的隐式转换\n使用关键词explicit，有以下限制：\n只对一个实参的构造函数有效 只能在类内声明构造函数时使用关键字，类外部定义时不应重复 只能阻止隐式转换，但是不能阻止显示转换 只能用于直接初始化，不能用于拷贝形式的初始化。 1 2 3 4 5 6 7 8 class Salesdata { public: Sales_data() = default； Sales data (const std::string \u0026amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) { ) explicit Sales_data(const std::string \u0026amp;s):bookNo(s) { } explicit Sales_data(std::istream\u0026amp;); }； 1 2 3 4 string null_book(\u0026#34;999-999-999999\u0026#34;); Sales_data it item(null_book) ;\t// 正确：直接初始化 //错误：不能将explicit构造函数用于拷贝形式的初始化过程 Sales data item2 = null_book; 1 2 3 4 //正确：实参是一个显式构造的Sales_data对象 item.combine(Sales_data(null_book)); //正确：static_cast可以使用explicit的构造函数 item.combine(static cast\u0026lt;Sales data\u0026gt;(cin)); 3、拷贝构造函数 todo\n4、赋值函数 todo\n5、析构函数 当对象不在存在执行销毁操作，销毁的操作由类的析构函数完成\n6、关于构造、拷贝、赋值、析构函数的总结和深入 这四种成员函数，编译器会在没有定义时，生成默认构造、拷贝、赋值、析构函数 有些类不能依赖编译器生成的版本，因为这是不安全的 7、对象 对象是类的实例化，分为普通对象和常对象 定义普通对象的方法\n1 2 ClassName a; ClassName *a = new ClassName; 常对象是指该对象在其生命周期内，其所有的数据成员的值都不能被改变；定义对象时加上关键字const，该对象就是常对象，其一般形式如下：\n1 2 3 4 5 类名 const 对象名[(实参类别)]; 或者 const 类名 对象名[(实参类别)]; const CComplex num; 对象可以用.来访问成员 指向对象的指针用-\u0026gt;来访问成员 二、 聚合类 （aggregate class） 满足以下所有条件： 所有成员都是public的。 没有定义任何构造函数。 没有类内初始值。 没有基类，也没有virtual函数。 可以使用一个花括号括起来的成员初始值列表，初始值的顺序必须和声明的顺序一致。 1 2 3 4 5 6 struct Data{ int ival; string s; }; Data val1={0,\u0026#34;Anna\u0026#34;}; 如果初始值列表中的元素个 数少于类的成员数量，则靠后的成员被值初始化。 初始值列表的元素个数绝对不能超过类的成员数量。 C++中引入聚合类的主要原因是为了方便地对一组相关的数据进行组织和管理。聚合类可以看作是一个数据容器，它把多个数据成员封装在一起，形成一个单独的数据单元，从而更加方便地使用这些数据。通过将相关的数据成员放在同一个聚合类中，我们可以更好地组织代码，提高代码的可读性和可维护性。此外，聚合类还可以减少代码量，避免出现过多的全局变量或结构体定义，从而使代码更加简洁、易于理解和维护。另外，聚合类也为C++的面向对象编程提供了一种新的方式。通过定义成员函数和重载操作符等方法，我们可以对聚合类进行更加灵活和方便的操作，实现更优雅的代码设计。最后，值得注意的是，虽然聚合类和结构体看起来很相似，但它们在语义上有所不同。聚合类更强调对数据的组织和封装，而结构体则更强调对数据的描述和表示。因此，在选择使用聚合类还是结构体时，需要根据具体的应用场景和需要进行选择。\n一个比较典型的必须要使用聚合类的场景是数据库中的数据表。在实际开发中，我们通常需要使用一种数据结构来表示数据库中的数据表，这个数据结构需要包含每一行数据的各个字段，以及相关的属性和方法。对于这种情况，使用聚合类可以非常方便地组织和管理数据表中的数据。我们可以将每一行数据看作是一个对象，把所有行对象放在同一个聚合类中，形成一个数据表对象。这个聚合类可以包含各种成员函数和操作符重载，用于实现数据表的各种查询、排序、更新等操作。\n三、 字面值常量类 constexpr函数的参数和返回值必须是字面值。 字面值类型：除了算术类型、引用和指针外，某些类也是字面值类型。 数据成员都是字面值类型的聚合类是字面值常量类。 如果不是聚合类，则必须满足下面所有条件： 数据成员都必须是字面值类型。 类必须至少含有一个constexpr构造函数。 如果一个数据成员含有类内部初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。 类必须使用析构函数的默认定义，该成员负责销毁类的对象。 四、访问控制与封装 访问说明符（access specifiers）： public：定义在 public后面的成员在整个程序内可以被访问； public成员定义类的接口。 private：定义在 private后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； private隐藏了类的实现细节。 使用 class或者 struct：都可以被用于定义一个类。唯一的却别在于访问权限。 使用 class：在第一个访问说明符之前的成员是 priavte的。 使用 struct：在第一个访问说明符之前的成员是 public的。 1、友元 允许特定的非成员函数访问一个类的私有成员. 友元的声明以关键字 friend开始。 friend Sales_data add(const Sales_data\u0026amp;, const Sales_data\u0026amp;);表示非成员函数add可以访问类的非公有成员。 通常将友元声明成组地放在类定义的开始或者结尾。 类之间的友元： 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。 2、封装的益处 确保用户的代码不会无意间破坏封装对象的状态。 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。 五、类的其他特性 成员函数作为内联函数 inline： 在类的内部，常有一些规模较小的函数适合于被声明成内联函数。 定义在类内部的函数是自动内联的。 在类外部定义的成员函数，也可以在声明时显式地加上 inline。 可变数据成员 （mutable data member）： mutable size_t access_ctr; 永远不会是const，即使它是const对象的成员。 类类型： 每个类定义了唯一的类型。 六、类的作用域 每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。 函数的返回类型通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。 如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。 类中的类型名定义都要放在一开始。 ","pubDate":"2021-09-20","title":"【C++ Primer(edition 5) 07】类"},{"link":"https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0/","plain":"一、函数基础 函数定义：函数是一个命名了的代码块。 编写函数：包括返回类型、函数名字和0个或者多个形参（parameter）组成的列表和函数体。 调用运算符调用函数：调用运算符的形式是一对圆括号 ()，作用于一个表达式，该表达式是函数或者指向函数的指针。 圆括号内是用逗号隔开的实参（argument）列表。 函数调用过程： 1.主调函数（calling function）的执行被中断。 2.被调函数（called function）开始执行。 形参和实参：形参和实参的个数和类型必须匹配上。 返回类型： void表示函数不返回任何值。函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。 名字：名字的作用于是程序文本的一部分，名字在其中可见。 1、局部对象 生命周期：对象的生命周期是程序执行过程中该对象存在的一段时间。 局部变量（local variable）：形参和函数体内部定义的变量统称为局部变量。它对函数而言是局部的，对函数外部而言是隐藏的。 自动对象：只存在于块执行期间的对象。当块的执行结束后，它的值就变成未定义的了。 局部静态对象： static类型的局部变量，生命周期贯穿函数调用前后。 2、函数声明 函数声明：函数的声明和定义唯一的区别是声明无需函数体，用一个分号替代。函数声明主要用于描述函数的接口，也称函数原型。 在头文件中进行函数声明：建议变量在头文件中声明；在源文件中定义。 分离编译： CC a.cc b.cc直接编译生成可执行文件；CC -c a.cc b.cc编译生成对象代码a.o b.o； CC a.o b.o编译生成可执行文件。 二、参数传递 形参初始化的机理和变量初始化一样。 引用传递（passed by reference）：又称传引用调用（called by reference），指形参是引用类型，引用形参是它对应的实参的别名。 值传递（passed by value）：又称传值调用（called by value），指实参的值是通过拷贝传递给形参。 1、传值参数 当初始化一个非引用类型的变量时，初始值被拷贝给变量。 函数对形参做的所有操作都不会影响实参。 指针形参：常用在C中，C++建议使用引用类型的形参代替指针。 2、传引用参数 通过使用引用形参，允许函数改变一个或多个实参的值。 引用形参直接关联到绑定的对象，而非对象的副本。 使用引用形参可以用于返回额外的信息。 经常用引用形参来避免不必要的复制。 void swap(int \u0026amp;v1, int \u0026amp;v2) 如果无需改变引用形参的值，最好将其声明为常量引用。 3、const形参和实参 形参的顶层const被忽略。void func(const int i);调用时既可以传入const int也可以传入int。 我们可以使用非常量初始化一个底层const对象，但是反过来不行。 在函数中，不能改变实参的局部副本。 尽量使用常量引用。 4、数组形参 4.1 数组形参的定义 因为不能拷贝数组，所以无法以值传递的方式使用数组参数，因为数组会转换成指针，所以当为函数传递一个数组时，实际上传递的是指向数组首元素的指针\n1 2 3 4 5 6 7 8 9 void print(const int *); void print(const int[]); void print(const int[10]); //这里的10只是期望数组含有多少元素，实际不一定 //三种print函数声明等价,形参都是const int* 类型 int i = 0 , j[2] = {0,1}; print(\u0026amp;i); print(j); 4.2 数组形参的越界问题 要注意在函数中使用数组时，不能越界。管理指针形参有三种常用的技术。\n1. 使用标记指定的数组长度 管理数据实参的第一个方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。C风格的是字符串是以\\0为结束的，函数在处理C风格字符串时，遇到空字符停止\n1 2 3 4 5 6 void print(const char *cp) { if(cp) //非空指针 while(*cp) //非空字符 count \u0026lt;\u0026lt; *cp++; } 2.使用标准库规范 管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针\n1 2 3 4 5 6 7 8 void print(const int *beg , const int *end) { while(beg != end) cout \u0026lt;\u0026lt;*beg++\u0026lt;\u0026lt;endl; } int j[2]={0,1}; print(begin(j),end(j)); 3.显示传递一个表示数组大小的形参 第三种管理方法，就是专门定义一个表示数组大小的形参\n1 2 3 4 5 6 7 8 9 void print(const int ia[], size_t size) { for(size_t i=0 ; i != size ; ++i){ cout\u0026lt;\u0026lt;ia[i]\u0026lt;\u0026lt;endl; } } int j[] = {0,1}; print(j,end(j)-begin(j)); 4.3 数组引用形参 1 2 3 4 5 6 7 8 f(int \u0026amp;arr[10]); //arr是一个数组，每一个元素都引用变量 f(int (\u0026amp;arr)[10]); //arr是引用变量，指向一个含有10个元素的数组 int i = 0 , j[2] = {0,1}; int k[10] = {0,1,2,3,4,5,6,7,8,9}; f(\u0026amp;i); //错误 f(j); //错误 f(k); //正确 4.4 传递多维数组 1 void print(int (*matrix)[10] , int rowSize); 5、main处理命令行选项 int main(int argc, char *argv[]){...} 第一个形参代表参数的个数；第二个形参是参数C风格字符串数组。 6、可变形参 如果函数的实参数量未知但是全部实参的类型都相同，可以使用initializer_list类型的形参，这是一种标准库类型，用于表示某种特定类型的值的数组。定能一在同名头文件中。\ninitializer_list提供的操作（C++11）：\n操作 解释 initializer_list\u0026lt;T\u0026gt; lst; 默认初始化；T类型元素的空列表 initializer_list\u0026lt;T\u0026gt; lst{a,b,c...}; lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是const。 lst2(lst) 拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 lst2 = lst 同上 lst.size() 列表中的元素数量 lst.begin() 返回指向lst中首元素的指针 lst.end() 返回指向lst中微元素下一位置的指针 initializer_list使用demo：\n1 2 3 4 5 6 7 8 void err_msg(ErrCode e, initializer_list\u0026lt;string\u0026gt; il){ cout \u0026lt;\u0026lt; e.msg \u0026lt;\u0026lt; endl; for (auto bed = il.begin(); beg != il.end(); ++ beg) cout \u0026lt;\u0026lt; *beg \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } err_msg(ErrCode(0), {\u0026#34;functionX\u0026#34;, \u0026#34;okay}); 所有实参类型相同，可以使用 initializer_list的标准库类型。 实参类型不同，可以使用可变参数模板。 省略形参符： ...，便于C++访问某些C代码，这些C代码使用了 varargs的C标准功能。 三、返回类型和return语句 1、无返回值函数 没有返回值的 return语句只能用在返回类型是 void的函数中，返回 void的函数不要求非得有 return语句。\n2、有返回值函数 return语句的返回值的类型必须和函数的返回类型相同，或者能够隐式地转换成函数的返回类型。\n2.1 值是如何被返回的 ![[c++ 临时对象以及引用的一些知识]] 返回的值用于初始化调用点的一个临时量(除了指针和引用)，该临时量就是函数调用的结果。\n函数返回的是一个string对象，意味着返回值将被拷贝到调用点，因此，该函数返回word的副本或者一个未命名的临时string对象\n1 2 3 4 5 6 7 string make_plural(size_t ctr , const string \u0026amp;word, const string \u0026amp;ending) { return (ctr \u0026gt; 1) ? word+ending : word; } string word = make_plural(0,word,\u0026#34;s\u0026#34;); 如果函数返回引用，该引用仅是它所引用对象的一个别名\n2.2 不要返回局部对象的引用或指针 1 2 3 4 5 6 7 8 9 // 严重错误：这个函数试图返回局部对象的引用 const string \u0026amp;mainp() { string ret ; if(!ret.empty()) return ret; else return \u0026#34;Empty\u0026#34;; } 返回局部对象的引用是错误的；同样，返回局部对象的指针也是错误的。 一旦函数完成，局部对象被释放，指针将指向一个不存在的对象。要想确保返回值的安全，不妨提问：引用所引（指针所指向）的是在函数之前已经存在的哪个对象？\n⚠️不要，而不是不能 ![[C++中返回临时变量指针问题]]\n2.3 返回类类型的函数和调用运算符 1 2 //调用string对象的size成员，该string对象是由shorterString函数返回的 auto sz = shorterString(s1,s2).size(); 2.4 引用返回左值 函数的返回类型决定函数调用是否是左值。==调用一个返回引用的函数得到左值==；其他返回类型得到右值。\n2.5 列表初始化返回值 函数可以返回花括号包围的值的列表。（C++11） 此处的列表也用来对表示函数返回的临时量进行初始化\n1 2 3 4 5 6 7 8 9 10 vector\u0026lt;string\u0026gt; process() { //string expected , actual if(expected.empty()) return {}; else if(expected == actual) return {\u0026#34;functionX\u0026#34; ,\u0026#34;okay\u0026#34;}; else return {\u0026#34;fuctionX\u0026#34;,expected,actual}; } 如果函数返回的是内置类型,则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间。如果函数返回的是类类型，由类本身定义初始值如何使用。\n2.6 主函数main的返回值 main函数可以没有return语句直接结束 如果结尾没有return，编译器将隐式地插入一条返回0的return语句。返回0代表执行成功。main的返回值可以看作状态指示器，0表示成功，其他表示失败，其中非0的具体含义根据机器定夺，如果期望返回值与机器无关，则可调用cstdlib头文件中定义的两个预处理变量\n1 2 3 4 5 6 7 int main() { if(some_failure) return EXIT_FAILURE; else return EXIT_SUCCESS; } 其为预处理变量，所以不用在前面添加std::\n2.7 返回数组指针 因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。虽然从语法上来说，要想定义一个返回数组的指针或引用 的函数比较烦琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名：\n1 2 3 typedef int arrT[10]; //arrT是包含10个整数的数组 using arrT = int[10]; //等价声明 arrT* func() {...} //func返回一个指向含有10个整数的数组指针 如果不使用类型别名\n1 int (*func(int i))[10] func (int i)表示调用func函数时需要一个int类型的实参。 (*func(int i))意味着我们可以对函数调用的结果执行解引用操作。 (*func(int i)) [10]表示解引用func的调用将得到一个大小是10的数组, int (*func (int i)) [10]表示数组中的元素是int类型 使用 decltype 如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型\n1 2 3 4 5 6 int odd[] = {1,3,5,7,9}; int even[] = {2,4,6,8,10}; decltype(odd) *arrPtr(int i) { return ( i%2 ) ? \u0026amp;odd : \u0026amp;even; } 尾置返回类型 使用尾置返回类型 (trailing return type)。任何函数的定义都能使用，但是这种形式对返回类型复杂的函数最有效，比如返是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以-\u0026gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，在本应该出现返回类型的地方放置一个auto：\n1 auto func(int i) -\u0026gt; int(*)[10] 四、函数重载 1、重载概念 重载：如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载（overload）函数。 main函数不能重载。 重载和const形参： 一个有顶层const的形参和没有它的函数无法区分。 Record lookup(Phone* const)和 Record lookup(Phone*)无法区分。 相反，是否有某个底层const形参可以区分。 Record lookup(Account*)和 Record lookup(const Account*)可以区分。 重载和作用域：若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名。 2、函数匹配 重载函数匹配的三个步骤：1.候选函数；2.可行函数；3.寻找最佳匹配。 候选函数：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。 可行函数：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。 寻找最佳匹配：基本思想：实参类型和形参类型越接近，它们匹配地越好。 1 2 3 4 5 6 7 8 9 10 11 12 string read(); void print(const string \u0026amp;); void print(double); void fooBar(int val) { bool read = false; string s = read(); //WRONG void print(int); print(\u0026#34;Value:\u0026#34;); //WRONG print(val); print(3.14); } 五、特殊用途语言特性 1、默认实参 string screen(sz ht = 24, sz wid = 80, char backgrnd = ' '); 一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值。 2、内联（inline）函数 普通函数的缺点：调用函数比求解等价表达式要慢得多。 inline函数可以避免函数调用的开销，可以让编译器在编译时内联地展开该函数。 inline函数应该在头文件中定义。 1 2 cout \u0026lt;\u0026lt; shorterString(s1,s2)\u0026lt;\u0026lt;endl; //inline cout \u0026lt;\u0026lt; (s1.size() \u0026lt; s2.size() ? s1 : s2) \u0026lt;\u0026lt;endl; //编译时 3、constexpr函数 指能用于常量表达式的函数。编译器会把所有调用constexpr函数的地方替换成结果值，被隐式的指定成内联函数 函数的返回类型及所有形参类型都要是字面值类型，并且有且仅有一条return语句 1 2 3 4 5 6 7 8 constexpr int new_sz() {return 42;} constexpr int foo = new new_sz(); //foo是一个常量表达式 //返回值可以不是常量 constexpr size_t scale(size_t cnt){return new_sz()*cnt;} int arr[scale(2)]; int i =2 ; int a2[scale(i)]; //WRONG constexpr函数应该在头文件中定义。 4、调试帮助 4.1 assert 预处理宏（preprocessor macro） assert(expr); 如果expr为假（0），输出信息并终止程序的执行 如果为真（1），什么也不做 定义在cassert头文件中，预处理器而不是编译器管理\n4.2 NDEBUG assert的行为依赖于一个名为NDEBUG的预处理变量，该变量定义，则不是执行，未定义，则执行检查\n定义NDEBUG的方法\n利用#define NDEBUG 关闭assert 利用编译器参数控制调试状态： CC -D NDEBUG main.c可以定义这个变量NDEBUG。 利用NDEBUG编写条件调试代码 如果定义了NDEBUG，忽略掉调试代码 如果未定义NDEBUG，执行 #ifndef 和 #endif之间的代码\n1 2 3 4 5 void print(){ #ifndef NDEBUG cerr \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; #endif } 预处理器定义的一些变量\n变量名 含义 __FILE__ 存放文件名的字符串字面量 __LINE__ 存放当前行号的整型字面值 __FILE__ 存放文件编译时间的字符串字面值 __FILE__ 存放文件编译日期的字符串字面量 六、函数指针 1、函数指针 是指向函数的指针。 bool (*pf)(const string \u0026amp;, const string \u0026amp;); 注：两端的括号不可少。 将函数名作为一个值使用时，该函数自动转换为指针\n1 2 bool *pf = func; bool *pf = \u0026amp;func; //\u0026amp;可选 2、函数指针形参 形参中使用函数定义或者函数指针定义效果一样。\n1 2 3 4 5 6 7 8 void useBigger(const string \u0026amp;s1 , const string \u0026amp;s2, bool pf(const string \u0026amp; , const string \u0026amp;)); void useBigger(const string \u0026amp;s1 , const string \u0026amp;s2, bool (*pf)(const string \u0026amp; , const string \u0026amp;)); //调用 useBigger(s1,s2,func); 过于冗余的形参，可以使用类型别名或者decltype来简化\n1 2 3 4 5 6 7 8 9 10 11 12 13 //func1 , func2 , funcU1 都是函数类型 typedef bool func1(const string \u0026amp; , const string \u0026amp;); typedef decltype(lengthCompare) func2; using funcU1 = bool(const string \u0026amp; , const tring \u0026amp;); //func3 , func4 , funcU2是指向函数的指针 typedef bool(*func3)(const string \u0026amp; , const string \u0026amp;); typedef decltype(lengthCompare) *func4; using funcU2 = bool(*)(const string \u0026amp; , const tring \u0026amp;); //更加简洁的形式 void useBigger(const string \u0026amp;s1 , const string \u0026amp;s2, func1); void useBigger(const string \u0026amp;s1 , const string \u0026amp;s2, func3); void useBigger(const string \u0026amp;s1 , const string \u0026amp;s2, funcU1); void useBigger(const string \u0026amp;s1 , const string \u0026amp;s2, funcU2); 这里直接给函数名字作为形参，会自动转为函数指针\n3、返回指向函数的指针 直接声明\n1 int (*f1(int))(int *,int*); 类型别名 和形参不同，返回类型不会自动识别函数名为函数指针类型，所以要明确的定义\n1 2 3 4 5 using F = int(int *, int*); using Fp = int(*)(int *,int*); Fp f1(int); F f2(int); //WRONG 尾置返回类型\n1 auto f1(int)-\u0026gt;int(*)(int *,int*); 4、重载函数的指针 定义指向重载函数的指针必须精准匹配\n1 2 3 4 5 6 7 void ff(int *); void ff(unsigned int); void (*pf1)(unsigned int) = ff; //pf1指向ff(unsigned int) void (*pf2)(int) = ff; //WRONG double (*pf3)(int *) =ff; //WRONG ","pubDate":"2021-09-13","title":"【C++ Primer(edition 5) 06】函数"},{"link":"https://cnjslw.github.io/posts/%E8%AF%AD%E5%8F%A5/","plain":"简单语句 表达式语句：一个表达式末尾加上分号，就变成了表达式语句。 空语句：只有一个单独的分号。 复合语句（块）：用花括号 {}包裹起来的语句和声明的序列。一个块就是一个作用域。 条件语句 悬垂else（dangling else）：用来描述在嵌套的if else语句中，如果if比else多时如何处理的问题。C++使用的方法是else匹配最近没有配对的if。 迭代语句 while：当不确定到底要迭代多少次时，使用 while循环比较合适，比如读取输入的内容。 for： for语句可以省略掉 init-statement， condition和 expression的任何一个；甚至全部。 范围for： for (declaration: expression) statement 跳转语句 break：break语句负责终止离它最近的while、do while、for或者switch语句，并从这些语句之后的第一条语句开始继续执行。 continue：终止最近的循环中的当前迭代并立即开始下一次迭代。只能在while、do while、for循环的内部。 try语句块和异常处理 throw表达式：异常检测部分使用 throw表达式来表示它遇到了无法处理的问题。我们说 throw引发 raise了异常。 try语句块：以 try关键词开始，以一个或多个 catch字句结束。 try语句块中的代码抛出的异常通常会被某个 catch捕获并处理。 catch子句也被称为异常处理代码。 异常类：用于在 throw表达式和相关的 catch子句之间传递异常的具体信息。 1 2 3 4 Sales_item item1,item2; cin \u0026gt;\u0026gt; item1\u0026gt;\u0026gt;item2; if(item1.isbn() != item2.isbn()) throw runtime_error(\u0026#34;Data must refer to same ISBN\u0026#34;); runtime_error：异常类，抛出异常将终止当前函数并将控制权给能处理该异常的代码 1 2 3 4 5 6 7 8 9 10 11 12 while(cin\u0026gt;\u0026gt;iteml\u0026gt;\u0026gt;item2){ try{ //...... }catch(runtime_error err){ cout \u0026lt;\u0026lt; err.what() \u0026lt;\u0026lt; \u0026#34;\\nTry Agiain?\u0026#34;\u0026lt;\u0026lt;endl; char c; cin \u0026gt;\u0026gt; c; if(!cin || c==\u0026#39;n\u0026#39;) break; } } 标准异常 《C++Primer（edition 5）》P197\n","pubDate":"2021-09-12","title":"【C++ Primer(edition 5) 05】语句"},{"link":"https://cnjslw.github.io/posts/%E8%A1%A8%E8%BE%BE%E5%BC%8F/","plain":"表达式由一个或多个运算对象(operand)组成，对表达式求值将得到一个结果(result )。字面值和变量是最简单的表达式(expression),其结果就是字面值和变量的值。把一个运算符(operator)和一个或多个运算对象组合起来可以生成较复杂的表达式。 ^0c892c\n一、表达式基础 运算对象转换：小整数类型会被提升为较大的整数类型 重载运算符：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。 左值和右值： C中原意：左值可以在表达式左边，右值不能。 C++：当一个对象被用作右值的时候，用的是对象的值（内容）； 被用做左值时，用的是对象的身份（在内存中的位置）。 求值顺序：int i = f1() + f2() 先计算f1() + f2(),再计算int i = f1() + f2()。但是f1和f2的计算先后不确定 但是，如果f1、f2都对同一对象进行了修改，因为顺序不确定，所以会编译出错，显示未定义 二、算术运算符 溢出：当计算的结果超出该类型所能表示的范围时就会产生溢出。 bool类型不应该参与计算 1 2 3 4 bool b=true; bool b2=-b; //仍然为true //b为true，提升为对应int=1，-b=-1 //b2=-1≠0，所以b2仍未true 取余运算m%n，结果符号与m相同 三、逻辑运算符 短路求值：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。先左再右 小技巧，声明为引用类型可以避免对元素的拷贝，如下，如string特别大时可以节省大量时间。 1 2 3 4 vector\u0026lt;string\u0026gt; text; for(const auto \u0026amp;s: text){ cout\u0026lt;\u0026lt;s; } 四、赋值运算符 赋值运算的返回结果时它的左侧运算对象，且是一个左值。类型也就是左侧对象的类型。 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。 赋值运算符满足右结合律，这点和其他二元运算符不一样。 ival = jval = 0;等价于ival = (jval = 0); 赋值运算优先级比较低，使用其当条件时应该加括号。 复合赋值运算符，复合运算符只求值一次，普通运算符求值两次。（对性能有一点点点点影响） 任意复合运算符op等价于a = a op b; 五、递增递减运算符 前置版本j = ++i，先加一后赋值 后置版本j = i++，先赋值后加一 优先使用前置版本，后置多一步储存原始值。（除非需要变化前的值）\n混用解引用和递增运算符 *iter++等价于*(iter++)，递增优先级较高\n1 2 3 auto iter = vi.begin(); while (iter!=vi.end()\u0026amp;\u0026amp;*iter\u0026gt;=0) cout\u0026lt;\u0026lt;*iter++\u0026lt;\u0026lt;endl;\t// 输出当前值，指针向前移1 简洁是一种美德，追求简洁能降低程序出错可能性\n六、成员访问运算符 ptr-\u0026gt;mem等价于(*ptr).mem\n注意.运算符优先级大于*，所以记得加括号\n七、条件运算符 条件运算符（?:）允许我们把简单的if-else逻辑嵌入到单个表达式中去，按照如下形式：cond? expr1: expr2\n可以嵌套使用，右结合律，从右向左顺序组合\n1 2 3 finalgrade = (grade \u0026gt; 90) ? \u0026#34;high pass\u0026#34;:(grade \u0026lt; 60) ? \u0026#34;fail\u0026#34; : \u0026#34;pass\u0026#34;; //等价于 finalgrade = (grade \u0026gt; 90) ? \u0026#34;high pass\u0026#34;: ((grade \u0026lt; 60) ? \u0026#34;fail\u0026#34; : \u0026#34;pass\u0026#34;); 输出表达式使用条件运算符记得加括号，条件运算符优先级太低。 八、位运算符 用于检查和设置二进制位的功能。\n位运算符是作用于整数类型的运算对象。 二进制位向左移（\u0026lt;\u0026lt;）或者向右移（\u0026gt;\u0026gt;），移出边界外的位就被舍弃掉了。 位取反（~）（逐位求反）、与（\u0026amp;）、或（|）、异或（^） 有符号数负值可能移位后变号，所以强烈建议位运算符仅用于无符号数。\n应用：\n1 2 3 4 5 unsigned long quiz1 = 0; // 每一位代表一个学生是否通过考试 1UL \u0026lt;\u0026lt; 12; // 代表第12个学生通过 quiz1 |= (1UL \u0026lt;\u0026lt; 12); // 将第12个学生置为已通过 quiz1 \u0026amp;= ~(1UL \u0026lt;\u0026lt; 12); // 将第12个学生修改为未通过 bool stu12 = quiz1 \u0026amp; (1UL \u0026lt;\u0026lt; 12); // 判断第12个学生是否通过 位运算符使用较少，但是重载cout、cin大家都用过\n位运算符满足左结合律，优先级介于中间，使用时尽量加括号。\n九、sizeof运算符 返回一条表达式或一个类型名字所占的字节数。 返回的类型是 size_t的常量表达式。 sizeof并不实际计算其运算对象的值。 两种形式： sizeof (type)，给出类型名 sizeof expr，给出表达式 可用sizeof返回数组的大小 1 2 3 4 5 int ia[10]; // sizeof(ia)返回整个数组所占空间的大小 // sizeof(ia)/sizeof(*ia)返回数组的大小 constexpr size_t sz = sizeof(ia)/sizeof(*ia); int arr[sz]; 十、逗号运算符 从左向右依次求值。\n左侧求值结果丢弃，逗号运算符结果是右侧表达式的值。\n十一、类型转换 1、隐式类型转换 设计为尽可能避免损失精度，即转换为更精细类型。\n比 int类型小的整数值先提升为较大的整数类型。 条件中，非布尔转换成布尔。 初始化中，初始值转换成变量的类型。 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型。 函数调用时也会有转换。 1.1 算术转换 算术转换(arithmetic conversion) 的含义是把一种算术类型转换成另外一种算术类型\n1.1.1 整型提升 常见的char、bool、short能存在int就会转换成int，否则提升为unsigned int wchar_t,char16_t,char32_t提升为整型中int,long,long long ……最小的，且能容纳原类型所有可能值的类型。 1.1.2 无符号类型的运算对象 都带符号 or 都不带符号，小类型转大类型 一个带符号，另一个不带符号 带符号\u0026gt;不带符号：无符号能存入带符号类型，则转化为带符号类型，反之则转为无符号类型 带符号≤不带符号：带符号转为不带符号 不同符号的类型转换带来了隐患，比如 unsigned int 类型的变量大于int类型的变量，则有转为为 int-\u0026gt;unsigned int , 如果恰巧这个int 是一个负数，则转化为就会产生歧义 1.2 其他转换 p143\n2、显式类型转换（尽量避免） 2.1 static_cast 任何明确定义的类型转换，只要不包含底层const，都可以使用。\n1 2 3 int i,j ; cin \u0026gt;\u0026gt; i \u0026gt;\u0026gt; j; double slope = static_cast\u0026lt;double\u0026gt;(j)/i; 常用于较大算数运算符转换为较小算数运算符，旨在告诉编译器，不在乎精度的损失。\n2.2 dynamic_cast 支持运行时类型识别。\n2.3 const_cast 只能改变运算对象的底层const，一般可用于去除const性质。\n1 2 const char *pc; char *p = const_cast\u0026lt;char*\u0026gt;(pc) 只有const_cast 可以消除底层const，其他类型转换会报错，但是如果被消除的变量本身就是常量对象，通过const_cast消除其底层const后再修改，就是未定义的行为\n2.4 reinterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释。\n3、旧式强制类型转换 1 char *pc = (char *) ip; //ip原类型为指向整数的指针 十二、运算符优先级表 《C++ Primer（edition 5）》p166\n十三、常量表达式 常量表达式是指不会改变并且在编译过程中就能得到计算结果的表达式，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。\n1 2 const int max_file = 20 ; const int limit = max_file + 1 ; ","pubDate":"2021-09-09","title":"【C++ Primer(edition 5) 04】表达式"},{"link":"https://cnjslw.github.io/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/","plain":"一、string 标准库类型string表示可变长的字符序列。 #include \u0026lt;string\u0026gt;，然后 using std::string; string对象：注意，不同于字符串字面值。 1、定义和初始化string对象 定义string对象的方式：\n方式 解释 string s1 默认初始化，s1是个空字符串 string s2(s1) s2是s1的副本 string s2 = s1 等价于s2(s1)，s2是s1的副本 string s3(\u0026quot;value\u0026quot;) s3是字面值“value”的副本，除了字面值最后的那个空字符外 string s3 = \u0026quot;value\u0026quot; 等价于s3(\u0026quot;value\u0026quot;)，s3是字面值\u0026quot;value\u0026quot;的副本 string s4(n, 'c') 把s4初始化为由连续n个字符c组成的串 [[顺序容器#^5f2418|构造string的其他方法]]\n拷贝初始化（copy initialization）：使用等号=将一个已有的对象拷贝到正在创建的对象。 直接初始化（direct initialization）：通过括号给对象赋值。 2、string对象上的操作 string的操作：\n操作 解释 os \u0026lt;\u0026lt; s 将s写到输出流os当中，返回os is \u0026gt;\u0026gt; s 从is中读取字符串赋给s，字符串以空白分割，返回is getline(is, s) 从is中读取一行赋给s，返回is s.empty() s为空返回true，否则返回false s.size() 返回s中字符的个数 s[n] 返回s中第n个字符的引用，位置n从0计起 s1+s2 返回s1和s2连接后的结果 s1=s2 用s2的副本代替s1中原来的字符 s1==s2 如果s1和s2中所含的字符完全一样，则它们相等；string对象的相等性判断对字母的大小写敏感 s1!=s2 同上 \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;= 利用字符在字典中的顺序进行比较，且对字母的大小写敏感（对第一个不相同的位置进行比较） string io： 执行读操作\u0026gt;\u0026gt;：忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止。 getline：读取一整行，包括空白符。 s.size()返回的时string::size_type类型，记住是一个无符号类型的值，不要和int混用 s1+s2使用时，保证至少一侧是string类型。string s1 = \u0026quot;hello\u0026quot; + \u0026quot;world\u0026quot; // 错误，两侧均为字符串字面值 字符串字面值和string是不同的类型。 3、处理string对象中的字符 ctype.h vs. cctype：C++修改了c的标准库，名称为去掉.h，前面加c。 如c++版本为cctype，c版本为ctype.h\n尽量使用c++版本的头文件，即cctype cctype头文件中定义了一组标准函数：\n函数 解释 isalnum(c) 当c是字母或数字时为真 isalpha(c) 当c是字母时为真 iscntrl(c) 当c是控制字符时为真 isdigit(c) 当c是数字时为真 isgraph(c) 当c不是空格但可以打印时为真 islower(c) 当c是小写字母时为真 isprint(c) 当c是可打印字符时为真 ispunct(c) 当c是标点符号时为真 isspace(c) 当c是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） isupper(c) 当c是大写字母时为真 isxdigit(c) 当c是十六进制数字时为真 tolower(c) 当c是大写字母，输出对应的小写字母；否则原样输出c toupper(c) 当c是小写字母，输出对应的大写字母；否则原样输出c 遍历字符串：使用范围for（range for）语句： for (auto c: str)，或者 for (auto \u0026amp;c: str)使用引用直接改变字符串中的字符。 （C++11） str[x],[]输入参数为string::size_type类型，给出int整型也会自动转化为该类型 二、vector [[C++Primer#第九章|深层次的介绍]]\nvector是一个容器，也是一个类模板； #include \u0026lt;vector\u0026gt; 然后 using std::vector; 容器：包含其他对象。 类模板：本身不是类，但可以实例化instantiation(编译器根据模板创建类或函数的过程称为实例化)出一个类。 vector是一个模板， vector\u0026lt;int\u0026gt;是一个类型。 通过将类型放在类模板名称后面的尖括号中来指定类型，如vector\u0026lt;int\u0026gt; ivec。 1、定义和初始化vector对象 初始化vector对象的方法\n方法 解释 vector\u0026lt;T\u0026gt; v1 v1是一个空vector，它潜在的元素是T类型的，执行默认初始化 vector\u0026lt;T\u0026gt; v2(v1) v2中包含有v1所有元素的副本 vector\u0026lt;T\u0026gt; v2 = v1 等价于v2(v1)，v2中包含v1所有元素的副本 vector\u0026lt;T\u0026gt; v3(n, val) v3包含了n个重复的元素，每个元素的值都是val vector\u0026lt;T\u0026gt; v4(n) v4包含了n个重复地执行了值初始化的对象 vector\u0026lt;T\u0026gt; v5{a, b, c...} v5包含了初始值个数的元素，每个元素被赋予相应的初始值 vector\u0026lt;T\u0026gt; v5={a, b, c...} 等价于v5{a, b, c...} 列表初始化： vector\u0026lt;string\u0026gt; v{\u0026quot;a\u0026quot;, \u0026quot;an\u0026quot;, \u0026quot;the\u0026quot;}; （C++11） 元素由内默认初始化有两个限制，其一有些类必须明确的提供初始值，其二,如果只提供了元素的数量，而没有设定初始值，只能使用直接初始化。 如果初始化时使用了花括号的形式，但是提供了值又不能用来列表初始化就要考虑用这样的值来构造vector对象。 2、向vector对象中添加元素 v.push_back(e) 在尾部增加元素。 3、其他vector操作 vector支持的操作：\n操作 解释 v.emtpy() 如果v不含有任何元素，返回真；否则返回假 v.size() 返回v中元素的个数 v.push_back(t) 向v的尾端添加一个值为t的元素 v[n] 返回v中第n个位置上元素的引用 v1 = v2 用v2中的元素拷贝替换v1中的元素 v1 = {a,b,c...} 用列表中元素的拷贝替换v1中的元素 v1 == v2 v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同 v1 != v2 同上 \u0026lt;,\u0026lt;=,\u0026gt;, \u0026gt;= 以字典顺序进行比较 范围for语句内不应该改变其遍历序列的大小。 vector对象（以及string对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。 三、迭代器iterator 所有标准库容器都可以使用迭代器。 类似于指针类型，迭代器也提供了对对象的间接访问。 1、使用迭代器 vector\u0026lt;int\u0026gt;::iterator iter。 auto b = v.begin();返回指向第一个元素的迭代器。 auto e = v.end();返回指向最后一个元素的下一个（哨兵，尾后,one past the end）的迭代器（off the end）。 如果容器为空， begin()和 end()返回的是同一个迭代器，都是尾后迭代器。 使用解引用符*访问迭代器指向的元素。 养成使用迭代器和!=的习惯（泛型编程）。 容器：可以包含其他对象；但所有的对象必须类型相同。 迭代器（iterator）：每种标准容器都有自己的迭代器。C++倾向于用迭代器而不是下标遍历元素。 const_iterator：只能读取容器内元素不能改变。 箭头运算符： 解引用 + 成员访问，it-\u0026gt;mem等价于 (*it).mem 谨记：但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。 标准容器迭代器的运算符:\n运算符 解释 *iter 返回迭代器iter所指向的元素的引用 iter-\u0026gt;mem 等价于(*iter).mem ++iter 令iter指示容器中的下一个元素 --iter 令iter指示容器中的上一个元素 iter1 == iter2 判断两个迭代器是否相等 2、迭代器运算 vector和string迭代器支持的运算：\n运算符 解释 iter + n 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 iter - n 迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。 iter1 += n 迭代器加法的复合赋值语句，将iter1加n的结果赋给iter1 iter1 -= n 迭代器减法的复合赋值语句，将iter2减n的加过赋给iter1 iter1 - iter2 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。 \u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;= 迭代器的关系运算符，如果某迭代器 difference_type：保证足够大以存储任何两个迭代器对象间的距离，可正可负。 三、数组 相当于vector的低级版，长度固定。 如果不清楚元素的确切个数，请使用vector。 1、定义和初始化内置数组 初始化：char input_buffer[buffer_size];，长度必须是const表达式，或者不写，让编译器自己推断。 数组不允许直接赋值给另一个数组。 字符数组的特殊性 : 字符数组有一种额外的初始化形式，可以用字符串字面值对此类数组初始化。一定要注意字符串字面值的结尾处还有一个空字符。 1 2 char a1[] = {\u0026#39;c\u0026#39; , \u0026#39;+\u0026#39;, \u0026#39;+\u0026#39;};//列表初始化,没有空字符 char a2[]=\u0026#34;C++\u0026#34; //自动添加表示字符串结束的空字符 理解复杂的数组声明 : 由内向外，从右向左。 用数组初始化 vector： int a[] = {1,2,3,4,5}; vector\u0026lt;int\u0026gt; v(begin(a), end(a)); 。 2、访问数组元素 数组下标的类型：size_t 。 字符数组的特殊性：结尾处有一个空字符，如 char a[] = \u0026quot;hello\u0026quot;; 。 3、数组和指针 使用数组时，编译器一般会把它转换成指针。 标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值。 int *p=a[2] ; int k= p[-2]; //k=a[0]* 指针访问数组：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针。 当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组。当使用decltype的关键字时，上述转换不会发生。 在宿主中引入begin和end函数来获取数组的首元素和数组的尾后元素。 两个指向数组的指针相减的结果是它们之间的距离。 结果类型为ptrdiff_t的标准库类型。 4、C风格字符串 C风格的字符串是一种特殊的字符数组\n1 2 const char *c = \u0026#34;Halo,World\u0026#34;; const char c[] = {\u0026#39;H\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;,\u0026#39;,\u0026#39;W\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;\\0\u0026#39;}; 两者等价，请注意，该数组的最后一个字符为空字符\\0，这也被称为字符串结束字符，因为它告诉编译器， 字符串到此结束。这种C风格字符串是特殊的字符数组，因为总是在最后一个字符后加上空字符\\0，在代码中使用字符串字面量时，编译器将负责在它后面添加\\0。 在数组中间插入\\0并不会改变数组的长度，而只会导致将该数组作为输入的字符串处理将到这 个位置结束，如果不加\\0，则会导致在打印或者计算长度等操作是无法停止或者输出垃圾数据，从而程序奔溃。\nC风格字符串不仅使用起来不方便而且极易引发程序漏洞是, 诸多安全问题的根本原因。\n从C继承来的字符串。 用空字符结束（\\0）。 对大多数应用来说，使用标准库 string比使用C风格字符串更安全、更高效。 获取 string 中的 cstring ： const char *str = s.c_str(); 1 2 3 char ca[] = {\u0026#39;C\u0026#39; , \u0026#39;+\u0026#39; , \u0026#39;+\u0026#39;}; cout \u0026lt;\u0026lt; strlen(ca)\u0026lt;\u0026lt;endl; //严重错误CA没有以空字符结束。 Strlen函数将有可能沿着ca在内存中的位置不断向前寻找，直到遇到空字符才停下。 C标准库String函数，定义在\u0026lt;cstring\u0026gt; 中：\n函数 介绍 strlen(p) 返回p的长度，空字符不计算在内 strcmp(p1, p2) 比较p1和p2的相等性。如果p1==p2，返回0；如果p1\u0026gt;p2，返回一个正值；如果p1\u0026lt;p2，返回一个负值。 strcat(p1, p2) 将p2附加到p1之后，返回p1 strcpy(p1, p2) 将p2拷贝给p1，返回p1 尽量使用vector和迭代器，少用数组\n5、与旧代码的接口 混用string对象和C风格字符串\n允许使用以空字符结束的字符数组来初始化string对象，或为string对象赋值。 允许使用以空字符结束的字符数组作为string对象加法运算中的一个对象，不能两个运算对象都是 ， 在string对象的复合赋值运算中，允许使用以空字符结束的字符数组作为右侧的运算对象。 上述性质反过来只能用string专门提供的一个名为c_str的成员函数来初始化指向字符的指针。string s =\u0026quot;C++\u0026quot; ; const char *str = s.c_str();该函数的返回结果是一个指针，该指针指向的一个以空字符结束的字读数组, 也就是C风格的字符串，而这个数组所存的数据恰好与那个string对象是一样的，结果指针的类型是const char*，从而确保我们不会改变字符数组的类型。 六、多维数组 多维数组的初始化： int ia[3][4] = {{0,1,2,3}, ...}。 使用范围for语句时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。 七、动态数组 使用 new和 delete表达和c中malloc和free类似的功能，即在堆（自由存储区）中分配存储空间。 定义： int *pia = new int[10]; 10可以被一个变量替代。 释放： delete [] pia;，注意不要忘记[]。 ","pubDate":"2021-09-08","title":"【C++ Primer(edition 5) 03】字符串、向量和数组"},{"link":"https://cnjslw.github.io/posts/%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/","plain":"一、引用 1、左值引用 1.1、引用的定义 引用是一个对象的别名，引用类型引用（refer to）另外一种类型。如int \u0026amp;refVal = val;。 引用的类型要和与之绑定的对象(对象)严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起\n引用必须初始化。 引用和它的初始值是绑定在一起的，而不是拷贝。一旦定义就不能更改绑定为其他的对象 1.2、引用规则的两种例外情况 第一个例外 在初始化常量引用时允许用任意表达式作为初始值，只要表达式的结果能够转换为引用的类型即可，允许一个常量引用绑定非常量的对象，字面值，甚至一个表达式 ^d7c880\n1 2 3 4 5 int i = -42; const int \u0026amp;rl = i;\t//允许将 const int\u0026amp; 绑定到一个普通int对象上 const int \u0026amp;r2 = 42;\t//正确：rl是一个常量引用 const int \u0026amp;r3 = rl*2;\t//正确：r3是一个常量引用 int \u0026amp;r4 = rl*2;\t//\t错误：r4是一个普通的非常量引用 1 2 double dval = 3.14; const int \u0026amp;ri = dval; 理解这种例外的核心就是搞清楚当一个常量引用被绑定到另外一种类型上发生了什么。\n1 2 3 const int temp = dval; //由双精度浮点数生成一个临时的整型常量 const int \u0026amp;ri = temp; //让ri绑定这个临时量 在这种情况下，ri绑定了一个临时量(temporary)对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。c++程序员们常常把临时量对象简称为临时量。\n第二个例外 存在继承关系的类是一个例外，可以将基类的指针或者引用绑定到派生类对象上 可以将基类的指针或引用绑定到派生类对象上有一层极为至要的含义：当使用基类的 引用（或指针）时，实际我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。 ^9b1798\n1.3 sizeof()和引用 sizeof()取的是引用变量的类型大小\n3、为什么要有引用 避免无休止的拷贝，极大提高了性能\n二、指针 1、定义 指针是一种 \u0026ldquo;指向（point to）\u0026ldquo;另外一种类型的复合类型。也可以说是指向内存单元的特殊变量。指针的类型与所指向的对象类型必须一致\n1.1 声明指针 int *ip1;，从右向左读有助于阅读，ip1是指向int类型的指针。\n1.2 取变量地址 指针存放某个对象的地址，获取对象的地址： int i=42; int *p = \u0026amp;i;。 \u0026amp;是取地址符。\n1.3 利用指针访问对象 使用解引用符（*）来访问对象 指针访问对象： cout \u0026lt;\u0026lt; *p;\n1.4 sizeof()和指针 sizeof()用于普通变量是指变量类型的内存大小，即编译器为变量预留的内存空间大小。 但是，当用于指针变量时，取决于编译器和操作系统存储地址所需的内存空间，与指向什么类型的变量空间是没有关系的。\n2、指针操作 2.1 递增和递减 如果对指针执行递增或递减运算，编译器将认为要指向内存块中相邻的值（并假定这个值的 类型与前一个值相同）,而不是相邻的字节（除非值的长度刚好是1字节，如char）。 将指针递增或递减的结果 将指针递增或递减时，其包含的地址将增加或减少指向的数据类型的sizeof （并不一定是1字节）。这样，编译器将琉保指针不会指向数据的中间或末尾，而只会指向数据的开头。 如果声明了如下指针：\n1 Type* pType = Address; 则执行++piype后，pType 将包含（指向）Address + sizeoffiype。\n2.2 将关键字const用于指针 ![[变量和基本类型#3、指针和const|指针和const]]\n2.3 将指针传递给函数 3、指针定义的两种例外情况 指针的类型与所指向的对象类型必须一致这个规则有两种例外 第一种 允许令一个指向常量的指针指向一个非常量对象 ^413a8b\n1 2 3 const double *cptr ; double dval = 3.14 ; cptr = \u0026amp;dval ; 和常量引用一样，指向常量的指针也没有规定其所指的对象必须是个常量。所谓的指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过 其他途径改变。 可以这样想，所谓的常量引用和常量指针，不过是指针和引用的“自以为是”，他们觉得自己指向了常量，所以自觉的不去改变所指向的对象的值罢了。\n第二种 [[复合类型#^9b1798|继承关系中存在例外]]\n4、指针的值的四种状态 1.指向一个对象； 2.指向紧邻对象的下一个位置； 3.空指针； 4.无效指针。\n对无效指针的操作均会引发错误，第二种和第三种虽为有效的，但理论上是不被允许的\n5、空指针 空指针不指向任何对象。使用int *p=nullptr;来使用空指针。\n6、空类型指针 void*指针可以存放任意对象的地址。因无类型，仅操作内存空间，对所存对象无法访问。 利用void*指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void*指针。不能直接操作void*指针所指的对象，因为我们并不知道 这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。\n7、使用指针时常犯的错误 7.1 野指针 “野指针”则是不确定其具体指向的指针。“野指针”最常来自于未初始化的指针\n1 2 void *p; // 此时 p 是“野指针” 因为“野指针”可能指向任意内存段，因此它可能会损坏正常的数据，也有可能引发其他未知错误，所以C语言中的“野指针”危害性甚至比“悬空指针”还要严重。在实际的C语言程序开发中，定义指针时，一般都要尽量避免“野指针”的出现（赋初值）：\n1 void *p = NULL; 7.2 内存泄漏 这可能是C++应用程序最常见的问题之一：运行时间越长，占用的内存越多，系统越慢。如果在使用new动态分配的内存不再需要后，程序员没有使用配套的delete释放，通常就会出现这种情况。\n7.3 指向无效的内存单元 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { // uninitialized pointer (bad) int* pTemperature; cout \u0026lt;\u0026lt; \u0026#34;Is it sunny (y/n)?\u0026#34; \u0026lt;\u0026lt; endl; char Userinput = \u0026#39;y\u0026#39;; cin \u0026gt;\u0026gt; Userinput; if (Userinput == \u0026#39;y\u0026#39;) { pTemperature = new int; *pTemperature = 30; } // pTemperature contains invalid value if user entered \u0026#39;n\u0026#39; cout « \u0026#34;Temperature is: \u0026#39; « *pTemperature; // delete also being invoked for those cases new wasn\u0026#39;t done delete pTemperature; return 0; } 7.4 悬空指针 指针可以指向一块内存，如果这块内存稍后被操作系统回收（被释放），但是指针仍然指向这块内存，那么，此时该指针就是“悬空指针”\n三、指针与引用的不同 本质上： 引用本质是一个指针\n使用上： 指针与引用类似，都实现了对其他对象的间接访问。 然而指针与引用相比也有很多不同点。\n其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在==指针的生命周期内它可以先后指向几个不同的对象==，但是引用一旦初始化后就不可以再改变。\n其二，==指针无须在定义时赋初值==。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有个不确定的值。\n其三，作为参数传递时，指针是==拷贝==同样的地址，如果函数作用域中改变指针变量的地址，则不再影响实参。引用参数实质上==传递的是实参本身==，即传递进来的不是实参的一个拷贝，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。\n四、理解复合类型的声明 变量的定义包括一个基本数据类型(base type) 和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。也就是说， 条定义语句可能定义出不同类型的变量：\n1 int i = 1024, *p = \u0026amp;i , \u0026amp;r = i; 甚至可以有多个声明符，组合出更为复杂的变量\n指向指针的指针\n1 int **p; 指向指针的引用 要理解变量到底是什么，最简单的方法就是==从右向左==阅读r的定义，距离变量名最近的符号对变量的类型有直接的影响\n1 2 3 4 5 6 int i = 42; int *p; int *\u0026amp;r = p; //r是一个引用变量，引用一个指向int型变量的指针变量 r = \u0026amp;i; *r=0; ","pubDate":"2021-09-06","title":"【C++ Primer(edition 5) 02】复合类型"},{"link":"https://cnjslw.github.io/posts/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/","plain":"一、基本内置类型 基本算数类型\n类型 含义 最小尺寸 bool 布尔类型 8bits char 字符 8bits wchar_t 宽字符 16bits char16_t Unicode字符 16bits char32_t Unicode字符 32bits short 短整型 16bits int 整型 16bits (在32位机器中是32bits) long 长整型 32bits long long 长整型 64bits （是在C++11中新定义的） float 单精度浮点数 6位有效数字 double 双精度浮点数 10位有效数字 long double 扩展精度浮点数 10位有效数字 如何选择类型\n1.当明确知晓数值不可能是负数时，选用无符号类型； 2.使用int执行整数运算。一般long的大小和int一样，而short常常显得太小。除非超过了int的范围，选择long long。 3.算术表达式中不要使用char或bool。 4.浮点运算选用double。 二、常量 在C++中，常量类似于变量，只是不能修改。与变量一样，常量也占用内存空间，并使用名称标识为其预留的空间的地址，但不能覆盖该空间的内容。在C++中，常量可以是： •字面常量； •使用关键字const声明的常量； •使用关键字constexpr声明的常量表达式（C++11新增的）; •使用关键字enum声明的枚举常量； •使用#define定义的常量（已摒弃，不推荐）。\n1、使用constexpr声明常量 在C++11之前，C++就支持常量表达式的概念，只是没有关键字constexpr，在程序清单3.5中， 22.0/7是一个常量表达式，C++11之前的编译器也支持它。然而，C++11之前的编译器不允许定义在编译阶段计算的函数。 在C++11中，可以编写下面这样的代码：\n1 constexpr double GetPi() {return 22.0 / 7;} 还可将GetPi与另一个常量一起使用，如下所示：\n1 constexpr double TwicePi() {return 2 * GetPi();} 乍一看，const和constexpr之间的差别很小，但从编译器和应用程序的角度看，关键字Constexpr 提供了优化应用程序的可能性。对于第二条语句，如果使用const,将在运行阶段执行计算，但使用遵 守C++11的编译器时，将在编译阶段计算该表达式的值，这提高了应用程序的运行速度。\n2、字面值常量 一个形如42的值被称作字面值常量（literal）。 整型和浮点型字面值。 字符和字符串字面值。 使用空格连接，继承自C。 字符字面值：单引号， 'a' 字符串字面值：双引号， \u0026quot;Hello World\u0026quot;\u0026quot; 分多行书写字符串。 1 2 std:cout\u0026lt;\u0026lt;\u0026#34;wow, a really, really long string\u0026#34; \u0026#34;literal that spans two lines\u0026#34; \u0026lt;\u0026lt;std::endl; 转义序列。\\n、\\t等。 布尔字面值。true，false。 指针字面值。nullptr 字符串型实际上时常量字符构成的数组，结尾处以'\\0'结束，所以字符串类型实际上长度比内容多1。\n3、使用const将变量声明为常量 [[变量和基本类型#五、const限定符]]\n4、枚举常量 在有些情况下，变量只能有一组特定的取值\n1 2 3 4 5 6 7 8 9 10 11 enum RainbowColors { Violet = 0 , //此后每个值都递增1，默认0开始 Indigo, Blue, Yellow, Orange, Red } RainbowColors MyWorldColor = Blue; 5、使用#define定义常量 【摒弃】 这是一个预处理器宏，让预处理器将随后出现的所有Pi都替换为3.14286。预处理器将进行文本替换，而不是智能替换。编译器既不知道也不关心常量的类型。\n1 #define Pi 3.14 三、变量 1、什么是变量 变量提供一个具名的，可供程序操作的存储空间 变量类型向编译器指出了变量可存储的数据的性质，编译器将为变量预留必要的空间。变量名由程序员选择，它替代了变量值在内存中的存储地址，但更友好。除非给变量赋初值，否则无法确保相应内存单元的内容是什么，这对程序可能不利。因此，初始化虽然是可选的，但对变量初始化通常是 一个不错的编程习惯。程序清单3.1将用户提供的两个数字相乘，演示了如何在程序中声明、初始化。\n变量名 是内存地址的别名，方便存取 类型 是告诉编译器可以存什么样的数据,需要多大的内存空间 初始化 是可选的，不然无法确保内存中的数据是啥 变量提供一个具名的、可供程序操作的存储空间。 C++中变量和对象一般可以互换使用。\n2、变量定义（define） 定义形式：类型说明符（type specifier） + 一个或多个变量名组成的列表。用于初始化变量的值可以是任意复杂的[[表达式#^0c892c|表达式]]\n1 int sum = 0, value, units_sold = 0; 3、初始化 初始化（initialize）：对象在创建时获得了一个特定的值。 初始化不是赋值！ 初始化 = 创建变量 + 赋予初始值 赋值 = 擦除对象的当前值 + 用新值代替\n3.1 直接初始化 略\n3.2 列表初始化(C++11 全面支持) 使用花括号{}\n1 2 3 4 int units_sold = 0; int units_sold = {0}; int units_sold{0}; int units_sold(0); 当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错\n1 2 3 long double Id = 3.1415926536; int a{Id}, b = {Id}; // 错误 ：转换未执行，因为存在丢失信息的危险 int c(ld), d = Id; // 正确：转换执行，且确实丢失了部分值 3.3 默认初始化 定义时没有指定初始值会被默认初始化，默认值到底是什么由变量类型决定\n在函数体内部的内置类型变量将不会被初始化, 函数体外的内置类型初始化为0，试图使用未定义的变量将发生错误。建议初始化每一个内置类型的变量。\n3.4 值初始化（类） 通常情况下，可以只提供Vector对象容纳的元素数量而不用略去初始值。此时库会创建一个值初始化的(value-initialized)元素初值，并把它赋给容器中的所有元素。这个 初值由vector对象中元素的类型决定。 限制：类中的元素必须支持默认初始化\n4、变量的声明（declaration） vs 定义（define） 为了支持分离式编译，C++将声明和定义区分开。声明使得名字为程序所知。定义负责创建与名字关联的实体。 extern：只是说明变量定义在其他地方。 只声明而不定义： 在变量名前添加关键字 extern，如extern int i;。但如果包含了初始值，就变成了定义：extern double pi = 3.14; 变量只能被定义一次，但是可以多次声明。定义只出现在一个文件中，其他文件使用该变量时需要对其声明。 名字的作用域（namescope）{} 第一次使用变量时再定义它。 嵌套的作用域 同时存在全局和局部变量时，已定义局部变量的作用域中可用::reused显式访问全局变量reused。 但是用到全局变量时，尽量不适用重名的局部变量。 5、变量命名规范 需体现实际意义 变量名用小写字母 自定义类名用大写字母开头：Sales_item 标识符由多个单词组成，中间须有明确区分：student_loan或studentLoan，不要用studentloan。 6、左值和右值 左值（l-value）可以出现在赋值语句的左边或者右边，比如变量； 右值（r-value）只能出现在赋值语句的右边，比如常量。 7、变量的作用域 C++作用域\n四、复合类型 复合类型\n五、const限定符 动机：希望定义一些不能被改变值的变量。 1、初始化和const const对象必须初始化，且不能被改变。 编译器将在编译过程中把用到const 变量的地方都替换成对应的值。 const变量默认不能被其他文件访问，非要访问，必须在指定const定义之前加extern。某些时候有这样种const变量，它的初始值不是个常量表达式，但又确实有必要在文件间共享。也就是说，只在一个文件中定义const,而在其他多个文件中声明并使用它。解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了： 1 2 3 4 // file_l.cc定义并初始化了一个常量，该常量能被其他文件访问 extern const int bufSize = fen(); // file_l.h 头丈件 extern const int bufSize; // 与\t.cc 中定义的 bufSize 是同一个 2、const的引用 [[复合类型#^d7c880|常量引用的特殊性]]\nreference to const（对常量的引用）：指向const对象的引用，如 const int ival=1; const int \u0026amp;refVal = ival;，可以读取但不能修改refVal。 临时量（temporary）对象：当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。 对临时量的引用是非法行为。 3、指针和const [[复合类型#^413a8b|常量指针的特殊性]]\npointer to const（指向常量的指针，简称常量指针）：不能用于改变其所指对象的值, 如 const double pi = 3.14; const double *cptr = \u0026amp;pi;。 const pointer：指针本身是常量（简称指针常量），也就是说指针固定指向该对象，（存放在指针中的地址不变，地址所对应的那个对象值可以修改）如 int i = 0; int *const ptr = \u0026amp;i; 4、顶层const与底层 顶层const：表示变量本身是个常量，对任何数据类型适用，如算数类型（int、double），类，指针。 底层const：表示指向的变量是个常量，用于指针和引用 六、处理类型 1、类型别名 传统别名：使用typedef来定义类型的同义词。 1 2 typedef double wages; typedef wages base,*p; //base = wages = double , p = wages * = double * 这里不仅有基本类型还包含声明符，需要理解[[复合类型#四、理解复合类型的声明|复合类型的声明]]\n新标准别名：别名声明（alias declaration）： using SI = Sales_item;（C++11） 指针、常量和类型别名\n1 2 3 4 5 6 7 8 9 // 对于复合类型（指针等）不能代回原式来进行理解 typedef char *pstring; // pstring是char*的别名 const pstring cstr = 0; // 指向char的常量指针 const pstring *ps; //ps是一个指针，他的对象是指向char的常量指针 // 如改写为const char *cstr = 0;不正确，为指向const char的指针 // 辅助理解（可代回后加括号） // const pstring cstr = 0;代回后const (char *) cstr = 0; // const char *cstr = 0;即为(const char *) cstr = 0; 2、auto类型说明符 c++11 auto类型说明符：让编译器自动推断类型。 一条声明语句只能有一个数据类型，所以一个auto声明多个变量时只能相同的变量类型(包括复杂类型\u0026amp;和*)。auto sz = 0, pi =3.14//错误 如何初始化的对象是引用类型，会根据引用变量的引用对象的值来推测，而非引用变量的类型，int i = 0, \u0026amp;r = i; auto a = r; 推断a的类型是int。 会忽略顶层const。const int ci = 1; const auto f = ci;推断类型是int，如果希望是顶层const需要自己加const；但是如果左值是一个引用变量，那么初始值中的顶层常量属性会被保存 1 2 3 4 5 6 7 8 9 10 11 12 int i = 0, \u0026amp;r = i; auto a = r; //a 是整型 const int ci = i, \u0026amp;cr = ci; auto b = ci; //b 是整型 auto c = cr; //c 是一个整型 auto d = \u0026amp;i; //d 是一个整型指针 auto e = \u0026amp;ci; //e 是一个指向整数常量的指针（对常量取地址是一种底层const） const auto f = ci; //ci的推演类型是int,f是cosnt int auto \u0026amp;g = ci; //g是一个整型常量引用，绑定到ci auto \u0026amp;h = 42; //错误：不能为非常量引用绑定到字面值 const auto \u0026amp;j = 42 //正确，这里是因为常量引用的特殊性，可以参考复合类型的笔记 3、decltype类型指示符 有时会遇到这种情况: 向往从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量（想用类型，不想用值）。 为了满足这一要求，C++1I新标准引入了第二种类型说明符decltype decltype：选择并返回操作数的数据类型，从表达式的类型推断出要定义的变量的类型。\n3.1 与auto的不同 decltype处理顶层const和引用的方式与auto有些许不同。 其一，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）:\n1 2 3 4 const int ci =0, \u0026amp;cj =ci; decltype(ci) x = 0 ; //x的类型是const int decltype(cj) y = x ; //y的类型是const int \u0026amp; decltype(cj) z; //错误，z是const int \u0026amp; ,需要初始化 其二，decltype的结果类型与表达式形式密切相关，如果对变量加括号（一层或者多层），因为变量是一种可以作为赋值语句左值的特殊表达式，编译器会因此将其认为是一个表达式\n1 2 decltype((i)) d; //错误，d是int\u0026amp;，必须初始化 decltype(i) e; //正确，e是一个未初始化的int 3.2 decltype和引用 如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的 类型。 1 2 3 4 5 6 decltype(f()) sum = x; // 推断sum的类型是函数f的返回类型。 int i = 42, *p = \u0026amp;i, \u0026amp;r = i ; decltype(r + 0) b; //正确，加法的结果是int,因此b是一个未初始化的int decltype(*p) c; //错误：c是int\u0026amp; , 必须初始化 decltype(\u0026amp;i) d; //d是 int **类型 因为r是一个引用，因此decltype (r)的结果是引用类型。如果想让结果类型是r所指 的类型，可以把r作为表达式的一部分，如r+0,显然这个表达式的结果将是一个具体值而非一个引用。 表达式的内容是解引用操作，则decltype将得到引用类型 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果 i 是 int，则表达式 i=x 的类型是 int\u0026amp;。 取地址运算符生成右值，所以decltype(\u0026amp;p)的结果是int ** ","pubDate":"2021-09-04","title":"【C++ Primer(edition 5) 01】变量和基本类型"}];
    var search_theEnd = "到底了";
    var search_nothing = "什么也没找到";
    var search_found = "找到";
    var search_result = "条结果";
    var search_results = "条结果";
    var enable_mermaid =  null 
</script>





        
    </body>
</html>

