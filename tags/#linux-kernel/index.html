<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>AWei’s Kernel Tour | #Linux Kernel</title>
    <meta name="description"
        content=" ">
    <link rel="canonical" href="https://cnjslw.github.io/tags/#linux-kernel/" />
    <link rel="icon" type="image/x-icon" href="/images/linux_pic.ico">
    <meta property="og:title" content="#Linux Kernel" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cnjslw.github.io/tags/#linux-kernel/" />


    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="#Linux Kernel"/>
<meta name="twitter:description" content=""/>

    
    
    

    <link rel="stylesheet" href='/css/style.css' />
    <link rel="stylesheet" href='/css/search.css' />
    <link rel="stylesheet" href='/css/md_nb.css' />
    <link rel="stylesheet" href='/css/list.css' />
    <link rel="stylesheet" href='/css/terms.css' />
    <link rel="stylesheet" href='/css/taxonomy.css' />
    <link rel="stylesheet" href='/css/font-awesome-4.7.0/css/font-awesome.min.css' />
    <link rel="stylesheet" href='/css/home.css' />
    <link rel="stylesheet" href='/css/syntax.css' />
    
    <link rel="stylesheet" href='/css/shortcode.css' />

    
    <link rel="stylesheet" href='/css/_custom.css' />
    <style>
        {
                {
                if eq .Kind "404"
            }
        }

        body::after {
            display: none;
        }

            {
                {
                end
            }
        }
    </style>
    
    
    
    
    <script src="/js/lazysizes.min.js" async=""></script>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/search.js"></script>
    <script src="/js/md_nb.js"></script>
    <script src="/js/yes.js"></script>
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
</head><body style="font-family: ,'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Heiti SC', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;">
        <div class="loading">
            <div class="loading-bg"></div>
            <div class="loading-long">
                <div class="loading-short"></div>
            </div>
        </div>

        <header>
    <nav class="navbar">
        <div class="navbar-brand">
            <a href="/">
                <span class="logo">AWei’s Kernel Tour</span>
            </a>
        </div>
        <div class="navbar-menu">
            
                <a href="/">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-home'></i> 主页</div>
                        </div>
                    </div>
                </a>
            
                <a href="/posts">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-book'></i> 文章</div>
                        </div>
                    </div>
                </a>
            
                <a href="/categories">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-folder-open'></i> 分类</div>
                        </div>
                    </div>
                </a>
            
                <a href="/series">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-gears'></i> 系列</div>
                        </div>
                    </div>
                </a>
            
                <a href="/tags">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-tags'></i> 标签</div>
                        </div>
                    </div>
                </a>
            
                <a href="/about">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-info-circle'></i> 简历</div>
                        </div>
                    </div>
                </a>
            
            <div class="navbar-burger">
                <div class="burger-btn"><span><i class="fa fa-navicon"></i></span></div>
            </div>
            
            
            <div class="search-in"><span><i class="fa fa-search"></i></span></div>
            
                <div class="mode">
                    <span class="sun"><i class="fa fa-sun-o"></i></span>
                    <span class="moon"><i class="fa fa-moon-o"></i></span>
                </div>
            
        </div>
    </nav>
    <div class="burger-items">
        
        <a href="/">
            <div class="burger-item">
                <i class='fa fa-home'></i> 主页
            </div>
        </a>
        
        <a href="/posts">
            <div class="burger-item">
                <i class='fa fa-book'></i> 文章
            </div>
        </a>
        
        <a href="/categories">
            <div class="burger-item">
                <i class='fa fa-folder-open'></i> 分类
            </div>
        </a>
        
        <a href="/series">
            <div class="burger-item">
                <i class='fa fa-gears'></i> 系列
            </div>
        </a>
        
        <a href="/tags">
            <div class="burger-item">
                <i class='fa fa-tags'></i> 标签
            </div>
        </a>
        
        <a href="/about">
            <div class="burger-item">
                <i class='fa fa-info-circle'></i> 简历
            </div>
        </a>
        
    </div>
    <div class="header-rest"></div>
</header>


        <div id="content">
    






    
        
    




    <div class="hero">
        
            
                <div class="hero-img">
                    <img class="lazyload" src="/images/thumbnail.gif" data-src="https://picsum.photos/2500/500" alt="">
                </div>
            
        <div class="hero-content">
            <h1 class="hero-title">标签: #Linux Kernel</h1>
        </div>
    </div>




<div class="zhuti-0">
    <div class="container">
        <div class="zhuti">
            <div class="zhuti-l">
                




    


<div class="terms-body">
    <div class="long">
        <button class="tosides-1 text-wbd">
            <i class="fa fa-arrow-right"></i>
        </button>
        <button class="tosides-2 text-wbd">
            <i class="fa fa-arrow-left"></i>
        </button>
        <button class="toup text-wbd">
            <i class="fa fa-arrow-up"></i>
        </button>
    </div>
    
        <div class="terms-row">
            
            <div class="terms-root">
                
                


<div class="card-large">
    <div class="card-large-img">

        
        <img class="lazyload" src="/images/thumbnail.gif" data-src="https://picsum.photos/2500/500"
            alt='图片加载失败'>
        
    </div>
    <div class="card-large-content">
        <div class="up-title"><a href="https://cnjslw.github.io/posts/01-linux0.12%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">【Linux Kernel 0.12】启动流程</a></div>
        <div class="up-date">
            <span class="no-wrap"><i class="fa fa-calendar"></i> 发布于: 2023-2-12 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> 更新于: 2023-2-12 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-folder"></i>
                
                收录于:
                
                <a href='
                                        /categories/linux-kernel
                                    '>
                    Linux Kernel
                </a>
                
            </span>
        </div>
        <div class="down-summary">Linux0.12的启动流程</div>
    </div>
    <div class="card-readmore">
        <a href="https://cnjslw.github.io/posts/01-linux0.12%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">
            <span><i class="fa fa-arrow-right"></i></span>
        </a>
    </div>
</div>






<div class="down-type">
    
    <span class="down-type-item">
        <div class="shuxian-root">
            <div class="shuxian"></div>
        </div>
        <div class="type-text">
            <a href='
                            /tags/#linux-kernel
                        '>
                <i class="fa fa-tag"></i> #Linux Kernel
            </a>
        </div>
    </span>
    
    <span class="down-type-item">
        <div class="shuxian-root">
            <div class="shuxian"></div>
        </div>
        <div class="type-text">
            <a href='
                            /tags/#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83
                        '>
                <i class="fa fa-tag"></i> #开发环境
            </a>
        </div>
    </span>
    
</div>

<div class="dang"></div>
            </div>
            
            <div class="terms-root">
                
                


<div class="card-large">
    <div class="card-large-img">

        
        <img class="lazyload" src="/images/thumbnail.gif" data-src="https://picsum.photos/2500/500"
            alt='图片加载失败'>
        
    </div>
    <div class="card-large-content">
        <div class="up-title"><a href="https://cnjslw.github.io/posts/qemu&#43;vscode&#43;kernel-debug/">【Linux Kernel】Linux debug 环境搭建：qemu&#43;vscode内核源码调试配置教程</a></div>
        <div class="up-date">
            <span class="no-wrap"><i class="fa fa-calendar"></i> 发布于: 2023-2-1 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> 更新于: 2023-2-1 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-folder"></i>
                
                收录于:
                
                <a href='
                                        /categories/linux-kernel
                                    '>
                    Linux Kernel
                </a>
                
            </span>
        </div>
        <div class="down-summary">Linux debug 环境搭建</div>
    </div>
    <div class="card-readmore">
        <a href="https://cnjslw.github.io/posts/qemu&#43;vscode&#43;kernel-debug/">
            <span><i class="fa fa-arrow-right"></i></span>
        </a>
    </div>
</div>






<div class="down-type">
    
    <span class="down-type-item">
        <div class="shuxian-root">
            <div class="shuxian"></div>
        </div>
        <div class="type-text">
            <a href='
                            /tags/#linux-kernel
                        '>
                <i class="fa fa-tag"></i> #Linux Kernel
            </a>
        </div>
    </span>
    
    <span class="down-type-item">
        <div class="shuxian-root">
            <div class="shuxian"></div>
        </div>
        <div class="type-text">
            <a href='
                            /tags/#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83
                        '>
                <i class="fa fa-tag"></i> #开发环境
            </a>
        </div>
    </span>
    
</div>

<div class="dang"></div>
            </div>
            
            <div class="terms-root">
                
                


<div class="card-large">
    <div class="card-large-img">

        
        <img class="lazyload" src="/images/thumbnail.gif" data-src="https://picsum.photos/2500/500"
            alt='图片加载失败'>
        
    </div>
    <div class="card-large-content">
        <div class="up-title"><a href="https://cnjslw.github.io/posts/linuxdocument-00/">【Linux Document 01】Memory Manager : Concept</a></div>
        <div class="up-date">
            <span class="no-wrap"><i class="fa fa-calendar"></i> 发布于: 2022-2-19 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> 更新于: 2022-2-19 &nbsp;</span>
            <span class="no-wrap"><i class="fa fa-folder"></i>
                
                收录于:
                
                <a href='
                                        /categories/linux-kernel
                                    '>
                    Linux Kernel
                </a>
                
            </span>
        </div>
        <div class="down-summary">Linux官方文档阅读笔记</div>
    </div>
    <div class="card-readmore">
        <a href="https://cnjslw.github.io/posts/linuxdocument-00/">
            <span><i class="fa fa-arrow-right"></i></span>
        </a>
    </div>
</div>






<div class="down-type">
    
    <span class="down-type-item">
        <div class="shuxian-root">
            <div class="shuxian"></div>
        </div>
        <div class="type-text">
            <a href='
                            /tags/#linux-kernel
                        '>
                <i class="fa fa-tag"></i> #Linux Kernel
            </a>
        </div>
    </span>
    
    <span class="down-type-item">
        <div class="shuxian-root">
            <div class="shuxian"></div>
        </div>
        <div class="type-text">
            <a href='
                            /tags/#%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3
                        '>
                <i class="fa fa-tag"></i> #官方文档
            </a>
        </div>
    </span>
    
</div>

<div class="dang"></div>
            </div>
            
        </div>
    
</div>


            </div>
            <div class="zhuti-r">
                
<div class="zhuti-r-0">
    <div class="zhuti-r-1">
        
        <div id="r1">
            

<div class="about-zuozhe">
    <div class="zuozhe">
        
            <div class="datou">
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/author.png" alt="">
            </div>
        
        <div class="name-jianjie">
            <div class="name">AWei</div>
            <div class="jianjie">
                凡外重者必内拙
            </div>
        </div>
    </div>

    <div class="type">
        <a href='
                    /posts/
                '>
            <p>文章</p>
            <p>27</p>
        </a>
        <a href='
                    /categories/
                '>
            <p>分类</p>
            <p>5</p>
        </a>
        <a href='
                    /tags/
                '>
            <p>标签</p>
            <p>13</p>
        </a>
    </div>

    <a href="https://github.com/cnjslw">
        <div class="follow">Follow Me</div>
    </a>
    <div class="link">
        
        <a href="https://github.com/cnjslw" class="link-item is-hidden-desktop" title="GitHub">
            <span class="icon"><i class='fa fa-github'></i></span>
        </a>
        
        <a href="https://www.youtube.com" class="link-item is-hidden-desktop" title="YouTube">
            <span class="icon"><i class='fa fa-youtube'></i></span>
        </a>
        
    </div>
</div>
            <div class="mulu">
    <div class="dong"></div>
    <div class="zhi">
        <div class="wenzi">
            <div class="zhi-mulu text-wbd">目录</div>
            <div class="mulu-items">
            </div>
        </div>
    </div>
</div>
            




<div class="other">
    <div class="other-up">
        <div class="other-qita text-wbd">最新文章</div>
        <div class="xian"></div>
    </div>
    <div class="list">
        
            <a href="https://cnjslw.github.io/posts/01-linux0.12%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">
                
<a href="https://cnjslw.github.io/posts/01-linux0.12%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( https://picsum.photos/2500/500 );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【Linux Kernel 0.12】启动流程
            </div>
            <div class="other-summary">Linux0.12的启动流程</div>
            <div class="other-date">2023-2-12</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cnjslw.github.io/posts/qemu&#43;vscode&#43;kernel-debug/">
                
<a href="https://cnjslw.github.io/posts/qemu&#43;vscode&#43;kernel-debug/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( https://picsum.photos/2500/500 );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【Linux Kernel】Linux debug 环境搭建：qemu&#43;vscode内核源码调试配置教程
            </div>
            <div class="other-summary">Linux debug 环境搭建</div>
            <div class="other-date">2023-2-1</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cnjslw.github.io/posts/%E6%8C%87%E4%BB%A4%E6%A6%82%E8%BF%B0/">
                
<a href="https://cnjslw.github.io/posts/%E6%8C%87%E4%BB%A4%E6%A6%82%E8%BF%B0/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( https://picsum.photos/2500/500 );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【计算机组成原理与体系架构01】指令系统设计
            </div>
            <div class="other-summary">指令系统设计</div>
            <div class="other-date">2023-1-15</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cnjslw.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01-%E6%A6%82%E8%BF%B0/">
                
<a href="https://cnjslw.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01-%E6%A6%82%E8%BF%B0/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( https://picsum.photos/2500/500 );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【计算机网络 01】概述
            </div>
            <div class="other-summary">计算机网络</div>
            <div class="other-date">2022-7-17</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cnjslw.github.io/posts/%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%8F%8B%E5%85%83/">
                
<a href="https://cnjslw.github.io/posts/%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%8F%8B%E5%85%83/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( https://picsum.photos/2500/500 );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【模板与泛型编程03】类模板和友元
            </div>
            <div class="other-summary">类模板</div>
            <div class="other-date">2022-6-22</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cnjslw.github.io/posts/%E7%B1%BB%E6%A8%A1%E6%9D%BF/">
                
<a href="https://cnjslw.github.io/posts/%E7%B1%BB%E6%A8%A1%E6%9D%BF/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( https://picsum.photos/2500/500 );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【模板与泛型编程02】类模板
            </div>
            <div class="other-summary">类模板</div>
            <div class="other-date">2022-6-20</div>
        </div>
    </div>
</a>
            </a>
        
    </div>
</div>
        </div>
        <div id="r2">
            
        </div> 
    </div>
</div>

            </div>
        </div>
    </div>
</div>


        </div>

        <footer class="footer">
    
        <div class="container">
            <div class="footer-items">
                
                    <div class="footer-item">
                        <i class="fa fa-user"></i> <span id="busuanzi_value_site_pv"></span> |
                        <i class="fa fa-eye"></i> <span id="busuanzi_value_site_uv"></span>
                    </div>
                
                
                    <div class="footer-item">
                        © 2022-2023 <a href="https://github.com/cnjslw">AWei</a>
                    </div>
                
                
                    <div class="footer-item">
                        Theme by <a href="https://github.com/xioyito/NewBee">NewBee</a> | Powered by <a href="https://gohugo.io/">Hugo</a>
                    </div>
                
            </div>
        </div>
    

    
</footer>


        
        <div class="search-root">
    <div class="search-zz"></div>
    <div class="search">
        <div class="sheader anniu">
            <div class="sh-l">
                <input type="text" placeholder='请输入关键词' id="search-key">
                <span class="sclear"><i class="fa fa-close"></i></span>
            </div>
            <div class="sh-r">
                <button>搜索</button>
            </div>
        </div>
        <div class="sbody">
            <div class="sbody-1">
                <div class="stip"></div>
            </div>
        </div>
    </div>
</div>
        









    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    


<script type="text/javascript">
    var mode_custom = "auto";
    var postsCount =  27 ;
    var arrPosts = [{"link":"https://cnjslw.github.io/posts/01-linux0.12%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/","plain":"从BIOS开始 为什么 首先运行的其实是BIOS（Basic Input Output System） 为什么？ 取决于硬件的先决条件[3]：\nCPU只能运行加载到内存中的程序 内存中的程序在计算机掉电之后会全部消失 所以操作系统必须保存在不挥发存储介质中，在上电后由某中机制将其加载到内存中运行。BIOS横空出世。\nBIOS如何启动？ 一个新的疑问，BIOS自身又是如何启动的？ 首先，BIOS同样是一段程序，所以同样无法逃脱之前的两个设定（CPU只能运行内存中的程序，内存掉电挥发），BIOS机制是如何应对的呢？ 先做两点说明\nBIOS固化在计算机主机板上的一块很小的ROM芯片里。 CPU硬件逻辑设计为加电瞬间强行将CS的值置为0xF000、IP的值置为0xFFF0，这样CS:IP就指向0xFFFF0这个地址位置 At initial power on, the BIOS is executed directly from ROM. The ROM chip is mapped to a fixed location in the processor\u0026rsquo;s memory space (this is typically a feature of the chipset). When the x86 processor comes out of reset, it immediately begins executing from 0xFFFFFFF0. However, executing directly from ROM is quite slow, so usually one of the first things the BIOS does is to copy and decompress the BIOS code into RAM, and it executes from there. Of course, the memory controller must be initialized first! The BIOS takes care of that beforehand. The memory map layout will vary from system to system. At power-on, the BIOS will query the attached PCI/PCIe devices, determine what resources are needed, and place them in the memory map at the optimal location. If everything is working properly, memory-mapped devices should not overlap with RAM. (Note that on a 64-bit system with \u0026gt;3GB of RAM, things get complicated because you need a \u0026ldquo;hole\u0026rdquo; in the middle of RAM for your 32-bit PCI/PCIe devices. Some early x64 BIOSes and chipsets had issues with this.)[4]\n简而言之，在主板初始化的过程中，BIOS固件会被读取到内存中，BIOS固件被加载到内存后，需要进行内存映射。BIOS会将自身的代码和数据存放到特定的内存地址空间中。这是一个纯硬件完成的动作。\nBIOS如何引导操作系统 主要说明BIOS如何加载操作系统,但BIOS的作用不仅仅如此\n从0xFFFF0开始 第一条指令就是跳转指令\n1 jmpf 0xf000:e05b 在内存中建立中断向量表和中断服务程序 BIOS程序在内存最开始的位置（0x00000）用1 KB的内存空间（0x00000～0x003FF）构建中断向量表，在紧挨着它的位置用256字节的内存空间构建BIOS数据区（0x00400～0x004FF），并在大约57 KB以后的位置（0x0E05B）加载了8 KB左右的与中断向量表相应的若干中断服务程序[2] 中断向量表中有256个中断向量，每个中断向量占4字节，其中两个字节是CS的值，两个字节是IP的值。每个中断向量都指向一个具体的中断服务程序。\n为什么要建立中断机制？ 因为需要利用中断机制从存储介质中读取系统内核到内存中\n加载bootsect（第一部分内核代码） 对于Linux 0.12操作系统而言，计算机将分三批逐次加载操作系统的内核代码。第一批由BIOS中断int 0x19把第一扇区bootsect的内容加载到内存0x7c00处；第二批、第三批在bootsect的指挥下，分别把其后的4个扇区和随后的240个扇区的内容加载至内存。 计算机硬件体系结构的设计与BIOS联手操作，会让CPU接收到一个int 0x19中断。CPU接收到这个中断后，会立即在中断向量表中找到int 0x19中断向量[2]。相应的中断处理程序的作用就是把软盘第一扇区中的程序（512 B）加载到内存0x07C00处。\nbootsect.S 分配内存 为了加载setup，bootsect首先就需要对后续操作所涉及的内存位置进行设置，包括将要加载的setup程序的扇区数（SETUPLEN）以及被加载到的位置（SETUPSEG）；启动扇区被BIOS加载的位置（BOOTSEG）及将要移动到的新位置（INITSEG）；内核（kernel）被加载的位置（SYSSEG）、内核的末尾位置（ENDSEG）及根文件系统设备号（ROOT_DEV）\n1 2 3 4 5 6 7 8 9 10 SETUPLEN = 4\t! nr of setup-sectors BOOTSEG = 0x07c0\t! original address of boot-sector INITSEG = DEF_INITSEG\t! we move boot here - out of the way SETUPSEG = DEF_SETUPSEG\t! setup starts here SYSSEG = DEF_SYSSEG\t! system loaded at 0x10000 (65536). ENDSEG = SYSSEG + SYSSIZE\t! where to stop loading ! ROOT_DEV \u0026amp; SWAP_DEV are now written by \u0026#34;build\u0026#34;. ROOT_DEV = 0 SWAP_DEV = 0 复制bootsect bootsect启动程序将它自身（全部的512 B内容）从内存0x07C00（BOOTSEG）处复制至内存0x90000（INITSEG）处。 加载setup（第二部分内核代码） 借助BIOS提供的int 0x13中断向量所指向的中断服务程序（也就是磁盘服务程序）加载setup到内存中，一共4个扇区\n加载system模块（第三部分内核代码） 任然利用BIOS 提供的int 0x13中断服务，将system模块加载到内核，一共240个扇区\n确定根设备号 setup.s 设置内核参数 setup程序做的第一件事情就是利用BIOS提供的中断服务程序从设备上提取内核运行所需的机器系统数据，其中包括光标位置、显示页面等数据，并分别从中断向量0x41和0x46向量值所指的内存地址处获取硬盘参数表1、硬盘参数表2，把它们存放在0x9000:0x0080和0x9000:0x0090处。BIOS提取的机器系统数据将覆盖bootsect程序所在部分区域。 移动system 将system模块从0x10000~0x8fff(当时认为内核系统模块system的长度不会超过此值：512KB) 整块向下移动到内存绝对地址0x00000处\n进入保护模式 加载中断描述符表寄存器(idtr)和全局描述符表寄存器(gdtr),开启A20地址线，重新设置两个中断控制芯⽚8259A,将硬件中断号重新设置为0x20~0x2f。最后设置CPU的控制寄存器CR0(也称机器状态字)，从而进⼊32位保护模式运行。\n当前内存的映像 head.S 程序自身的代码在程序自身所在的内存空间创建了内核分页机制，即在0x000000的位置创建了页目录表、页表、缓冲区、GDT、IDT，并将head程序已经执行过的代码所占内存空间覆盖。这意味着head程序自己将自己废弃，main函数即将开始执行 重新设置IDT 首先是加载各个数据段寄存器,重新设置中断描述符表IDT，共256项，并使各个表项均指向一个只报错误的哑中断子程序ignore_int。\n重新设置GDT 在设置好中断描述符表之后,本程序又重新设置了全局段描述符表gdt\n设置管理内存的分页处理机制 将页目录表放在绝对物理地址0开始处（也是本程序所处的物理内存位置，因此这段程序将被覆盖掉)，紧随后面放置共可寻址16MB内存的4个页表，并分别设置它们的表项。\n当前内存的映像 [1] 《Linux内核完全剖析：基于0.12内核》赵炯著\n[2] 《Linux 内核设计的艺术（第2版）》新设计团队\n[3] 《Linux内核源代码情景分析》毛德操，胡希明等\n[4] x86 - Who loads the BIOS and the memory map during boot-up - Stack Overflow\n[5] 8086CPU中14个寄存器的详解_基址寄存器\n","pubDate":"2023-02-12","title":"【Linux Kernel 0.12】启动流程"},{"link":"https://cnjslw.github.io/posts/qemu+vscode+kernel-debug/","plain":"基础环境 虚拟机环境 VMware® Workstation 16 Pro 16.2.4 build-20089737 Ubuntu14.04 amd64 真机环境 Intel(R) Core(TM) i7-7700HQ CPU （AMD64） Windows 10 专业版 22H2 Visual Studio 1.79.2 Visual Studio 插件配置 C/C++ v.1.15.4 C/C++ Extension Pack v1.3.0 Remote SSH v0.102.0 Remote SSH: Editing Configuration v0.86.0 Remote Explorer: v.0.4.0 Ubuntu14.04 设置 root 设置 1 2 //设置root密码 sudo passwd 软件更新 1 2 sudo apt-get update sudo apt-get upgrade 开机root 登录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 修改50-ubuntu.conf gedit /usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf # 修改内容 [SeatDefaults] user-session=ubuntu autologin-user=root greeter-session=unity-greete greeter-show-manual-login=true allow-guest=false # 修改.profile gedit /root/.profile # 修改内容 # mesg n tty -s \u0026amp;\u0026amp; mesg n 禁止提示ubuntu更新 参考配置方案[3] 相关软件安装 ssh安装与vscode远程连接设置 安装ssh 1 2 3 4 5 6 7 8 9 10 # 1. 安装 sudo apt-get install openssh-server -y # 2. 修改配置文件 sudo gedit /etc/ssh/sshd_config # 3. 修改选项 # Authentication: LoginGraceTime 120 #PermitRootLogin prohibit-password PermitRootLogin yes StrictModes yes Vscode 远程连接 参考配置方法[2] Linux Source Code 下载地址：\nIndex of /pub/linux/kernel/\n1 2 # 解压 tar -zxvf linux-2.6.32.20.tar.gz qemu 1 2 3 4 5 # 安装 apt-get install qemu -y # 检测安装结果 qemu-i386 -version # qemu-i386 version 2.0.0 (Debian 2.0.0+dfsg-2ubuntu1.46), Copyright (c) 2003-2008 Fabrice Bellard gcc 要求安装gcc 4.4\n1 2 3 4 5 6 7 8 9 10 # 安装 apt-get install gcc-4.4 ls /usr/bin -l | grep gcc #可以看到gcc是一个链接文件，连接到gcc-4.8版本；可以把本链接删除，重新链接gcc到gcc-4.4版本； # 删除4.8版本的gcc软连接 sudo rm -rf /usr/bin/gcc sudo ln /usr/bin/gcc-4.4 /usr/bin/gcc # 检查安装结果 sudo gcc -v # 查看最终链接好的版本。 安装必要的编译环境 1 2 3 apt-get install aptitude -y aptitude install libncurses5-dev -y apt-get install libssl-dev -y gdb 卸载原有gdb，并下载gdb源码 1 2 sudo apt-get autoremove gdb wget http://ftp.gnu.org/gnu/gdb/gdb-7.9.tar.gz 修改源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 vim gdb-7.9/gdb/remote.c # 修改内容 if (buf_len \u0026gt; 2 * rsa-\u0026gt;sizeof_g_packet) error (_(\u0026#34;Remote \u0026#39;g\u0026#39; packet reply is too long: %s\u0026#34;), rs-\u0026gt;buf); # 改为 if (buf_len \u0026gt; 2 * rsa-\u0026gt;sizeof_g_packet) { rsa-\u0026gt;sizeof_g_packet = buf_len; for (i = 0; i \u0026lt; gdbarch_num_regs (gdbarch); i++) { if (rsa-\u0026gt;regs[i].pnum == -1) continue; if (rsa-\u0026gt;regs[i].offset \u0026gt;= rsa-\u0026gt;sizeof_g_packet) rsa-\u0026gt;regs[i].in_g_packet = 0; else rsa-\u0026gt;regs[i].in_g_packet = 1; } } 编译安装 1 2 3 4 cd gdb-7.9 sudo ./configure sudo make sudo make install 检查安装结果 1 gdb -v BusyBox 源码安装编译 1 2 3 4 5 6 7 8 9 10 11 # 下载源码 wget --no-check-certification https://busybox.net/downloads/busybox-1.25.0.tar.bz2 # 解压 tar -xvjf busybox-1.25.0.tar.bz2 # 编译 make defconfig make menuconfig make -j4 make menuconfig 在编译选项中需要手动勾选的项 1 2 # 检查安装结果,与截图中的内容相同则安装成功 ./busybox ls 1 2 # 安装 make install Linux内核编译 1 2 3 4 5 6 # 下载 wget https://mirrors.edge.kernel.org/pub/linux/kernel/v2.6/linux-2.6.32.20.tar.gz # 编译 make menuconfig make -j4 检查安装结果 根文件系统制作 将busybox安装后生成的_install文件单独拷贝到一个文件夹 1 2 3 mkdir ramdisk cd ramdisk cp -r ../busy-1.25.0/_install/* . 设置初始化进程init（建立一个软链接，一定不能直接复制过去） 1 2 cd ramdisk ln -s bin/busybox init 设置开机启动程序 首先，我们需要先设定一些程序运行所需要的文件夹 1 2 cd ramdisk mkdir -pv {bin,sbin,etc,proc,sys,usr/{bin,sbin},dev} init程序首先会访问etc/inittab文件，因此，我们需要编写inittab，指定开机需要启动的所有程序 1 2 3 cd ramdisk cd etc vim inittab inittab文件添加如下内容 1 2 3 4 5 6 ::sysinit:/etc/init.d/rcS ::askfirst:-/bin/sh ::restart:/sbin/init ::ctrlaltdel:/sbin/reboot ::shutdown:/bin/umount -a -r ::shutdown:/sbin/swapoff -a 1 chmod +x inittab 编写系统初始化命令 从inittab文件中可以看出，首先执行的是/etc/init.d/rcS脚本，因此，我们生成初始化脚本 1 2 3 4 cd ramdisk mkdir init.d cd init.d vim rcS rcS文件添加如下内容\n1 2 3 4 5 6 7 #!/bin/sh mount proc mount -o remount,rw / mount -a clear echo \u0026#34;My Tiny Linux Starting, press enter to active\u0026#34; 1 chmod +x rcS 设置文件系统 在rcS脚本中，mount -a 是自动挂载 /etc/fstab 里面的东西，可以理解为挂在文件系统，因此我们还需要编写 fstab文件来设置我们的文件系统。 1 2 cd ramdisk/etc/ vim fstab 1 2 3 4 #/etc/fstab proc /proc proc defaults 0 0 sysfs /sys sysfs defaults 0 0 devtmpfs /dev devtmpfs defaults 0 0 压缩生成镜像 至此，我们已经完成了RAM Disk中相关文件的配置，可以压缩生成文件镜像了。 1 2 cd ramdisk find . -print0 | cpio --null -ov --format=newc | gzip -9 \u0026gt; ../initramfs.img 最后生成的initramfs.img就是我们的根文件系统\nqemu+gdb调试linux kernel 直接运行\n1 qemu-system-x86_64 -kernel ./linux-2.6.32.20/arch/x86_64/boot/bzImage -initrd ./initramfs.img -append \u0026#34;console=ttyS0\u0026#34; -nographic 调试运行\n1 qemu-system-x86_64 -kernel ./linux-2.6.32.20/arch/x86_64/boot/bzImage -initrd ./initramfs.img -append \u0026#34;console=ttyS0\u0026#34; -nographic -S -s 1 2 3 4 gdb vmlinux # vmlinux为内核根目录下的文件 # 进入gdb后 target remote:1234 # qemu默认端口，可以更改 Vscode 远程调试 远程连接后添加配置文件lanuch.json 运行\u0026gt;添加配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;LinuxKernel-Debug\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;miDebuggerServerAddress\u0026#34;: \u0026#34;127.0.0.1:1234\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/vmlinux\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;logging\u0026#34;: { \u0026#34;engineLogging\u0026#34;: false }, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;/usr/local/bin/gdb\u0026#34; } ] } 正常调试\n[1] QEMU+GDB调试Linux内核总结\n[2] VSCode使用Remote SSH连接远程服务器\n[3] 怎么禁止/开启Ubuntu自动更新升级\n[4] 搭建 Linux 内核网络调试环境\n","pubDate":"2023-02-01","title":"【Linux Kernel】Linux debug 环境搭建：qemu+vscode内核源码调试配置教程"},{"link":"https://cnjslw.github.io/posts/%E6%8C%87%E4%BB%A4%E6%A6%82%E8%BF%B0/","plain":"指令系统介绍 指令系统设计原则 指令系统的发展历程 指令内容的演变 存储管理的演变 运行级别的演变 系统指令的组成 指令系统由若⼲条指令及其操作对象组成。 每条指令都是对⼀个操作的描述, 主要包括操作码和操作数。操作码规定指令功能, 例如加减法; 操作数指示操作对象, 包含数据类型、 访存地址、 寻址方式等内容的定义。\n地址空间 操作数 指令操作和编码 补充 早期，1980s年代，x86⼀般指当时的处理器8088和80286，不过这两个处理器都是16位的。如今， x86通常指32位指令集架构的处理器，比如80386。 80386处理器是intel在1985年实现的第一款32位指令集架构的处理器，又叫i386， Intel Architecture, 32-bit，缩写为IA-32，现在， IA-32一般又能引喻成所有的支持32位计算的x86架构。按照发展历史看， x86应该是指令集概念，⼀般用于个人PC系统如8086,286,386。 IA-32是intel首推的32位架构。 x86-64/x64/amd64/Intel64。在1999年， AMD公司⾸先在IA-32基础上，增加了64位寄存器，兼容早期的16位和32位软件系统，推出了x86-64的64位微处理器，后来命名为AMD64，实现了超车。然后intel公司也接受了该方案，叫做Intel64。 x86-64应该只算是x86指令集的64位扩展，并不是⼀种全新的64位架构。由于amd64和intel64本质上是⼀样的，叫法也是很多。 AMD通常叫它x86-64、 x86_64，微软和sun等软件公司叫它x64，操作系统厂商则通常用AMD64或者amd64来指代AMD64和Intel64。IA-64是Intel推出的用于Itanium处理器（安腾处理器）的自己的Intel Architecture 64位指令集，一般用于服务器。尽管Intel64也是64位处理器，但这两者完全不是⼀回事。 IA-64软件不能直接运行于Intel64处理器上。 x86-64是IA-32指令集的扩展，⽽IA-64则是完完全全没有⼀点IA-32影子的独立处理器架构。 IA-64需要通过模拟器才能运行IA-32，但是性能大大受影响。\n市面上处理器如何区分AMD64和IA-64呢？市面上买的Intel 64-bit的cpu其实都属于amd64分类，intel64和amd64其实都应该叫做x86_64。IA64则指Itaniums系统cpu，并不是x86架构的，一般都是用于服务器，不是个⼈桌面产品，价格昂贵。\nARM64/AArch64：ARM是精简指令集RISC下的处理器架构。ARMv3⾄ARMv7⽀持32位寻址空间。 ARMv8-A 开始支持64位寻址空间。 AArch64和ARM64都是指64位的ARM架构。\n[1] 《计算机组成原理与体系架构（第3版）》胡伟武等\n","pubDate":"2023-01-15","title":"【计算机组成原理与体系架构01】指令系统设计"},{"link":"https://cnjslw.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01-%E6%A6%82%E8%BF%B0/","plain":" OSI七层网络模型 TCP/IP四层概念模型 对应网络协议 设备 应用层（Application） 应用层 HTTP, TFTP, FTP, NFS, WAIS, SMTP 表示层（Presentation） ^^ Telnet, Rlogin, SNMP, Gopher 会话层（Session） ^^ SMTP, DNS 传输层（Transport） 传输层 TCP, UDP 四层交换机、四层路由器 网络层（Transport） 网络层 IP, ICMP, ARP, RARP, AKP, UUCP 路由器、三层交换机 数据链路层（Data Link） 数据链路层 FDDI, Ethernet, Arpanet, PDN, SLIP, PPP 网桥、以太网交换机、网卡 物理层（Physical） ^^ IEEE 802.1A, IEEE 802.2到IEEE 802.11 中继器、集线器、双绞线 TCP/IP协议族 TCP/IP分层 分用 每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用(Demultiplexing)\n封装 ","pubDate":"2022-07-17","title":"【计算机网络 01】概述"},{"link":"https://cnjslw.github.io/posts/%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%8F%8B%E5%85%83/","plain":"如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例\n1、友元类 传统友元类的概念是：让某个类B成为另外一个类A的友元类，这样的话，类B就可以在其成员函数中访问类A的所有成员（成员变量、成员函数），而不管这些成员在类A中是用什么修饰符（private、protected、public）修饰的。\n1.1 让类模板的某个实例称为友元类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 template \u0026lt;typename U\u0026gt; class B; template \u0026lt;typename T\u0026gt; class A { friend class B\u0026lt;long\u0026gt;; private: int data; }; template \u0026lt;typename U\u0026gt; class B { public: void callBAF() { A\u0026lt;int\u0026gt; atmpobj; atmpobj.data = 5 ; std::cout \u0026lt;\u0026lt; atmpobj.data\u0026lt;\u0026lt;std::endl; } }; int main() { B\u0026lt;long\u0026gt; bobj ; bobj.callBAF(); } 让类模板B的特定类模板实例（也就是B\u0026lt;long\u0026gt;）成为类模板A的友元类。也就是说，B\u0026lt;long\u0026gt;实际上代表的是一个具体的类\n1.2 让类模板成为友元类模板 整个类模板B变成类模板A的友元类模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 template \u0026lt;typename U\u0026gt; class B; template \u0026lt;typename T\u0026gt; class A { template\u0026lt;typename \u0026gt; friend class B; private: int data; }; template \u0026lt;typename U\u0026gt; class B { public: void callBAF() { A\u0026lt;int\u0026gt; atmpobj; atmpobj.data = 5 ; std::cout \u0026lt;\u0026lt; atmpobj.data\u0026lt;\u0026lt;std::endl; } }; int main() { B\u0026lt;long\u0026gt; bobj ; bobj.callBAF(); B\u0026lt;int\u0026gt; bobjs ; bobjs.callBAF(); } 1.3 让类型模板参数成为友元类（C++11） 如果传递进来的类型模板参数是一个类类型，则这个类类型可以成为当前类模板的友元类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template \u0026lt;typename T\u0026gt; class A2 { friend T; private int data; }; class CF { public: void callCFAF() { A2\u0026lt;CF\u0026gt; aobj; aobj.data=12; } }; int main() { CF mycfobj; mycfobj.callCFAF(); } 类模板有其特殊性，如果传递给类模板A2的类型模板参数不是一个类类型，那么代码行friend T;就会被忽略，从而不能访问data成员变量\n2、友元函数 2.1 让函数模板的某个实例成为友元函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 template\u0026lt;typename U , typename V\u0026gt; void func(U val1 , V val2); class Men { private: void funcmen()const { cout\u0026lt;\u0026lt;\u0026#34;Men::funcmen被调用了\u0026#34;\u0026lt;\u0026lt;endl; } friend void func\u0026lt;int , int\u0026gt;(int , int); friend void func\u0026lt;\u0026gt;(float , int);//尖括号内保持为空，编译器会用指定的实参类型推导出模板参数的类型 friend void func\u0026lt;\u0026gt;(int , float); }; template\u0026lt;typename U , typename V\u0026gt; void func(U val1 , V val2) { Men mymen; mymen.funcmen(); } int main() { func(2,3);//func\u0026lt;int ,int\u0026gt; func\u0026lt;float\u0026gt;(4.6f , 5);//func\u0026lt;float,int\u0026gt; func\u0026lt;int , float\u0026gt;(4,5.6f);//func\u0026lt;int ,float\u0026gt; } 2.2 友元模板 上面的范例中，只是让函数模板func()的某个实例成为Men类模板的友元函数，而且为了应对不同的情况，还要分别设置多个func()函数模板的实例成为Men类模板的友元函数。显然，如果希望所有func()实例都成为Men类模板的友元函数，像上面这样一个个设置很辛苦。所以，为了做到这点，就需要让函数模板func()成为Men类模板的友元模板。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Men { private: void funcmen()const { cout\u0026lt;\u0026lt;\u0026#34;Men::funcmen被调用了\u0026#34;\u0026lt;\u0026lt;endl; } template \u0026lt;typename U , typename V\u0026gt; friend void func(U val1 , V val2); }; template\u0026lt;typename U , typename V\u0026gt; void func(U val1 , V val2) { Men mymen; mymen.funcmen(); } int main() { func(2,3);//func\u0026lt;int ,int\u0026gt; func\u0026lt;float\u0026gt;(4.6f , 5);//func\u0026lt;float,int\u0026gt; func\u0026lt;int , float\u0026gt;(4,5.6f);//func\u0026lt;int ,float\u0026gt; } 所有func()函数模板的实例就都成为Men类模板的友元函数,也不再需要在类模板Men定义的前面增加针对函数模板func()的声明了。编译器是把全特化的func()函数模板看作一个实例化过的函数模板（理解得更直接一点，就是看作一个已经存在了的函数）\n2.3 在类模板中定义友元函数 可以在一个类模板中定义（不是声明）一个友元函数，这种友元函数是能被调用的，而且也只有在代码中调用了这个函数时，编译器才会实例化这个函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 template \u0026lt;typename Z\u0026gt; class Men { public: friend void func2(Men\u0026lt;Z\u0026gt;\u0026amp;tmpmen){ tmpmen.funcmen(); } void funcmen()const { cout\u0026lt;\u0026lt;\u0026#34;Men::funcmen被调用了\u0026#34;\u0026lt;\u0026lt;endl; } }; int main() { Men\u0026lt;double\u0026gt; mymen2; func2(mymen2); } 虽然func2()友元函数被写在一个类模板中，但是类模板被实例化时并不会实例化这些友元函数，只有代码中调用到这些函数时，这些函数才会被实例化。另外值得一提的就是，因为func2()是写在类模板定义中的，所以，当调用func2()时，如果func2()中的代码非常简单，那么聪明的编译器就会把func2()当作一个内联（Inline）函数来处理；如果func2()中的代码比较复杂（如出现了for循环等），那么func2()就很可能不会被当作一个内联函数处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //由cppinsights.io 生成 template\u0026lt;typename Z\u0026gt; class Men { public: friend inline void func2(Men\u0026lt;Z\u0026gt; \u0026amp; tmpmen) { tmpmen.funcmen(); } inline void funcmen() const { std::operator\u0026lt;\u0026lt;(std::cout, \u0026#34;Men::funcmen\\350\\242\\253\\350\\260\\203\\347\\224\\250\\344\\272\\206\u0026#34;).operator\u0026lt;\u0026lt;(std::endl); } }; /* First instantiated from: insights.cpp:20 */ #ifdef INSIGHTS_USE_TEMPLATE template\u0026lt;\u0026gt; class Men\u0026lt;double\u0026gt; { public: friend inline void func2(Men\u0026lt;double\u0026gt; \u0026amp; tmpmen) { tmpmen.funcmen(); } inline void funcmen() const { std::operator\u0026lt;\u0026lt;(std::cout, \u0026#34;Men::funcmen\\350\\242\\253\\350\\260\\203\\347\\224\\250\\344\\272\\206\u0026#34;).operator\u0026lt;\u0026lt;(std::endl); } // inline constexpr Men() noexcept = default; }; #endif int main() { Men\u0026lt;double\u0026gt; mymen2 = Men\u0026lt;double\u0026gt;(); func2(mymen2); return 0; } ","pubDate":"2022-06-22","title":"【模板与泛型编程03】类模板和友元"},{"link":"https://cnjslw.github.io/posts/%E7%B1%BB%E6%A8%A1%E6%9D%BF/","plain":"一、定义类模板 1、基本范例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //一个简单模板类 template \u0026lt;typename T\u0026gt; class Blob { public: typedef T value_type; typedef typename std::vector\u0026lt;T\u0026gt;::size_type size_type; //构造函数 Blob(); Blob(std::initializer_list\u0026lt;T\u0026gt; il); // Blob中的元素数目 size_type size () const { return data-\u0026gt;size(); } bool empty() const { return data-\u0026gt;empty(); } //添加和删除元素 void push_back(const T \u0026amp;t) {data-\u0026gt;push_back(t);} //移动版本 void push_back(T \u0026amp;\u0026amp;t){data-\u0026gt;push_back(std::move(t)); } void pop_back(); //元亲访问 T\u0026amp; back(); T\u0026amp; operator [](size_type i); private: std::shared_ptr\u0026lt;std::vector\u0026lt;T\u0026gt;\u0026gt; data; // 若 data [ i]无效，则抛出msg void check(size_type i, const std::string \u0026amp;msg) const; }; template\u0026lt;typename T\u0026gt; Blob\u0026lt;T\u0026gt;::check(size_type i, const std::string \u0026amp;msg) const { //...... } 对于类模板Blob，Blob可以称为类名或类模板，而Blob\u0026lt;T\u0026gt;可以称为类型名（Blob后面带了尖括号，所以表示的是一个具体类型），其中的T称为模板参数，T本身代表的也是一个类型（容器中的元素类型），\n2、模板参数 2.1 类型参数 同函数模板\n2.2 默认参数 2.2.1 常规默认参数 如果某个模板参数有默认值，那么从这个有默认值的模板参数开始，后面的所有模板参数都得有默认值\n1 2 3 4 5 6 7 8 9 10 11 template \u0026lt;typename T=char , typename U=int\u0026gt; struct TC { //... }; int main() { TC\u0026lt;\u0026gt; mytc1; //TC\u0026lt;char,int\u0026gt; TC\u0026lt;double\u0026gt; mytc2; //TC\u0026lt;char,double\u0026gt; } 2.2.2 后面的模板参数依赖前面的模板参数 1 template \u0026lt;typename T,typename U = T*\u0026gt; struct TC{}; 2.3 非类型模板参数 1 2 3 4 5 6 template \u0026lt;typename T , typename U , size_t arrsize = 8\u0026gt; struct TC { T m_arr[arrsize]; void functest(); }; 和函数模板一样，类模板非类型模板参数同样有限制，但是有两点有别于函数模板\n全局指针不能作为模板参数 字符串常量无法作为模板参数 1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;const char *p\u0026gt; struct TC { TC(){}\t}; const char* g_s = \u0026#34;hello\u0026#34;; int main() { TC\u0026lt;g_s\u0026gt; mytc1; //× TC\u0026lt;\u0026#34;hello\u0026#34;\u0026gt; mytc2; //× } 3、类型别名 对于模板，类型名往往比较长（实际的项目中往往比这里举例的类型名长很多），所以可以用typedef或using给这些类型名起一个额外的别名以简化书写，下面是使用typedef的方法\n1 2 typedef TC\u0026lt;int , float\u0026gt; IF_TC; IF_TC mytc1; C++11支持using\n1 2 using IF_TCU = TC\u0026lt;int , float\u0026gt;; IF_TCU mytc2; 二、实例化类模板 类模板中，只有被调用的成员函数，编译器才会产生出这些函数的实例化代码。如果类模板中有静态成员函数，那么当这个静态成员函数被调用的时候，也会被实例化。\n1、模板参数推断 不同于函数模板，编译器不能推断模板参数类型（C++17中这特特性已经失效）。为了使用类模板，我们必须在模板名后的尖括号中提供额外信息，提供显式模板实参列表，来实例化出特定的类。 一个类模板中所有的实例都形成一个独立的类。 2、特化 以下列代码为范例，说明类模板特化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template \u0026lt;typename T, typename U\u0026gt; struct TC { TC() {cout \u0026lt;\u0026lt; \u0026#34;TC泛化版本构造函数\u0026#34; \u0026lt;\u0026lt; endl; } void functest1() { cout \u0026lt;\u0026lt; \u0026#34;functest1泛化版本\u0026#34; \u0026lt;\u0026lt; endl; } void functest2() ; }; template \u0026lt;\u0026gt; void TC\u0026lt;int,int\u0026gt;::functest2(){cout\u0026lt;\u0026lt;\u0026#34;类模板成员函数的类外定义\u0026#34;\u0026lt;\u0026lt;endl;} int main() { TC\u0026lt;int , float\u0026gt; mytc; mytc.functest1(); } 2.1 全特化 概念同函数模板全特化一样，无非就是将模板参数用具体类型替代\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template \u0026lt;typename T, typename U\u0026gt; struct TC { TC() {cout \u0026lt;\u0026lt; \u0026#34;TC泛化版本构造函数\u0026#34; \u0026lt;\u0026lt; endl; } void functest1() { cout \u0026lt;\u0026lt; \u0026#34;functest1泛化版本\u0026#34; \u0026lt;\u0026lt; endl; } void functest2() ; }; template \u0026lt;\u0026gt; struct TC\u0026lt;int , int\u0026gt; //T == int , U == int { TC() {cout \u0026lt;\u0026lt; \u0026#34;TC特化版本构造函数\u0026#34; \u0026lt;\u0026lt; endl; } void functest1(); }; void TC\u0026lt;int ,int\u0026gt;::functest1() { cout \u0026lt;\u0026lt; \u0026#34;functest1特化版本的类成员函数类外定义\u0026#34; \u0026lt;\u0026lt; endl; } int main() { TC\u0026lt;int , int\u0026gt; mytc; mytc.functest1(); } 2.2 普通成员函数的全特化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template \u0026lt;typename T, typename U\u0026gt; struct TC { TC() {cout \u0026lt;\u0026lt; \u0026#34;TC泛化版本构造函数\u0026#34; \u0026lt;\u0026lt; endl; } void functest1() { cout \u0026lt;\u0026lt; \u0026#34;functest1泛化版本\u0026#34; \u0026lt;\u0026lt; endl; } void functest2() ; }; template\u0026lt;\u0026gt; void TC\u0026lt;double,double\u0026gt;::functest2() { cout\u0026lt;\u0026lt;\u0026#34;普通成员函数的全特化\u0026#34;\u0026lt;\u0026lt;endl; } int main() { TC\u0026lt;double , double\u0026gt; mytc; mytc.functest2(); } 2.3 静态成员变量的全特化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 template \u0026lt;typename T, typename U\u0026gt; struct TC { TC() {cout \u0026lt;\u0026lt; \u0026#34;TC泛化版本构造函数\u0026#34; \u0026lt;\u0026lt; endl; } void functest1() { cout \u0026lt;\u0026lt; \u0026#34;functest1泛化版本\u0026#34; \u0026lt;\u0026lt; endl; } void functest2() ; static int m_stc; static int m_sts; }; //静态成员变量泛化版本定义 template\u0026lt;typename T,typename U\u0026gt; int TC\u0026lt;T,U\u0026gt;::m_stc =50; //静态成员变量特化版本定义 template\u0026lt;\u0026gt; int TC\u0026lt;int,int\u0026gt;::m_sts = 100; int main() { TC\u0026lt;int,int\u0026gt; mytc; cout\u0026lt;\u0026lt;mytc.m_sts;//c++11,如果对象不是int,int类型实例化，编译器Warning cout\u0026lt;\u0026lt;mytc.m_stc; } 如果进行了普通成员函数的全特化，或者是静态成员变量的全特化，那么就无法用这些全特化时指定的类型对整个类模板进行全特化了。\n3、偏特化 3.1 模板参数数量上的偏特化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template \u0026lt;typename T, typename U\u0026gt; struct TC { TC() {cout \u0026lt;\u0026lt; \u0026#34;TC泛化版本构造函数\u0026#34; \u0026lt;\u0026lt; endl; } }; template\u0026lt;typename U\u0026gt; struct TC\u0026lt;double,U\u0026gt; { TC() {cout \u0026lt;\u0026lt; \u0026#34;TC偏特化构造函数\u0026#34; \u0026lt;\u0026lt; endl; } void functest1(); }; template\u0026lt;typename U\u0026gt; void TC\u0026lt;double ,U\u0026gt;::functest1() { cout \u0026lt;\u0026lt; \u0026#34;TC偏特化的成员函数类外定义\u0026#34; \u0026lt;\u0026lt; endl; } int main() { TC\u0026lt;double , double\u0026gt; mytc; mytc.functest1(); } 类模板偏特化版本中的类型模板参数不可以有默认值\n3.2 模板参数范围上的偏特化 同函数模板一致\n4、C++17中的类模板参数推断 4.1 隐式推断 隐式的推断指南，必须依托于构造函数存在\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template \u0026lt;typename T\u0026gt; struct A { A(T val1, T val2) { cout\u0026lt;\u0026lt;\u0026#34;A::A(T val1 , T val2)\u0026#34;\u0026lt;\u0026lt;endl; } A(T val) { cout\u0026lt;\u0026lt;\u0026#34;A::A(T val)\u0026#34;\u0026lt;\u0026lt;endl; } }; int main() { A obj1(15,16); // A\u0026lt;int\u0026gt; A obj2(17.7); // A\u0026lt;double\u0026gt; return 0; } 4.2 自定义推断 1 2 3 4 5 6 7 8 9 10 11 12 13 template \u0026lt;typename T\u0026gt; struct B { T m_b; }; template\u0026lt;typename T\u0026gt; B\u0026lt;T\u0026gt;-\u0026gt;B\u0026lt;T\u0026gt;;//自定义模板推断 int main() { B obj{15}; return 0; } 自定义推断有严格的使用条件，类B只有普通数据成员(聚合类)\n三、类模板的成员 1、成员函数模板 1.1 基本含义、构造函数模板 不管是普通的类，还是类模板，都可以为其定义成员函数模板，这种情况就是类（类模板）和其成员函数模板都有各自独立的模板参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;typename T1\u0026gt; class A { public: template \u0026lt;typename T2\u0026gt; A(T2 v1, T2 v2); template \u0026lt;typename T3\u0026gt; void myft(T3 tmpt) { cout\u0026lt;\u0026lt;tmpt\u0026lt;\u0026lt;endl; } T1 m_ic; static constexpr int m_stcvalue = 200; }; template \u0026lt;typename T1\u0026gt; template \u0026lt;typename T2\u0026gt; A\u0026lt;T1\u0026gt;::A(T2 v1,T2 v2) { cout\u0026lt;\u0026lt;\u0026#34;A::A(T2,T2)执行了!\u0026#34;\u0026lt;\u0026lt;endl; } int main() { A\u0026lt;float\u0026gt; a(1,2); a.myft(3); A\u0026lt;float\u0026gt; a2(1.1 , 2.2); A\u0026lt;float\u0026gt; a3(11.1f , 12.2f); } 类模板中的成员函数，只有源程序代码中出现调用这些成员函数的代码时，这些成员函数才会出现在一个实例化的类模板中 类模板中的成员函数模板，只有源程序代码中出现调用这些成员函数模板的代码时，这些成员函数模板的具体实例才会出现在一个实例化的类模板中。 目前的编译器并不支持虚成员函数模板，因为虚函数表vtbl的大小是固定的，每个表项里面就是一个虚函数地址。但是成员函数模板只有被调用的时候才能实例化（否则编译器也不知道要用什么模板参数实例化这个成员函数模板） 当函数和函数模板都合适时，编译器会优先选择函数而非函数模板 1.2 拷贝构造函数模板与拷贝赋值运算符模板 1 2 3 4 5 6 7 8 9 10 11 12 13 //续写上一小节类模板 template \u0026lt;typename U\u0026gt; A(const A\u0026lt;U\u0026gt;\u0026amp; other) { cout \u0026lt;\u0026lt;\u0026#34;A::A(const A\u0026lt;U\u0026gt;\u0026amp; other)拷贝构造函数模板执行了！\u0026#34;\u0026lt;\u0026lt;endl; } template \u0026lt;typename U\u0026gt; A\u0026lt;T1\u0026gt;\u0026amp; operator=(const A\u0026lt;U\u0026gt;\u0026amp; other) { cout \u0026lt;\u0026lt;\u0026#34;operator=(const A\u0026lt;U\u0026gt;\u0026amp; other)拷贝赋值运算符模板执行了\u0026#34;\u0026lt;\u0026lt;endl; return *this; } 拷贝构造函数模板不是拷贝构造函数，拷贝赋值运算符模板不是拷贝赋值运算符（其实这句话也同样适合构造函数模板不是构造函数）。因为拷贝构造函数或拷贝赋值运算符要求拷贝的对象类型完全相同，而拷贝构造函数模板或拷贝赋值运算符模板就没有这种要求。\n1 2 3 4 5 6 7 int main() { A\u0026lt;float\u0026gt; a3(1,2); a3.m_ic = 16.2f; A\u0026lt;float\u0026gt; a4(a3);//当执行A\u0026lt;float\u0026gt; a4(a3);代码行时，实际是要执行类模板A中的拷贝构造函数，但是类模板A中并没有拷贝构造函数，所以，编译器内部实际是执行了按值拷贝的一个动作，使a4.m_ic=16.2f。请记住：拷贝构造函数模板永远不可能成为拷贝构造函数，需要执行拷贝构造函数的地方，绝不会因为拷贝构造函数模板的存在就用对拷贝构造函数模板的调用代替对拷贝构造函数的调用。 A\u0026lt;int\u0026gt; a5(a3);//类型不同（都是用类模板A实例化出来的类）的两个对象，用一个拷贝构造另外一个时会调用模板拷贝构造函数。因为a5是A\u0026lt;int\u0026gt;类型，a3是A\u0026lt;float\u0026gt;类型，两者类型不同，所以，利用a3构造a5时，就会导致拷贝构造函数模板的执行。 } 1.3 特化 成员函数模板也能被特化，但是具体能特化到什么程度，可能不同编译器的标准不同\n2、类模板的嵌套 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //在上文中的类中继续添加 template \u0026lt;typename T1\u0026gt; class A { public: template \u0026lt;typename U\u0026gt; class OtherC { public: void myFunC() { cout\u0026lt;\u0026lt;\u0026#34;myFunc执行了\u0026#34;\u0026lt;\u0026lt;endl; } } }; //把myFunC()成员函数写在类模板A的float全特化版本定义外面 A\u0026lt;float\u0026gt;::OtherC\u0026lt;U\u0026gt;::myFunC(){cout\u0026lt;\u0026lt;\u0026#34;嵌入模板类的成员函数的类外定义\u0026#34;}; //把myFunC()成员函数写在类模板A的float全特化版本定义外面 template \u0026lt;typename T1\u0026gt; template \u0026lt;typename U\u0026gt; A\u0026lt;T1\u0026gt;::OtherC\u0026lt;U\u0026gt;::myFunC(){cout\u0026lt;\u0026lt;\u0026#34;嵌入模板类的成员函数的类外定义\u0026#34;}; int main() { A\u0026lt;float\u0026gt;::OtherC\u0026lt;float\u0026gt; myObjC; myObjC.myFunc(); } 3、变量模板与成员变量模板（C++14） 变量模板的英文为Variable Templates，是C++14标准引入的。一般这种变量模板需要定义在全局空间或命名空间中（一般也是放在.h头文件中）\n1 2 3 4 5 6 7 8 template \u0026lt;typenam T\u0026gt; T g_myvar{}; int main() { g_myvar\u0026lt;float\u0026gt; = 15.6f; g_myvar\u0026lt;int\u0026gt; = 13; cout\u0026lt;\u0026lt;g_myvar\u0026lt;float\u0026gt;\u0026lt;\u0026lt;endl;//15.6 cout\u0026lt;\u0026lt;g_myvar\u0026lt;int\u0026gt;\u0026lt;\u0026lt;endl;//13 } g_myvar后面跟了一个大括号{}，其实这是一种对变量的初始化方式，一般叫零初始化。所谓零初始化，就是数值型变量初始化为0；指针型变量初始化为nullptr；布尔型变量初始化为false，诸如此类（如果不对这些变量进行初始化，那么如果这些变量是局部变量的话，它们的值就可能是任意值）\n3.1 变量模板的特化 3.1.1 全特化 1 2 3 4 5 template\u0026lt;\u0026gt;char T g_myvar\u0026lt;double\u0026gt;{};//不需要正在特化类型（double）与这个变量模板类型（char）保持一致 int main() { g_myvar\u0026lt;double\u0026gt; =\u0026#39;2\u0026#39;;//g_myvar\u0026lt;double\u0026gt;当作一个char类型的变量使用了，它能够存储的数据范围当然也是与char类型变量一致的 } 3.1.2 偏特化 1 template\u0026lt;typename T\u0026gt; T g_myvar\u0026lt;T *\u0026gt;{120}; 3.2 默认模板参数 1 2 3 4 5 6 7 8 template \u0026lt;typename T = int\u0026gt; T g_myvar; int main() { g_myvar\u0026lt;int\u0026gt; = 13; g_myvar\u0026lt;\u0026gt; = 26; cout \u0026lt;\u0026lt; g_myvar\u0026lt;int\u0026gt;\u0026lt;\u0026lt;endl; //13 cout \u0026lt;\u0026lt; g_myvar\u0026lt;\u0026gt; \u0026lt;\u0026lt; endl; //26 } 3.3 非类型模板参数 1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename T,int value\u0026gt; T g_myvar3[value]; int main() { for(int i = 0; i \u0026lt; 15; ++i) { g_myvar3\u0026lt;int, 15\u0026gt;[i] = i; /*注意[]中的下标数字\u0026lt;=14，否则下标会越界，g_myvar3\u0026lt;int, 15\u0026gt;的写法一出现，就表示定义了int g_myvar3\u0026lt;int, 15\u0026gt;[15] 这个有15个元素的int类型数组*/ } } 4、别名模板与成员别名模板 别名模板的英文叫作Alias Templates，是C++ 11标准引入的，引入的目的是不但能简化书写，而且可以达到通过其他手段很难实现的效果，一般都是通过using实现别名模板\n1 2 3 4 5 6 7 8 #include \u0026lt;map\u0026gt; template \u0026lt;typename T\u0026gt; using str_map_t = std::map\u0026lt;std::string,T\u0026gt;; int main() { str_map_t \u0026lt;int\u0026gt; map1; map1.insert({\u0026#34;first\u0026#34;,1}); map2.insert({\u0026#34;second\u0026#34;,2}); } 5、模板模板参数 模板模板参数的英文为Template Template Parameters，名字比较绕嘴，就是让模板参数本身成为模板的意思。\nint是一个类型（简单类型/内部类型） vector或list是C++标准库中的容器，具体称呼应该是类模板（类名），而诸如vector\u0026lt;int\u0026gt;或list\u0026lt;double\u0026gt;就属于模板被实例化了的产物，称为类型（类类型） 假设一个需求，创建一个叫作myclass的类模板，这个类模板中，有一个成员变量myc，这个成员变量是一个容器（可能是一个vector或list，或者其他容器），希望在实例化myclass类模板时能够通过模板参数指定myc是什么类型的容器，以及指定这个容器中所装的元素类型。\n1 2 3 4 5 6 7 8 9 10 template \u0026lt;typename T , typename\u0026lt;class\u0026gt; class Container = std::vector\u0026gt; /* Container代表的是一个类模板（类名）,把类模板（而不是类型）当作一个参数传递到myclass中,这种模板参数就不叫作“类型模板参数”，而是叫作“模板模板参数” */ class myclass { public: Container\u0026lt;T\u0026gt; myc; }; template\u0026lt;class\u0026gt; class Container，是myclass这个类模板的模板参数，而Container本身也是一个模板，所以Container就叫“模板模板参数”\n6、共用体模板(联合模板) 1 2 3 4 5 6 7 8 9 10 11 12 template \u0026lt;typename T , typename U\u0026gt; union myuni { T carnum; U cartype; U cname[60]; }; int main() { myuni\u0026lt;int , char\u0026gt; myu ; myu.carnum =156; } ","pubDate":"2022-06-20","title":"【模板与泛型编程02】类模板"},{"link":"https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/","plain":"一、定义函数模板 1、基本范例 1 2 3 4 5 6 7 template \u0026lt;typename T\u0026gt; int compare(const T \u0026amp;v1 , const T \u0026amp;v2) { if(v1 \u0026lt; v2) return -1; if(v2 \u0026lt; v1) return 1; return 0; } 模板定义以关键字 template开始，后接模板形参表，模板形参表是用尖括号\u0026lt;\u0026gt;括住的一个或多个模板形参的列表，用逗号分隔，不能为空。\n模板程序应该尽量减少对实参类型的要求。 函数模板和类模板成员函数的定义通常放在头文件中。 2、模板参数 2.1 类型参数 类型参数前必须使用关键字class或者typename，这两个关键字含义相同，可以互换使用。旧的程序只能使用class。但是有些时候，class并不合适\n2.2 默认参数 1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename T , typename F = FunType\u0026gt; void TestFunc(T i , T j , F funcpoint=mf) { cout\u0026lt;\u0026lt;funcpoint(i,j)\u0026lt;\u0026lt;endl; } int main() { TestFunc(15,16); return 0; } 调用Testfunc()函数的时候，不用指定第3个实参，因为第3个参数有默认值。要注意默认参数的写法：针对当前的范例，类型模板参数F给了默认值，函数的形参也给了默认值。默认模板参数F是一个函数指针类型（FuncType），函数参数funcpoint = mf中的mf是函数名，代表函数首地址\n另外，函数模板的默认模板参数可以放在前面（这一点类模板默认模板参数不一样，类模板的模板参数一旦有一个是默认参数，则其后续的参数都需要是默认参数）。\n2.3 非类型参数 除了定义类型参数，还可以在模板中定义非类型参数(nontype parameter) 表示一个值而非一个类型。 当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达，从而允许编译器在编译时实例化模板。\n1 2 3 4 5 6 7 8 9 template\u0026lt;unsigned N , unsigned M\u0026gt; int compare(const char (\u0026amp;p1)[N] , const char (\u0026amp;p2)[M]) { return strcmp(p1,p2); } compare(\u0026#34;hi\u0026#34; , \u0026#34;mom\u0026#34;); //实例化模板 //int compare(const char (\u0026amp;p1)[3] , const char (\u0026amp;p2)[4]) 一个非类型参数可以是一个整形，或者是一个指向对象或函数类型的指针或引用，绑定到非类型整数参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参，必须具有静态的生存期。\n但是，并不是任何类型的参数都可以作为非类型模板参数，一般有以下一些是允许的 （1）整型或枚举类型。 （2）指针类型。 （3）左值引用类型。 （4）auto或decltype(auto)。对于decltype(auto)这个用法，其中的auto理解成要推导的类型，而decltype理解成推导过程采用decltype推导。 （5）可能还有其他类型，请读者自行在学习或阅读他人代码的过程中收集和总结。\n二、 实例化函数模板 这里可以给实例化一个定义：用具体的“类型”代替“类型模板参数”的过程就叫作实例化（也称为代码生成器）。\n1、一个错误的实例化示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template \u0026lt;typename T\u0026gt; T sub(T tv1 , T tv2) { return tv1 - tv2; } int main() { int v1 = 1; int v2 = 2; sub(v1,v2);//return -1 string s1 = \u0026#34;Hello\u0026#34;; string s2 = \u0026#34;World\u0026#34;; sub(s1,s2);//报错 return 0; } 所以，同样一个函数模板，可能以某种方式进行调用是合法的，而换一种方式调用就不合法了。尤其值得注意的是，这种合法性，在==编译阶段就可以由编译器判断出来==，因为这些对Sub()函数模板的调用代码就在这里摆着，编译器有能力在编译时就从这些调用代码中去推断Sub()函数模板中的模板参数T的类型。根据模板参数T的类型，编译器就能够判断出这个类型是否支持减法运算。\n2、编译器视角的实例化 1 2 sub(1,2); sub(1.1 , 2.2); 1 2 //.obj int __cdecl sub\u0026lt;int\u0026gt;(int,int) double __cdecl sub\u0026lt; double \u0026gt;( double, double) 这说明在编译阶段，在对模板进行具体针对某类型的实例化之前，编译器需要查看函数模板的函数体，确定能否针对该类型进行实例化\n当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码\n当编译器遇到类和普通函数\n普通函数 当我们调用一个函数时，编译器只需要掌握函数的声明 类 当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现 我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中 为了生成个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义，所以函数模板与类模板成员函数的定义通常放在头文件中。\n3、模板参数的实例化 1 2 3 4 5 template\u0026lt;typename T\u0026gt; T mydouble(T tmpvalue) { return tmpvalue * 2; } 3.1 显示实例化 1 2 int result = mydouble\u0026lt;int\u0026gt;(16); int result = mydouble\u0026lt;int\u0026gt;(17.7);//warning C4244: “参数”: 从“double”转换到“T”，可能丢失数据 3.2 隐式实例化 1 2 3 cout \u0026lt;\u0026lt; compare(1,0) \u0026lt;\u0026lt; endl; //实例化出一个特别版本的函数 //compare(const int\u0026amp; , const int\u0026amp;); 编译器用函数实参来为我们推断模板实参，实参类型是int。编译器会推断出模板实参为int , 并将它绑定到模板参数T。 编译器用推断出的模板参数来为我们实例化(instantiate) 一个特定版本的函数\n隐式实例化下的空参数列表\n1 auto result = mydouble\u0026lt;\u0026gt;(16.9); \u0026lt; \u0026gt;的作用：\u0026lt; \u0026gt;没什么用处，但是当有一个也叫作mydouble()的普通函数存在时，\u0026lt; \u0026gt;也许就会发挥作用\n3.3 部分实例化 1 2 3 4 5 6 7 8 9 10 11 12 template \u0026lt;typename V,typename T,typename U\u0026gt; V Add(T tv1, U tv2) { return tv1 + tv2; } int main() { Add(15,17.8);//error C2672: “Add”\u0026#34;: 找到匹配的重载函数 error C2783: “V Add(T,U)”: 未能为“V”推导模板参数 Add\u0026lt;double\u0026gt;(1.1 , 2); // return 3.1 return 0; } 通过尖括号指定一部分模板参数，另外一部分模板参数可以让编译器去推断。但是，一旦从某个模板参数开始推断，后续的所有模板参数都需要让编译器推断，==不可以自己指定第1个类型V和第3个类型U，然后推断中间第2个类型T，编译器不支持这种语法。==\n3.4 特化 1 2 3 4 5 6 7 template \u0026lt;typename T, typename U\u0026gt; void tfunc(T\u0026amp; tmprv, U\u0026amp; tmprv2) { cout \u0026lt;\u0026lt; \u0026#34;tfunc泛化版本\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; tmprv \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; tmprv2 \u0026lt;\u0026lt; endl; } 3.4.1 全特化 所谓全特化，就是把tfunc()这个泛化版本中的所有模板参数都用具体的类型代替，构成一个特殊的版本（全特化版本），既然所有模板参数都用具体的类型代替了，那么tfunc()泛化版本中template后面尖括号中的内容就变成空了。\n1 2 3 4 5 template\u0026lt;\u0026gt; void tfunc\u0026lt;int , double\u0026gt;(int\u0026amp; tmprv, double\u0026amp; tmprv2) { cout\u0026lt;\u0026lt;\u0026#34;tfunc特化\u0026#34;\u0026lt;\u0026lt;endl; } 全特化实际上等价于实例化一个函数模板，并不等价于一个函数重载\n1 2 3 4 void tfunc(int\u0026amp; tmprv, double\u0026amp; tmprv2) { cout\u0026lt;\u0026lt;\u0026#34;tfunc函数重载\u0026#34;\u0026lt;\u0026lt;endl; } ==调用优先级：普通函数 \u0026gt; 函数模板特化 \u0026gt; 函数模板泛化==\n3.4.2 偏特化 （1）模板参数数量上的偏特化\nWhat is : 特化第1个模板参数类型为double类型，但第2个模板参数不特化\n实际上，从模板参数数量上来讲，函数模板不能偏特化，只有类模板才能偏特化\n（2）模板参数范围上的偏特化\nWhat is : 所谓“参数范围”，比如原来是int类型，如果变成const int类型，那么与int类型相比，const int类型的范围就变小了；再比如，如果原来是任意类型T，现在变成T *（从任意类型缩小为任意指针类型），那这个类型的范围也是变小了；还有T \u0026amp;（左值引用）、T\u0026amp;\u0026amp;（右值引用），对于T，从类型范围上都属于变小了。\n对于函数模板，也不存在模板参数范围上的偏特化。因为这种所谓模板参数范围上的偏特化，实际上是函数模板的重载\n1 2 3 4 5 template \u0026lt;typename T , typename U\u0026gt; void tfunc(const T\u0026amp; tmprv1, U\u0026amp; tmprv2) { cout\u0026lt;\u0026lt;\u0026#34;函数模板的参数范围偏特化本质上是函数模板的重载\u0026#34;\u0026lt;\u0026lt;endl; } 3.5 实例化模板的返回值问题 显示实例化 1 Add\u0026lt;double\u0026gt;(1.1 , 3); auto 使用auto结合decltype完成返回值类型推断 1 2 3 4 5 6 template \u0026lt;typename V,typename T,typename U\u0026gt; auto Add(T tv1, U tv2) //auto Add(T tv1, U tv2) -\u0026gt; decltype(tv1 + tv2) { return tv1 + tv2; } 三、特异的语法 1、省略参数 不管是类型模板参数还是非类型模板参数，如果在代码中没有用到这个参数，则参数名可以省略\n1 2 3 template \u0026lt;typename T ,int value\u0026gt; auto Add2() {return 100;} 可以做如下省略\n1 2 3 template \u0026lt;typename ,int\u0026gt; auto Add2() {return 100;} 2、\u0026ldquo;无用\u0026quot;的typename 类型前面可以增加一个typename修饰以明确标识一个类型。有的时候为了表明其后面是一个类型，也需要用typename修饰\n1 2 3 4 5 template \u0026lt;typename T , typename int value\u0026gt; auto Add() { return 100; } 四、模板函数在工程中 1、inline和constexpr的含函数模板 inline或 constexpr说明符放在模板参数列表之后，返回类型之前：\n1 2 template \u0026lt;typename T\u0026gt; inline T min(const T\u0026amp;, const T\u0026amp;); template \u0026lt;typename T\u0026gt; constexpr T min(const T\u0026amp; , const T\u0026amp;); 2、编写与类型无关的代码 1 2 3 4 5 6 template \u0026lt;typename T\u0026gt; int compare(const T \u0026amp;v1 , const T \u0026amp;v2) { if(less\u0026lt;T\u0026gt;()(v1,v2)) return -1; if(less\u0026lt;T\u0026gt;()(v2,v1)) return 1; return 0; } 这样写的好处\nconst T \u0026amp;作为函数参数可以避免实参是不可调用类型 less\u0026lt;T\u0026gt;()使用标准库可以避免有些类型没有定义\u0026gt;的比较 ","pubDate":"2022-06-08","title":"【模板与泛型编程01】函数模板"},{"link":"https://cnjslw.github.io/posts/linuxdocument-00/","plain":"本篇解读Linux Document 中Memory Manger部分\nhttps://www.kernel.org/doc/html/next/admin-guide/mm/concepts.html\n虚拟内存 物理内存的关键问题？ 物理内存存在什么问题？\n内存资源紧俏 内存的有的连续有的不连续 不同架构或者相同架构的不同设计导致寻址范围不同 上述原因导致直接管理物理内存的复杂性，因此诞生了虚拟内存的概念\n虚拟内存为什么能解决物理内存的问题？ The virtual memory abstracts the details of physical memory from the application software, allows to keep only needed information in the physical memory (demand paging) and provides a mechanism for the protection and controlled sharing of data between processes.\n虚拟内存是物理内存提供如下功能：\n屏蔽物理内存细节，抽象物理内存，仅保存必要的信息，以供软件使用 保护共享数据 如何管理虚拟内存与物理内存 只有当CPU执行的当前指令试图读写内存时，就需要翻译虚拟地址为物理地址。 通过分页来管理内存，不同架构的设计允许定制化页面大小，每一个物理页面可以映射单个活多个虚拟地址，这种映射关系是由页表来管理的。页表是层级管理，高层次页表管理低层次页表，最低层次页表管理虚拟内存到物理内存的映射（也就是常说的多级页表）。顶级页表的地址存放在寄存器中。\n大页 Usually TLB is pretty scarce resource and applications with large memory working set will experience performance hit because of TLB misses\nTLB来加速通过页表查询的速度，TLB是比内存更加紧俏的资源，每一次的TLB Miss都是对性能的严重打击。 现代CPU架构允许高层次Page Table 直接映射物理页面，这样就少了几次页表的查询（因为页表是层级结构，原本只有最低层级的页表记录着最终的物理地址与虚拟地址的映射）。统称这些由非最低层级页表直接映射的页面为大页（为啥大？因为通常大于4KB）\nUsage of huge pages significantly reduces pressure on TLB, improves TLB hit-rate and thus improves overall system performance.\n大页的设计减轻了TLB的压力。\nThere are two mechanisms in Linux that enable mapping of the physical memory with the huge pages. The first one is HugeTLB filesystem, or hugetlbfs. It is a pseudo filesystem that uses RAM as its backing store. For the files created in this filesystem the data resides in the memory and mapped using huge pages. The hugetlbfs is described at HugeTLB Pages. Another, more recent, mechanism that enables use of the huge pages is called Transparent HugePages, or THP. Unlike the hugetlbfs that requires users and/or system administrators to configure what parts of the system memory should and can be mapped by the huge pages, THP manages such mappings transparently to the user and hence the name. See Transparent Hugepage Support for more details about THP.\nLinux对于这种机制的支持也是在不断改进的，Linux中实现映射物理内存到大页面的两种机制：HugeTLB文件系统和透明大页（THP）。HugeTLB文件系统需要用户或系统管理员进行配置以决定哪些内存部分应该使用大页面进行映射，而THP则通过自动管理实现了对大页面的透明映射\nZone Often hardware poses restrictions on how different physical memory ranges can be accessed. In some cases, devices cannot perform DMA to all the addressable memory. In other cases, the size of the physical memory exceeds the maximal addressable size of virtual memory and special actions are required to access portions of the memory. Linux groups memory pages into zones according to their possible usage. For example, ZONE_DMA will contain memory that can be used by devices for DMA, ZONE_HIGHMEM will contain memory that is not permanently mapped into kernel\u0026rsquo;s address space and ZONE_NORMAL will contain normally addressed pages. The actual layout of the memory zones is hardware dependent as not all architectures define all zones, and requirements for DMA are different for different platforms.\n简而言之，这段话指出硬件对内存访问有一些限制，例如某些设备无法进行完全的DMA操作，或者物理内存的大小超过了虚拟内存的寻址范围。为了满足不同的需求，Linux将内存划分为不同的区域，如ZONE_DMA、ZONE_HIGHMEM和ZONE_NORMAL，以便设备和内核能够根据需要访问适当的内存区域。具体的内存区域布局与硬件相关，并且根据不同的平台和DMA需求而有所不同。\nNodes Many multi-processor machines are NUMA - Non-Uniform Memory Access - systems. In such systems the memory is arranged into banks that have different access latency depending on the \u0026ldquo;distance\u0026rdquo; from the processor. Each bank is referred to as a node and for each node Linux constructs an independent memory management subsystem. A node has its own set of zones, lists of free and used pages and various statistics counters.\n多核NUMA系统，其中内存被分成了不同的存储区域，每个区域被称为一个节点。对于每个节点，Linux构建了独立的内存管理子系统，包括区Zones集、Page链表（包括已使用和未使用）和统计计数器等。这样的设计可以根据节点之间的距离来调整内存访问的延迟，实现更高效的内存管理。\nPage cache Page cache的存在是为了提高硬件和内存之间的访问速度，利用Page cache 将要读入的或者即将写入文件的内容暂存，写操作较为特殊，将要被写入（在内存中做出了修改，需要更新到辅助存储设备）的页面被标记为dirty，当再次使用该页面时，同步到辅助存储设备中。\nAnonymous Memory The anonymous memory or anonymous mappings represent memory that is not backed by a filesystem. Such mappings are implicitly created for program\u0026rsquo;s stack and heap or by explicit calls to mmap(2) system call. Usually, the anonymous mappings only define virtual memory areas that the program is allowed to access. The read accesses will result in creation of a page table entry that references a special physical page filled with zeroes. When the program performs a write, a regular physical page will be allocated to hold the written data. The page will be marked dirty and if the kernel decides to repurpose it, the dirty page will be swapped out\n匿名内存或匿名映射是指不由文件系统支持的内存。程序的堆栈和堆通常隐式地创建匿名映射，也可以通过调用mmap(2)系统调用来显式创建。匿名映射仅定义了程序可以访问的虚拟内存区域。对于读访问，将使用一个特殊的物理页面来表示零值。而在写操作时，将分配一个普通的物理页面来保存写入的数据，并将其标记为脏页。如果内核决定重新利用该页面，则脏页将被交换出去。\nReclaim Throughout the system lifetime, a physical page can be used for storing different types of data. It can be kernel internal data structures, DMA\u0026rsquo;able buffers for device drivers use, data read from a filesystem, memory allocated by user space processes etc. Depending on the page usage it is treated differently by the Linux memory management. The pages that can be freed at any time, either because they cache the data available elsewhere, for instance, on a hard disk, or because they can be swapped out, again, to the hard disk, are called reclaimable. The most notable categories of the reclaimable pages are page cache and anonymous memory. In most cases, the pages holding internal kernel data and used as DMA buffers cannot be repurposed, and they remain pinned until freed by their user. Such pages are called unreclaimable. However, in certain circumstances, even pages occupied with kernel data structures can be reclaimed. For instance, in-memory caches of filesystem metadata can be re-read from the storage device and therefore it is possible to discard them from the main memory when system is under memory pressure. The process of freeing the reclaimable physical memory pages and repurposing them is called (surprise!) reclaim. Linux can reclaim pages either asynchronously or synchronously, depending on the state of the system. When the system is not loaded, most of the memory is free and allocation requests will be satisfied immediately from the free pages supply. As the load increases, the amount of the free pages goes down and when it reaches a certain threshold (low watermark), an allocation request will awaken the kswapd daemon. It will asynchronously scan memory pages and either just free them if the data they contain is available elsewhere, or evict to the backing storage device (remember those dirty pages?). As memory usage increases even more and reaches another threshold - min watermark - an allocation will trigger direct reclaim. In this case allocation is stalled until enough memory pages are reclaimed to satisfy the request.\n全文翻译： 在系统的整个生命周期中，物理页面可以用于存储不同类型的数据。它可以是内核内部数据结构、设备驱动程序使用的可进行DMA访问的缓冲区、从文件系统读取的数据，或者是由用户空间进程分配的内存等。\n根据页面的使用方式，Linux内存管理会对其进行不同的处理。那些可以随时释放的页面，可能是因为它们缓存了其他位置（例如硬盘）上可用的数据，或者因为它们可以被换出到硬盘上，被称为可回收页面。可回收页面中最重要的两个类别是页面缓存和匿名内存。\n大多数情况下，保存内核内部数据并用作DMA缓冲区的页面无法被重新利用，并且它们将保持固定状态，直到被它们的用户释放。这样的页面被称为不可回收页面。然而，在某些情况下，即使是占用着内核数据结构的页面也可以被回收利用。例如，文件系统元数据的内存缓存可以从存储设备重新读取，因此在系统压力下，可以将其从主内存中丢弃。\n释放可回收物理内存页面并重新利用它们的过程称为回收。Linux可以根据系统的状态异步或同步地回收页面。当系统负载较低时，大部分内存都是空闲的，分配请求将立即从空闲页中满足。随着负载的增加，空闲页的数量减少，当达到一定的阈值（低水位线）时，分配请求将唤醒kswapd守护进程。它会异步扫描内存页面，并根据数据是否可在其他位置获取来决定是仅释放这些页面，还是将其驱逐到后备存储设备（还记得那些脏页吗？）。随着内存使用的进一步增加并达到另一个阈值（最低水位线），分配请求将触发直接回收。在这种情况下，分配将被暂停，直到回收足够的内存页面以满足请求为止。\n总结： 这段话主要解释了Linux内存管理中的页面回收机制。在系统运行过程中，物理页面可以用于存储各种类型的数据，包括内核数据、DMA缓冲区、文件系统数据等。根据页面的使用方式，可以将其分为可回收页面和不可回收页面。 可回收页面包括页面缓存和匿名内存，它们可以在系统需要时被异步地释放或重新利用。当系统负载较低时，大部分内存是空闲的，分配请求可以立即满足。但随着负载增加，空闲页面减少，当达到一定阈值时，会唤醒kswapd守护进程进行异步扫描和释放页面，或将脏页写回到存储设备。当内存使用进一步增加并达到另一个阈值时，会触发直接回收，即暂停内存分配直到回收足够的页面来满足请求。 需要注意的是，一些用于保存内核数据结构和DMA缓冲区的页面是不可回收的，它们会一直保持固定状态，直到它们的用户释放。但在某些情况下，即使是这些页面也可以被回收，例如重新读取文件系统元数据的内存缓存。 总之，这个机制确保了系统在内存紧张的情况下能够回收和重新利用可回收页面，从而更高效地利用内存资源，并及时满足分配请求。\nCompaction As the system runs, tasks allocate and free the memory and it becomes fragmented. Although with virtual memory it is possible to present scattered physical pages as virtually contiguous range, sometimes it is necessary to allocate large physically contiguous memory areas. Such need may arise, for instance, when a device driver requires a large buffer for DMA, or when THP allocates a huge page. Memory compaction addresses the fragmentation issue. This mechanism moves occupied pages from the lower part of a memory zone to free pages in the upper part of the zone. When a compaction scan is finished free pages are grouped together at the beginning of the zone and allocations of large physically contiguous areas become possible. Like reclaim, the compaction may happen asynchronously in the kcompactd daemon or synchronously as a result of a memory allocation request.\n碎片内存的压缩机制来解决需要分配连续物理内存的问题\nOOM Killer 在负载高的机器上，内存有可能会耗尽，内核将无法回收足够的内存以继续运行。为了保护系统的其余部分，内核会触发OOM（Out of Memory）Killer。 OOM杀手选择一个任务来牺牲，以维护整个系统的健康。选择的任务被终止，希望在其退出后释放足够的内存来恢复正常操作。\n","pubDate":"2022-02-19","title":"【Linux Document 01】Memory Manager : Concept"},{"link":"https://cnjslw.github.io/posts/03-%E9%80%9A%E7%94%A8%E6%8C%87%E4%BB%A4/","plain":"直接利用参考文献即可，指令的背后是计算机体系架构\n[1] Do Intel and AMD processor have the same assembler?\n[2] x86-64: Differences_between_AMD64_and_Intel_64\n[3] x86 instruction listings\n","pubDate":"2022-01-24","title":"【x86汇编语言03】通用指令集"},{"link":"https://cnjslw.github.io/posts/02-%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/","plain":"⚠默认基于Nasm汇编器和x86架构下的汇编 , 仅MASM支持会特殊标注\n一、数值编码 无符号整数（Unsigned Integer）：\n使用二进制补码（Binary Unsigned Integer）表示。 所有位都可用于表示数值，没有符号位。 最高位为数值的最高位，没有特殊含义。 能表示的范围：0 到 (2^n - 1)，其中 n 是该整数类型的位数。 有符号整数（Signed Integer）：\n使用二进制补码（Binary Two\u0026rsquo;s Complement）表示。 最高位（最左侧的位）作为符号位，0 表示正数，1 表示负数。 其余位表示数值部分，使用正数的二进制补码表示。 能表示的范围：-(2^(n-1)) 到 (2^(n-1) - 1)，其中 n 是该整数类型的位数。 小数（Floating-point Number）：\n使用浮点表示法，例如IEEE 754标准。 一般分为单精度（32位）和双精度（64位）两种格式。 包括符号位、指数位和尾数位，用于表示带有小数部分的实数。 能表示的范围和精度取决于具体的浮点表示格式。 字符（Character）：\n使用字符编码表来表示，最常见的是ASCII编码或Unicode编码。 通常每个字符占用一个固定大小的字节（如ASCII编码中的一个字节），或者使用多字节表示（如某些Unicode编码）。 每个编码表将字符映射到一个二进制值，以便在计算机中表示。 字符串（String）：\n字符串是由多个字符构成的序列。 在计算机中，字符串通常被表示为字符数组或字符指针，其中每个字符使用字符的表示方式进行存储。 字符串的具体表示方式可以根据编程语言和字符串库的不同而有所区别，但基本原理是相同的。 需要注意的是，每种数据类型在计算机中的具体表示方式可能会因编程语言、编译器、操作系统或硬件平台而有所差异。这些表示方式是通过约定和标准来定义的，以确保数据在计算机内部的正确解释和操作。\n二、变量 1、MASM中的变量 1.1 定义变量 变量名即汇编语句名字部分，是用户自定义的标识符，表示初值表首个数据的逻辑地址。汇编语言使用这个符号表示地址，故有时被称为符号地址。变量名可以没有，这种情况，汇编程序将直接为初值表分配空间，无符号地址。设置变量名是为了方便存取它指示的存储单元。\n1 变量名 变量定义伪指令 初值表 1.1.1 初值表 初值表是用逗号分隔的参数，由各种形式的常量和特殊的符号“?”、“DUP”组成。其中“？”表示初值不确定，即未赋初值。多个存储单元如果初值相同，可以用复制操作符DUP进行说明。\n1 重复次数 dup(重复参数) ; 1.1.2 变量定义伪指令 变量定义伪指令有DB、DW、DD、DF、DQ和DT（NASM和MASM使用了相同的伪指令 , MASM 6.0开始还对应支持BYTE、WORD、DWORD、FWORD、QWORD和TBYTE，两者功能相同），它们根据申请的主存空间单位分类\n除了 DB、DW、DD 等定义的简单变量，汇编语言还支持复杂的数据变量，例如结构（Structure）、记录（Record）、联合（Union）等。\n1.2 变量定位 变量定义的存储空间是按照书写的先后顺序一个接一个分配的。而定位伪指令可以控制其存放的偏移地址。\n1.2.1 ORG伪指令 ORG伪指令将参数表达的偏移地址作为当前偏移地址，格式是：\n1 org 参数 例如，从偏移地址100H处安排数据或程序，可以使用语句：\n1 org 100h 1.2.2 ALIGN与Even伪指令 在汇编语言中，\u0026ldquo;Align\u0026quot;和\u0026quot;Even\u0026quot;是两个常用的伪指令，它们的作用是调整代码或数据的对齐方式。\nAlign（对齐）伪指令：\nAlign伪指令用于将代码或数据对齐到指定的边界。 对齐是指将数据或指令的起始地址设置为特定的边界地址，通常是内存地址的倍数。 对齐可以提高程序执行效率和访问速度，尤其在一些体系结构中，要求某些特定类型的数据必须以特定的对齐方式存储。 使用Align伪指令，程序员可以指定对齐的边界，如字节、字（2字节）、双字（4字节）等。 Even（偶数）伪指令：\nEven伪指令用于将代码或数据的起始地址对齐到偶数地址。 在某些体系结构中，要求32位数据的起始地址必须为偶数，即内存地址的最低位必须为0。 使用Even伪指令，程序员可以确保代码或数据的起始地址为偶数地址，从而满足特定体系结构的要求。 这些对齐伪指令可以在编写汇编代码时使用，以确保数据的正确对齐和访问。对齐方式的选择通常受到特定体系结构或编译器的要求和限制。通过使用Align和Even伪指令，程序员可以以最佳的方式进行数据对齐，以提高代码执行效率和访问速度。\n1.2.3 变量属性 变量定义除分配存储空间和赋初值外，还可以创建变量名。 这个变量名一经定义便具有两类属性： （1）地址属性——指首个变量所在存储单元的逻辑地址，含有段基地址和偏移地址。 （2）类型属性——指变量定义的数据单位，有字节量、字量、双字量、3 字量、4 字量和10字节量，依次用类型名BYTE、WORD、DWORD、FWORD、QWORD和TBYTE表示。\nTYPE返回该类型变量一个数据项所占的字节数，例如对字节、字和双字变量依次返回1、2和4 对变量，还可以用LENGTHOF操作符获知某变量名指向多少个数据项，用SIZEOF操作符获知它共占用多少字节空间，即 SIZEOF 值=TYPE 值×LENGHOF 值\n1 2 3 4 5 6 7 mov ax,word ptr bvar ; mov bx,type bvar ; mov cx,type wvar mov dx,type array mov si,lengthof array mov di,sizeof array mov bp,arr_size 2、NASM中的变量 在NASM中，可以使用%define、equ和resb等指令来创建变量。\n使用 %define 定义符号常量： 1 %define 变量名 值 这种方式创建的变量是一个符号常量，它们在汇编时会被替换为具体的值。例如：\n1 %define SIZE 10 这样就定义了一个名为 SIZE 的变量，它的值为 10。在后续的代码中，可以直接使用 SIZE 来代表 10。\n使用 equ 定义符号常量： 1 变量名 equ 值 这种方式与 %define 类似，也是用于定义符号常量。例如：\n1 SIZE equ 10 这样就定义了一个名为 SIZE 的变量，它的值为 10。在后续的代码中，同样可以直接使用 SIZE 来代表 10。\n使用 resb 分配内存空间： 变量名 resb 长度 这种方式用于在内存中分配一定长度的字节空间，即创建一个字节长度的变量。例如：\n1 array resb 10 这样就创建了一个名为 array 的变量，它占用了 10 个字节的空间。\n除了 resb，NASM还提供了其他类似的分配内存空间的指令，如 resw（分配字）和 resd（分配双字）。可以根据具体需要选择适当的指令。\n三、寻址方式 1、立即寻址 1 2 add bx , 0xf000 ;0xf000 直接给出的数值是立即在指令中给出的,最终参加法运算的就是它,不需要通过其他方式寻址,故称为立即数,也是一种寻址方式,称为立即寻址 mov dx , label_a ;label_a 同上,也会转化为一个立即数 2、寄存器寻址 指令执行时,操作的数位于寄存器中,可以从寄存器里取得\n1 2 3 mov ax , cx add bx , 0xf000 inc dx 3、内存寻址 所谓的内存寻址,就是如何在指令中指定操作数的偏移地址,供处理器访问内存时使用,这个偏移地址就叫做有效地址(EA,Effective Address)\n3.1 直接寻址 1 2 3 mov ax , [0x5c0f] ; ds左移动4位,加上0x5c0f形成20位物理地址,从这个物理地址中取得一个字,保存在ax中 add word [0x0230] , 0x5000 ; xor byte [es:label_b] , 0x50 ; [es:label_b]使用了标号和段超越前缀,但属于直接寻址方式,因为标号是数值的等价形式,在指令编译阶段,会被转换成数值,段超越前缀改变了默认的数据段 3.2 基址寻址 所谓基址寻址,就是先指定一个基准位置,数据的偏移数据(有效地址)取决于它到基准位置的位移或者说距离,要使用基地寻址,需要在指定的地址部分使用基址寄存器BX或者BP来提供一个基准地址(默认情况下, BX默认寄存器DS, BP默认寄存器SS) , 可以在BX和BP的基础上加上位移\n1 2 3 mov [bx] , dx ; DS\u0026lt;\u0026lt;4+BX = EA add byte [bx] ,0x55 ; DS\u0026lt;\u0026lt;4+BX = EA mov ax , [bp-2] ; ; SS\u0026lt;\u0026lt;4+(BP-2) = EA ,常用作访问栈 一个小例子\n1 2 3 4 5 6 7 8 ;将每一个数字+1 buffer dw 0xf0 , 0xff00 , 0x300 mov bx buffer mov cx 3 lpinc: inc word [bx] add bx 2 loop lpinc 3.3 变址寻址 变址寻址类似于基址寻址,唯一不同之处在于这种寻址方式使用的是变址寄存器(或称索引寄存器)SI和DI , 除非使用了段超越前缀,默认使用DS作为段寄存器,同样可以增加位移\n1 2 3 mov [si] dx ; DS\u0026lt;\u0026lt;4+SI = EA add ax [di+0x100] xor word [si] , 0x8000 3.4 基址变址寻址 可以使用一个基址寄存器(BX或者BP) + 变址寄存器(SI和DI) = 基址变址\n1 2 3 mov ax,[bx+si] ;DS\u0026lt;\u0026lt;4+bx+si add word [bx+di] , 0x3000 ; DS\u0026lt;\u0026lt;4+bx+di mov [bx+si+0x100],al ; DS\u0026lt;\u0026lt;4+bx+si+0x100 一个例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 ;反转字符串 string db \u0026#39;abcdefg\u0026#39; mov bx ,string mov si,0 mov di,6 reverse: mov ah,[bx+si] mov al,[bx+di] mov [bx+si],al mov [bx+di],ah ;首尾字符互换 inc si dec di cmp si,di jl order [1] 《汇编语言》王爽\n[2] 《x86汇编语言：从实模式到保护模式（第二版）》李忠、王晓波、余洁\n[3] 《Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1》\n[4] 《汇编语言简明教程》钱晓捷\n[5] 8086CPU中14个寄存器的详解_基址寄存器\n[6] 《NASM中文手册》\n[7] 《MASM61 Pro Guide》\n","pubDate":"2022-01-20","title":"【x86汇编语言02】变量与基本类型"},{"link":"https://cnjslw.github.io/posts/01-8086%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","plain":"一、基础知识 1、指令 机器指令：CPU能直接识别并执行的二进制编码 汇编指令：汇编指令是机器指令的助记符，同机器指令一一对应。 指令：指令通常由操作码和地址码（操作数）两部分组成 指令集：每种CPU都有自己的汇编指令集。 2、汇编语言程序 2.1 汇编语言由3类指令组成 汇编指令 伪指令：没有对应的机器码，由编译器执行，计算机并不执行 其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。 2.2 指令代码格式 指令的代码格式（Instruction Format）说明如何用二进制编码指令，也称机器代码（Machine Code）格式，它由操作码和地址码组成\n指令的操作码（Opcode）表明处理器执行的操作，例如数据传送、加法运算、跳转等操作 操作数（Operand）是参与操作的数据，也就是各种操作的对象，主要以寄存器或存储器地址、I/O 地址形式指明数据的来源，所以也称为地址码 1 2 mov al , [bx+si+6] ;指令功能：AL⬅[BX+SI+6] ;机器代码：8A 40 06 （十六进制表示法） 操作码：\u0026ldquo;8A\u0026rdquo; 操作数：\u0026ldquo;40\u0026rdquo; ,\u0026ldquo;06\u0026rdquo;\n2.3 语句格式 执行性语句——表达处理器指令的语句 1 标号：处理器指令助记符 操作数,操作数 ;注释 说明性语句——表达汇编程序命令的语句 1 名字 伪指令助记符 参数,参数,...... ;注释 2.3.1 标号与名字 执行性语句中，冒号前的标号表示处理器指令在主存中的逻辑地址，主要用于指示分支、循环等程序的目的地址，可有可无 说明性语句中的名字可以是变量名、段名、子程序名等，反映变量、段和子程序等的逻辑地址。 标号采用冒号分隔处理器指令，名字采用空格或制表符分隔伪指令，据此也分别了两种语句。 标号和名字是符合汇编程序语法的用户自定义的标识符（Identifier）。标识符（也称为符号Symbol）一般最多由31个字母、数字及规定的特殊符号（如 _、$、?、@）组成，不能以数字开头 2.3.2 助记符与伪指令 在汇编语言中，助记符（Mnemonic）和伪指令（Pseudoinstruction）是两种不同的概念。 1）助记符（Mnemonic）：助记符是用于表示机器指令的一种简短的助记名称。它是汇编语言中可识别的文本符号，代表着特定的机器指令操作码。例如，\u0026ldquo;MOV\u0026quot;代表将数据从一个位置移动到另一个位置的机器指令。总的来说，助记符直接对应机器指令，而伪指令提供了更高级和方便的功能，用于改善程序结构和编译过程。 助记符（Mnemonics）是帮助记忆指令的符号，反映指令的功能。 [[汇编语言#十五、 指令系统总结|助记符总结]]\n2）伪指令（Pseudoinstruction）：伪指令是在汇编语言中使用的一类特殊指令，其并不直接对应于机器指令，而是由编译器或汇编器根据伪指令的含义来生成一系列真正的机器指令。伪指令通常用于提供汇编程序的组织结构、定义常量、定义变量等。它们更多地是为了方便程序员或者提供编译时的一些辅助功能。\n1 msg db\u0026#39;Hello,asm!\u0026#39;,13,10,\u0026#39;$\u0026#39; 名字 MSG 指示这个字符串在主存的逻辑地址，包含有段基地址和偏移地址，也就是这个字符串的变量名。可以用一个MASM操作符OFFSET获得其偏移地址，保存到DX寄存器，汇编语言执行性语句如下：\n1 mov dx, offset msg ;DX获得MSG的偏移地址 区别：\n助记符表示实际的机器指令，每个助记符对应着特定的操作码。它们直接被处理器执行。 伪指令虽然看起来像指令，但它们并没有直接对应的机器指令。它们是由编译器或汇编器解释并转换成一系列真正的机器指令。 2.3.3 操作数和参数 处理器指令的操作数表示参与操作的对象，可以是一个具体的常量、也可以是保存在寄存器的数据，还可以是一个保存在存储器中的变量等。 双操作数的指令中，目的操作数写在逗号前，还可用来存放指令操作的结果；对应地，逗号后的操作数就称为源操作数。 例如，指令“MOV AH,9”中数字9是常量形式的源操作数，AH是寄存器形式的目的操作数。同样，OFFSET MSG经汇编后转换为一个具体的偏移地址，也是常量。 伪指令的参数可以是常量、变量名、表达式等，可以有多个，参数之间用逗号分隔。例如在“\u0026lsquo;Hello, asm !\u0026rsquo;,13,10, \u0026lsquo;$\u0026rsquo;”示例中，就用单引号表达了一个字符串“Hello, asm !”，一个字符“$”，还有常量13和10（这两个常量在ASCII码表中表示回车和换行控制字符，其作用相当于C语言的“\\n”）。\n2.3.4 注释和分隔符 标号后的冒号、注释前的分号以及操作数间和参数间的逗号都是规定采用的分隔符，其他部分通常采用空格或制表符作为分隔符。多个空格和制表符的作用与一个相同。另外，MASM也支持续行符“\\”，表示本行内容与上一行内容属于同一个语句。\n2.4 编译器 够将汇编指令转换成机器指令的翻译程序每一种CPU都有自己的汇编指令集。\n在内存或磁盘上，指令和数据没有任何区别，都是二进制信息\n3、存储器 随机存储器（RAM）在程序的执行过程中可读可写，必须带电存储\n只读存储器（ROM）在程序的执行过程中只读，关机数据不丢失\n（以上3张图片来自王道考研 - 计算机组成原理课件）\n4、总线 4.1 总线 总线是连接各个部件的信息传输线，是各个部件共享的传输介质。\n主板上有核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相连。这些器件有CPU、存储器、外围芯片组、扩展插槽等。扩展插槽上一般插有RAM内存条和各类接口卡。\n总线根据位置分类：\n片内总线（芯片内部总线）\n系统总线（计算机各部件之间的信息传输线）\n根据传送信息的不同，系统总线从逻辑上又分为3类，地址总线、控制总线和数据总线。\nCPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行以下3类信息的交互。\n地址总线：CPU通过地址总线来指定存储单元\n1根导线可以传送的稳定状态只有两种，高电平或是低电平。用二进制表示就是1或0 图示有10根地址线即一次可以传输10位，访问存储单元地址为1011，寻址范围为0 ~ (210 - 1)\n数据总线：CPU与内存或其他器件之间的数据传送是通过数据总线来进行的\n8根数据线一次可传送一个8位二进制数据（即一个字节），传送2个字节需要两次；16根数据线一次可传送2个字节（内存对齐核心原理）\n控制总线：CPU对外部器件的控制是通过控制总线来进行的。\n有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。\n所以，控制总线的宽度决定了CPU对外部器件的控制能力。\n4.2 CPU对存储器的读写 1、 CPU通过地址线将地址信息3发出。\n2、 CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。\n3、 存储器将3号单元中的数据8通过数据线送入CPU。写操作与读操作的步骤相似。\n联想：在组成原理中用微操作表示：(PC) → MAR; 1 → R; M(MAR) → MDR; …\n4.3 CPU对外设的控制 CPU对外设都不能直接控制，如显示器、音箱、打印机等。\n直接控制这些设备进行工作的是插在扩展插槽上的接口卡。\n扩展插槽通过总线和CPU相连，所以接口卡也通过总线同CPU相连。CPU可以直接控制这些接口卡，从而实现CPU对外设的间接控制。\n如：CPU无法直接控制显示器，但CPU可以直接控制显卡，从而实现对显示器的间接控制\n5、内存地址空间 CPU将系统中各类存储器看作一个逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。\n对于CPU，所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力限制。(或许就是计组中学的统一编址吧)\n每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据（对ROM写无效）。\n二、寄存器 1、寄存器 CPU由运算器、控制器、寄存器等器件构成，这些器件靠片内总线相连。\n运算器进行信息处理；控制器控制各种器件进行工作；寄存器进行信息存储；\n8086CPU有14个寄存器：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW都是16位\n16位结构CPU具有下面几方面的结构特性。\n运算器一次最多可以处理16位的数据； 寄存器的最大宽度为16位； 寄存器和运算器之间的通路为16位。 8086CPU可以一次性处理以下两种尺寸的数据。\n字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中。 字：记为word，一个字由两个字节组成，可以存在一个16位寄存器中(16位CPU)\n8086采用小端模式：高地址存放高位字节，低地址存放低位字节。 2、通用寄存器 通用寄存器：通常用来存放一般性的数据，有AX、BX、CX、DX它们可分为两个可独立使用的8位寄存器，还有SI，DI，BP，SP不能分为高低字节\n在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的\n一个8位寄存器所能存储的数据范围是0 ~ 28-1。\n3、8086CPU给出物理地址的方法 8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。\n8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为16位。\n从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出的寻址能力只有64KB。\n8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。\n当8086CPU要读写内存时：\nCPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址； 地址加法器将两个16位地址合成为一个20位的物理地址； 地址加法器采用物理地址 = 段地址×16 + 偏移地址的方法用段地址和偏移地址合成物理地址。\n例如，8086CPU要访问地址为123C8H的内存单元，1230H左移一位(空出4位)加上00C8H合成123C8H\n4、段寄存器 我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元，可以用分段的方式来管理内存。\n用一个段存放数据，将它定义为“数据段”；\n用一个段存放代码，将它定义为“代码段”；\n用一个段当作栈，将它定义为“栈段”。\n注意：\n一个段的起始地址一定是16的倍数； 偏移地址为16位，变化范围为0-FFFFH，所以一个段的长度最大为64KB。 CPU可以用不同的段地址和偏移地址形成同一个物理地址。 段寄存器：8086CPU有4个段寄存器：CS、DS、SS、ES，提供内存单元的段地址。\n4.1 CS和IP CS为代码段寄存器，IP为指令指针寄存器，\nCPU将CS、IP中的内容当作指令的段地址和偏移地址,用它们合成指令的物理地址,\nCPU将CS:IP指向的内容当作指令执行。(即PC)\n8086CPU的工作过程简要描述\n从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器； IP=IP+所读取指令的长度，从而指向下一条指令； 执行指令。转到步骤1，重复这个过程。 在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。\n8086CPU提供转移指令修改CS、IP的内容。\njmp 段地址:偏移地址：用指令中给出的段地址修改CS，偏移地址修改IP。如：jmp 2AE3:3\njmp 某一合法寄存器：仅修改IP的内容。如：jmp ax。在含义上好似：mov IP，ax\n8086CPU不支持将数据直接送入段寄存器的操作，这属于8086CPU硬件设计\n4.2 DS 和 [address] DS寄存器：通常用来存放要访问数据的段地址\n[address]表示一个偏移地址为address的内存单元，段地址默认放在ds中\n通过数据段段地址和偏移地址即可定位内存单元。\nmov bx, 1000H ;8086CPU不支持将数据直接送入段寄存器的操作 mov ds, bx ;ds存放数据段地址 mov [0], al ;将al数据（1字节）存到1000H段的0偏移地址处，即10000H mov ax, [2] ;将数据段偏移地址2处的一个字（8086为2字节）存放到ax寄存器 add cx, [4] ;将偏移地址4处的一个字数据加上cx寄存器数据放到cx寄存器 sub dx, [6] ;dx寄存器数据减去数据段偏移地址6处的字数据存到dx 4.3 SS 和 SP 在基于8086CPU编程的时候，可以将一段内存当作栈来使用。\n栈段寄存器SS，存放段地址，SP寄存器存放偏移地址，任意时刻，SS:SP指向栈顶元素\n8086CPU中，入栈时，栈顶从高地址向低地址方向增长。\npush ax表示将寄存器ax中的数据送入栈中，由两步完成。\nSP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶； 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。\npop ax表示从栈顶取出数据送入ax，由以下两步完成。\n将SS:SP指向的内存单元处的数据送入ax中； SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。 实验\n将10000H~1000FH这段空间当作栈，初始状态栈是空的； 设置AX=001AH，BX=001BH； 将AX、BX中的数据入栈； 然后将AX、BX清零； 从栈中恢复AX、BX原来的内容。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 mov ax, 1000H mov ss, ax mov sp, 0010H ;初始化栈顶 mov ax, 001AH mov bx, 001BH push ax push bx ;ax、bx入栈 sub ax, ax ;将ax清零，也可以用mov ax，0， ;sub ax，ax的机器码为2个字节， ;mov ax，0的机器码为3个字节。 sub bx, bx pop bx ;从栈中恢复ax、bx原来的数据 pop ax ; [1] 《汇编语言》王爽\n[2] 《x86汇编语言：从实模式到保护模式（第二版）》李忠、王晓波、余洁\n[3] 《Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1》\n[4] 《汇编语言简明教程》钱晓捷\n[5] 8086CPU中14个寄存器的详解_基址寄存器\n","pubDate":"2022-01-13","title":"【x86汇编语言01】 8086体系结构与汇编基础"},{"link":"https://cnjslw.github.io/posts/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","plain":"整数类型 浮点数类型 字符和字符串 地址、指针和引用 常量 变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int c = 10; void func(int a ) { int b = ++a; c++; } int main() { { int b = 100; func(b); c--; } { int b = 200; func(b); c+=3; } return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 c: .long 10 # 定义一个变量c为10，.long是定义长整型变量的指令 func(int): push ebp # 将ebp寄存器的值保存到栈中 mov ebp, esp # 将esp寄存器的值赋给ebp，相当于保存了当前函数的栈指针 sub esp, 16 # 在栈上为局部变量和函数参数分配16字节的空间，esp寄存器指向新的栈顶位置 add DWORD PTR [ebp+8], 1 # 取出调用函数时压入栈中的第一个参数，并将其加1 mov eax, DWORD PTR [ebp+8] # 将参数赋值给eax寄存器 mov DWORD PTR [ebp-4], eax # 将eax的值传递给局部变量[ebp-4] mov eax, DWORD PTR c # 将变量c的值赋给eax寄存器 add eax, 1 # 将eax的值加1 mov DWORD PTR c, eax # 将eax的值赋给变量c nop # 空指令 leave # 恢复栈指针 ret # 返回函数结果 main: push ebp # 将ebp寄存器的值保存到栈中 mov ebp, esp # 将esp寄存器的值赋给ebp，相当于保存了当前函数的栈指针 sub esp, 16 # 在栈上为局部变量和函数参数分配16字节的空间，esp寄存器指向新的栈顶位置 mov DWORD PTR [ebp-4], 100 # 将100赋值给局部变量[ebp-4] push DWORD PTR [ebp-4] # 将[ebp-4]的值压入栈中，作为函数调用的参数 call func(int) # 调用函数func add esp, 4 # 释放栈空间 mov eax, DWORD PTR c # 将变量c的值赋给eax寄存器 sub eax, 1 # 将eax的值减1 mov DWORD PTR c, eax # 将eax的值赋给变量c mov DWORD PTR [ebp-8], 200 # 将200赋值给局部变量[ebp-8] push DWORD PTR [ebp-8] # 将[ebp-8]的值压入栈中，作为函数调用的参数 call func(int) # 调用函数func add esp, 4 # 释放栈空间 mov eax, DWORD PTR c # 将变量c的值赋给eax寄存器 add eax, 3 # 将eax的值加3 mov DWORD PTR c, eax # 将eax的值赋给变量c mov eax, 0 # 将eax寄存器清零 leave # 恢复栈指针 ret # 返回函数结果 ","pubDate":"2021-11-01","title":"【从汇编的视角重学C++ 01】基本数据类型的表现形式"},{"link":"https://cnjslw.github.io/posts/%E5%A4%9A%E6%80%81/","plain":"OOP的核心思想是多态性（polymorphism）（动态绑定是多态性得以实现的重要因素）\n一、静态类型和动态类型 动态类型: 变量或表达式表示的内存中的对象类型，直到运行时才可见 静态类型: 变量申明的类型或表达式生成的类型，在编译时就已知 可以将基类的指针或引用绑定到派生类对象上。 如果不是指针也不是引用，则它的动态类型和静态类型永远保持一致 不存在从基类向派生类的隐式类型转换。 派生类向基类的自动类型转换只对指针或引用类型有效，对象之间不存在类型转换。对象之间的转换会导致某些对象被切掉(sliced down)。所谓的切掉，就是当派生类和基类之间通过拷贝构造，赋值构造等进行转化时，有一些成员会因为数据成员的不同导致成员丢失，有点像被切掉了。 二、虚函数与动态绑定 1、如何实现多态 基类通过在其成员函数的声明语句前加上关键字virtual使得该函数执行动态绑定。 任何非静态函数都可以是虚函数。关键字virtual只能出现在内内部的声明语句之前，而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式的也是虚函数。如果成员函数没有被声明为虚函数，则解析过程发生在编译时而非运行时。\n当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。\n派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上virtual关键字，也可以不加。 派生类函数如果覆盖了某个继承而来的虚函数, 它的形参必须与被它覆盖的基类函数完全一致,返回类型必须与基类函数匹配，除非返回类本身的指针或引用时，不要求一致，但是要求要求两个类 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。之间可以进行类型转化 2、override和final关键字 C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个override关键字。 如果我们想覆盖某个虚函数，但不小心把形参列表弄错了，这个时候就不会覆盖基类中的虚函数。加上override可以明确程序员的意图，让编译器帮忙确认参数列表是否出错。（在派生类中申明一个除了参数列表之外与基类中虚函数一致的函数是合法，但是不要这样做，为了防止不是刻意构造这样的函数，而是写错了，设置了override关键字） 如果某个函数被指定为final，则之后的任何尝试覆盖函数的操作都将引发错误 3、禁止动态绑定 在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符（::）可以实现。\n1 double undiscounted = baseP-\u0026gt;Quote::net_price(42); 三、多态实例 编译产生的代码将在运行时确定使用虚函数的哪个版本，判断的依据是该指针所绑定对象的真实类型即动态类型。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Base{ public: virtual itn fcn(); }; class D1:public Base{ public: int fcn(int); virtual void f2(); }; class D2:public D1{ int fcn(int); int fcn(); void f2(); } Base bobj ; D1 dlobj ; D2 d1obj; Base *bpl = \u0026amp;bobj, *bp2 = \u0026amp;dlobj, *bp3 = \u0026amp;d2obj; bpl-\u0026gt;fcn (); bp2-\u0026gt;fcn (); bp3-\u0026gt;fcn (); D1 *dlp = \u0026amp;dlobj; D2 *d2p = \u0026amp;d2obj; bp2-\u0026gt;f2();\tdlp-\u0026gt;f2() ;\td2p-\u0026gt;f2() ;\t四、抽象基类 纯虚函数（pure virtual）：清晰地告诉用户当前的函数是没有实际意义的。纯虚函数无需定义，只用在函数体的位置前书写=0就可以将一个虚函数说明为纯虚函数。 含有纯虚函数的类是抽象基类（abstract base class）。不能创建抽象基类的对象。 五、广义的多态 1.重载多态（编译期间） 1.1 函数重载 1.2 运算符重载 2.子类型重载（运行期间） 2.1 虚函数 见上面内容\n3.参数多态性（编译器） 3.1 类模板 3.2 函数模板 4.强制多态（编译期间、运行期） 4.1 基本类型转换 4.2 自定义类型转换 ","pubDate":"2021-10-27","title":"【C++ Primer(edition 5) 15】多态"},{"link":"https://cnjslw.github.io/posts/%E7%BB%A7%E6%89%BF/","plain":"一、概述 面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和多态。\n继承（inheritance）：\n通过继承联系在一起的类构成一种层次关系。 通常在层次关系的根部有一个基类（base class）。 其他类直接或者简介从基类继承而来，这些继承得到的类成为派生类（derived class）。 基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。 对于某些函数，基类希望它的派生类自定义适合自己的版本，此时基类就将这些函数声明成虚函数（virtual function）。 派生类必须通过使用类派生列表（class derivation list）明确指出它是从哪个基类继承而来。形式：一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前都可以有访问说明符。class Bulk_quote : public Quote{}; 派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上virtual关键字，也可以不加。C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个override关键字。 继承是一种强大的属性重用方式，是通向多态的跳板 动态绑定（dynamic binding，又称运行时绑定）：\n使用同一段代码可以分别处理基类和派生类的对象。 函数的运行版本由实参决定，即在运行时选择函数的版本。 二、定义继承 1 2 3 4 5 6 7 class Base{ ...... }; class Derived:access-specifier Base{ ....... }; 派生类必须通过类派生列表（class derivation list）明确指出它是从哪个基类继承而来。形式：冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有一下三种访问说明符的一个：public、protected、private。\n派生类中的虚函数: C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个override关键字。\n静态成员：如果基类定义了一个基类成员，则在整个继承体系中只存在该成员的唯一定义。\n派生类的声明：声明中不包含它的派生列表。\n如果使用某个类作为基类, 则该类必须定义而非申明\n派生类使用基类的成员：派生类可以访问基类的共有成员和受保护成员\nC++11新标准提供一种防止继承的方法，在类名后面跟一个关键字final。\n三、基类和派生类之间细节 1、类型转换与继承 1.1 基于指针和引用对象的类型转换 理解基类和派生类之间的类型抓换是理解C++语言面向对象编程的关键所在。 派生类对象及派生类向基类的类型转换：因为在派生类对象中含有与其基类对应的组成部分，所以能把派生类的对象当成基类对象来使用，而且也能将基类的指针或引用绑定到派生类对象中的基类部分上。\n1 2 3 4 5 Quote item; //基类 Bulk_quote bulk; //派生类 Quote *p = \u0026amp;item; p = \u0026amp;bulk; Quote \u0026amp;r = bulk; 可以将基类的指针或引用绑定到派生类对象上有一层极为至要的含义：当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。\n1.2 强制类型转换带来的sliced down问题 对象之间的转换会导致某些对象被切掉(sliced down)。所谓的切掉，就是当派生类和基类之间通过拷贝构造，赋值构造等进行转化时，有一些成员会因为数据成员的不同导致成员丢失，有点像被切掉了。\n2、派生类的实例化 2.1 合成构造函数、赋值函数、析构函数、拷贝控制函数 基类或派生类的合成拷贝控制成员的行为和其他合成的构造函数、赋值运算符或析构函数类似：他们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。合成析构函数也有同样的规则。无论基类成员是合成的版本还是自定义的版本都没有影响，唯一的要求就是相应的成员可以访问并且未被删除。[[继承#五、访问控制与继承|访问控制与继承]] 如果就是不能访问或者被删除 如果基类的默认拷贝构造、构造、拷贝赋值或析构函数是被删除的，则对应的派生类成员也是被删除的。 如果基类有一个不可访问或者删除掉的析构函数，则派生类的默认和拷贝构造函数将被删除 因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们需要执行移动操作时首先应该在基类中进行定义 派生类析构函数：派生类析构函数先执行，然后执行基类的析构函数。析构函数只负责销毁派生类自己分配的资源。 2.2 初始化之-构造函数 派生类构造函数：派生类必须使用基类的构造函数去初始化它的基类部分。 C++11新标准中，派生类可以重用其直接基类定义的构造函数。 如果在初始化派生类对象，可以通过初始化列表给基类传递参数，从而调用基类的重载构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Base public: Base(int SomeNumber) // overloaded constructor { // Do something with SomeNumber } }； Class Derived: public Base { public: Derived(): Base(25) // instantiate class Base with argument 25 { // derived class constructor code } ｝； 如果基类的构造函数含有默认实参，这些实参并不会被继承，相反会获得多个继承的构造函数，每个构造函数分别省略掉一个含有默认实参的形参。 2.3 初始化之-拷贝构造函数 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。通常使用对应的基类构造函数初始化对象的基类部分，不同于构造函数默认使用基类的默认构造函数，当使用拷贝控制成员和移动控制成员时，需要显式的调用基类的相应成员函数\n1 2 3 4 5 6 7 8 9 10 11 class Base ( /* ... */ }; class D: public Base ( public: //默认情况下，基类的默认构造函数初始化对象的基类部分 //要想使用拷贝或移动构造函数，我们必须在构造函数初始依列表中 //显式地调用该构造函数 D(const D\u0026amp; d):Base(d)\t// 拷贝基类成员 /* D的成员的初始依*/ { /* ... */ } D(D\u0026amp;\u0026amp; d):Base (std: :move (d))\t// 移动基类成员 /* D的成员的初始值*/ { /* ... */ ) )； 2.4 初始化之-赋值函数 赋值运算符也是相似的情况 1 2 3 4 5 D \u0026amp;D::operator=(const D \u0026amp;rhs) { Base::operator= (rhs); // 为基类部分赋值 //按照过去的方式为派生类的成员赋值 //的情处理自赋值及释放已有资源等情况 return *this; 先调用基类的赋值运算符，然后再完成派生类的赋值操作，无论基类的赋值运算符是由编译器合成的还是自定义的都无关紧要\n2.5 初始之-拷贝赋值运算符 2.6 初始化之-析构函数 基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。 如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。 虚析构函数将阻止合成移动操作。 2.7 构造与析构顺序 构造顺序，先基类后派生 析构顺序，先派生后基类\n四、继承中的类作用域 1、如何查找类中的名字 每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。 在编译时进行名字查找 : 一个对象引用或指针的静态类型决定了该对象的哪些成员是可见的，即使与动态类型可能不一致，但是我们能够使用哪些成员仍然是由静态类型决定的。 派生类的成员将隐藏同名的基类成员。也可以通过作用域运算符来使用隐藏的成员。 2、覆盖基类中的成员 声明在内层作用域的函数，并不会存在申明在外层作用域的函数, 因此定义派生类中的函数不会重载基类中的成员，会隐藏基类中的成员。除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。 3、使用基类中的成员 使用域解析运算符:: 来调用基类的方法也可以抑制[[继承#三、虚函数与动态绑定|动态绑定]]\n1 2 3 4 5 6 7 8 9 10 11 12 class Carp:public Fish { public: Carp():Fish(true){} void Swim() { cout\u0026lt;\u0026lt;\u0026#34;Carp swims real slow\u0026#34;\u0026lt;\u0026lt;endl; Fish::Swim(); } } 覆盖重载的函数 : 和其他函数一样，成员函数无论是否是虚函数都能被重载。派生类可以覆盖重载函数的0个或多个实例。有时一个类仅需要覆盖重载集合中的一些而非全部函数一种好的解决方案，就是为重载的成员提供一条using声明语句，这样我们就可以无需覆盖基类中的每一个重载版本。 如using Disc_quote::Disc_quote;，注明了要继承Disc_quote的构造函数。如果派生类有自己的数据成员，则这些成员将被默认初始化。 using申明不会改变构造函数的访问级别 大多数情况下使用using后,派生类会继承所有基类的构造函数，但是有两种例外，一是派生类可以继承一部分构造函数，而定义自己的版本，如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。二是默认拷贝和移动构造函数不会被继承。 五 、访问控制与继承 1、对于公有继承（public)方式 基类的public和protected成员的访问属性在派生类中保持不变，但基类的private成员不可直接派生类中访问（可通过调用基类中访问属性为公有或保护的成员函数来访问基类中的私有成员）。即派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。 基类成员对基类对象的可见性为：公有成员可见（或者说可访问），保护成员和私有成员不可见（或者说不可访问）。 基类成员对派生类的可见性为：基类的公有成员和保护成员可见，基类的私有成员不可见。 基类成员对派生类对象的可见性为：基类的公有成员可见，保护成员和私有成员不可见，即通过派生类的对象只能访问基类的public成员。 所以，在公有继承时，派生类的对象可以直接访问基类中的公有成员，派生类的成员函数可以直接访问基类中的公有成员和保护成员。\n2、对于私有继承(private)方式 基类的public和protected成员都以private身份出现在派生类中，但基类的private成员同样是不可直接访问的。 基类成员对基类对象的可见性为：公有成员可见，保护成员和私有成员不可见。 基类成员对派生类的可见性为：基类的公有成员和保护成员可见，基类的私有成员不可见。（经过私有继承之后，所有基类的成员都成为了派生类的私有成员或不可直接访问的成员，如果用此派生类进一步向下派生子类的话，基类的全部成员就无法在这个派生类的子类中被直接访问） 基类成员对派生类对象的可见性为：基类的公有成员、保护成员和私有成员均是不可见的，即通过通过派生类的对象不能直接访问基类中的任何成员。 所以，在私有继承时，派生类的对象无法直接访问基类中的任何成员，派生类的成员函数则依然可以直接访问基类中的公有成员和保护成员。另外，基类的公有和保护成员只能由直接派生类继承，而无法再向下继承。\n3、对于保护继承（protected）方式 基类的public和protected成员都以protected身份出现在派生类中，基类的private成员也同样是不可直接访问的。 基类成员对基类对象的可见性为：公有成员可见，保护成员和私有成员不可见。 基类成员对派生类的可见性为：基类的公有成员和保护成员可见，基类的私有成员不可见。（比较私有继承和保护继承可以看出，实际上在直接派生类中，所有成员的访问属性都是完全相同的。但是，如果派生类作为新的基类继续派生时，二者的区别就出现了。） 基类成员对派生类对象的可见性为：基类的公有成员、保护成员和私有成员均是不可见的，即通过通过派生类的对象不能直接访问基类中的任何成员。 因此，保护继承既与私有继承有相似的地方也有与公有继承相似的地方。对派生类的对象来说，它与私有继承方式的性质相同。而对于其派生类来说，它又与公有继承方式的性质相同。这样做既实现了数据隐藏，又方便继承，实现代码重用。 ![[Pasted image 20230119014703.png]]\n1 2 3 4 5 6 7 8 class Parent{ public: ... private: ... protected: ... }; 2. 派生类的继承方式说明符 class Child : public Parent {}; class Child : protected Parent {}; class Child : private Parent {}; public 继承方式： 基类中的 public 成员在派生类中仍为 public； 基类中的 protected 成员在派生类中仍为 protected； 基类中的 private 成员在派生类中被继承下来，但是不可访问； protected 继承方式： 基类中的 public 成员在派生类中变为 protected 属性； 基类中的 protected 成员在派生类中变为 protected 属性； 基类中的 private 成员在派生类中被继承下来，但是仍不可访问； private 继承方式： 基类中的 public 成员在派生类中变为 private 属性； 基类中的 protected 成员在派生类中变为 private 属性； 基类中的 private 成员在派生类中被继承下来，但是仍不可访问； 可以看出，三种继承方式不会影响派生类成员对基类成员的访问权限，无论哪种继承方式，派生类中仍然只能访问基类中的 public 和 protected 成员，不能访问 private 成员；\n基类的 private 成员不能在派生类中使用，并没有说基类的 private 成员不能被继承。实际上，基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。private 成员的这种特性，能够很好的对派生类隐藏基类的实现，以体现面向对象的封装性。 继承方式影响的是 类实例对象对类成员的访问权限： 例如，如果派生类的继承方式是 private，则基类对象可以访问的 public 属性的类成员，派生类对象便不能访问了，因为派生类中该对象变成了 private 属性； 由于 private 和 protected 继承方式会改变基类成员在派生类中的访问权限，导致继承关系复杂，所以实际开发中我们一般使用 public。 总结：继承方式决定了基类成员在派生类中的可见性，但不影响派生类对基类成员的访问权限\n3. 改变访问权限 使用 using 关键字可以改变基类成员在派生类中的访问权限，例如将 public 改为 private、将 protected 改为 public。\n注意：using 只能改变基类中 public 和 protected 成员的访问权限，不能改变 private 成员的访问权限，因为基类中 private 成员在派生类中是不可见的，根本不能使用，所以基类中的 private 成员在派生类中无论如何都不能访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include\u0026lt;iostream\u0026gt; using namespace std; //基类People class People { public: void show(); protected: char *m_name; int m_age; }; void People::show() { cout \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;的年龄是\u0026#34; \u0026lt;\u0026lt; m_age \u0026lt;\u0026lt; endl; } //派生类Student class Student : public People { public: void learning(); public: using People::m_name; //将protected改为public using People::m_age; //将protected改为public float m_score; private: using People::show; //将public改为private }; void Student::learning() { cout \u0026lt;\u0026lt; \u0026#34;我是\u0026#34; \u0026lt;\u0026lt; m_name \u0026lt;\u0026lt; \u0026#34;，今年\u0026#34; \u0026lt;\u0026lt; m_age \u0026lt;\u0026lt; \u0026#34;岁，这次考了\u0026#34; \u0026lt;\u0026lt; m_score \u0026lt;\u0026lt; \u0026#34;分！\u0026#34; \u0026lt;\u0026lt; endl; } int main() { Student stu; stu.m_name = \u0026#34;小明\u0026#34;; stu.m_age = 16; stu.m_score = 99.5f; stu.show(); //compile error stu.learning(); return 0; } Student 类中，show 函数被改为了 private 权限，则 Student 类的对象就不能调用 show 函数了。 六、多继承 ","pubDate":"2021-10-22","title":"【C++ Primer(edition 5) 14】继承"},{"link":"https://cnjslw.github.io/posts/%E6%93%8D%E4%BD%9C%E9%87%8D%E8%BD%BD%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","plain":"一、基本概念 1、定义重载运算符 1 return_type operator operator_symbol(...parameter list...); 重载运算符是具有特殊名字的函数：由关键字operator和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 当一个重载的运算符是成员函数时，this绑定到左侧运算对象。动态运算符符函数的参数数量比运算对象的数量少一个。 只能重载大多数的运算符，而不能发明新的运算符号。 重载运算符的优先级和结合律跟对应的内置运算符保持一致。 2、调用重载运算符 方式一 将运算符作用于类型正确的实参，从而以这种间接方式“调用”重 载的运算符函数\n1 data1 + data2; 方式二 调用普通函数一样直接调用运算符函数，先指定函数名字，然后传入数量正确、类型适当的实参\n1 operator+(data1, data2); 3、哪些运算符不可以重载，那些不建议重载 ![[Pasted image 20230122101348.png]]\n某些运算符指定了运算对象求值的顺序 因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。 特别是，逻辑与运算符、逻辑或运算符和逗号运算符的运算对象求值顺序规则无法保留下来。除此之外，\u0026amp;\u0026amp;和 ||运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值。 因为上述运算符的重载版本无法保留求值顺序和/或短路求值属性，因此不建议重载它们,因为用起来会发现求值规则不再适用\n还有一个原因使得我们一般不重载逗号运算符和取地址运算符：C++语言已经定义了这两种运算符用于类类型对象时的特殊含义，这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义，所以一般来说它们不应该被重载，否则它们的行为将异于常态，从而导致类的用户无法适应。\n4、运算符作为成员函数和非成员函数的问题 有时别无选择，必须作为成员函数，而有些时候作为普通函数更好。 如何做出选择呢，有以下的依据：\n赋值（=）、下标（[]）、调用（()）和成员访问箭头（-\u0026gt;）运算符必须是成员。 复合赋值运算符一般来说是成员。 改变对象状态的运算符或者和给定类型密切相关的运算符通常是成员，如递增、解引用。 具有对称性的运算符如算术、相等性、关系和位运算符等，通常是非成员函数。 输出运算符\u0026lt;\u0026lt;必须是非成员函数 含有类对象的混合类型的表达式中使用对称性运算符，运算符必须定义成非成员函数 1 2 3 4 5 6 //如果 “+”是string类的成员 string s = \u0026#34;world\u0026#34;; string t = s + \u0026#34;!\u0026#34;; //√ s.operator + (\u0026#34;!\u0026#34;) string u = \u0026#34;hi\u0026#34; + s; //× \u0026#34;hi\u0026#34;.operator + (s) //如果“+”是非常成员函数 //“hi”+s 等价于 operator+(\u0026#34;hi\u0026#34;,s); 每个实参都能够转换为string类型 二、输入和输出运算符 1、重载输出运算符\u0026laquo; 第一个形参通常是一个非常量的ostream对象的引用。非常量是因为向流中写入会改变其状态；而引用是因为我们无法复制一个ostream对象。 第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复制实参，同时不会改变该形参。 输入输出运算符必须是非成员函数。 1 2 3 4 5 ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os , const Sales_data \u0026amp;item) { os \u0026lt;\u0026lt; item.isbn()\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;item.units_sold\u0026lt;\u0026lt;\u0026#34; \u0026#34;; return os; } 2、重载输入运算符\u0026raquo; 第一个形参通常是运算符将要读取的流的引用，第二个形参是将要读取到的（非常量）对象的引用。 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。 1 2 3 4 5 6 7 8 9 10 11 istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;is, Sales_data \u0026amp;item) { double price;//不需要初始化，因为我们将先读入数据到price,之后才使用它 is\u0026gt;\u0026gt;item.bookNo\u0026gt;\u0026gt;item.units_sold\u0026gt;\u0026gt;price; if(is) //检查输入是否成功 item.revenue = item.units_sold*price; else item = Sales_data(); //输入失败：对象被赋予默认的状态 return is; } 三、算术和关系运算符（+、-、*、/ , ==、!=、\u0026hellip;\u0026hellip;） 如果类同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算数运算符。\n1 2 3 4 5 6 7 //假设两个对象指向同一本书 Sales_data operator+(const Sales_data \u0026amp;lhs, const Sales_data \u0026amp;rhs) { Sales_data sum = lhs; // 把lhs的数据成员拷贝给sum sum += rhs;// 将 rhs 加至sum中 return sum; } 1、相等运算符== 如果定义了operator==，则这个类也应该定义operator!=。 相等运算符和不等运算符的一个应该把工作委托给另一个。 相等运算符应该具有传递性。 如果某个类在逻辑上有相等性的含义，则该类应该定义operator==，这样做可以使用户更容易使用标准库算法来处理这个类。 1 2 3 4 5 6 7 8 bool operator==(const Sales_data \u0026amp;lhs, const Sales_data \u0026amp;rhs) { return lhs.isbn() == rhs.isbn() \u0026amp;\u0026amp; lhs.units_sold == rhs.units_sold \u0026amp;\u0026amp; lhs.revenue == rhs.revenue; } bool operator!=(const Sales_data \u0026amp;lhs, const Sales_data \u0026amp;rhs) { return !(lhs == rhs); } 2、关系运算符 如果存在唯一一种逻辑可靠的\u0026lt;定义，则应该考虑为这个类定义\u0026lt;运算符。如果同时还包含==，则当且晋档\u0026lt;的定义和++产生的结果一直时才定义\u0026lt;运算符。\n四、赋值运算符= 我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。 赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这么做。这两类运算符都应该返回左侧运算对象的引用。 1 2 3 4 5 6 Sales_data\u0026amp; Sales_data::operator+=(const Sales_data \u0026amp;rhs) ( units_sold += rhs.units_sold; revenue += rhs.revenue; return *this; } 五、下标运算符[] 下标运算符必须是成员函数。 一般会定义两个版本： 1.返回普通引用。 2.类的常量成员，并返回常量引用。 1 2 3 4 5 6 7 8 9 10 11 12 13 class StrVec { public: std::strings operator[](std::size_t n) { return elements[n]; } const std::strings operator[](std::size_t n) const { return elements[n]; } private: std::string *elements; //指向数组首元素的指针 }； 六、递增和递减运算符（++、\u0026ndash;） 定义递增和递减运算符的类应该同时定义前置版本和后置版本，后置版本接受一个额外的(不被使用)int类型的形参以形成重载函数。 通常应该被定义成类的成员。 为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。 同样为了和内置版本保持一致，后置运算符应该返回递增或递减前对象的值，而不是引用。 后置版本接受一个额外的，不被使用的int类型的形参。因为不会用到，所以无需命名。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 //前置版本 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026amp; operator++() ; // 前置运算符 StrBlobPtr\u0026amp; operator--() ; //其他成员和之前的版本一致 }; StrBlobPtr\u0026amp; StrBlobPtr::operator++() { // 如果curr已经指向了容器的尾后位置，则无法递增它 check(curr, \u0026#34;increment past end of StrBlobPtr*\u0026#39;); ++curr; //将 curr在当前状态下向前移动一个元素 return *this; } //后置版本 class StrBlobPtr { public: //递增和递减运算符 StrBlobPtr\u0026amp; operator++(int) ; // 后置运算符 StrBlobPtr\u0026amp; operator--(int) ; //其他成员和之前的版本一致 }; StrBlobPtr StrBlobPtr::operator++(int) { //此处无须检查有效性，调用前置递增运算时才需要检查 StrBlobPtr ret = *this; // 记录当前的值 ++*this; //向前移动一个元素，前置++需要检查递增的有效性 return ret; //返回之前记录的状态 } StrBlobPtr StrBlobPtr::operator--(int) { //此处无须检查有效性，调用前置递减运算时才需要检查 StrBlobPtr ret = *this; //记录当前的值 --*this; / / 向后移动一个元素，前置--需要检查递减的有效性 return ret; / / 返回之前记录的状态 } 七、成员访问运算符（*、-\u0026gt;） 箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。 解引用和乘法的区别是一个是一元运算符，一个是二元运算符。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class StrBlobPtr { public: std::strings operator*() const { auto p = check(curr, \u0026#34;dereference past end\u0026#34;); return (*p) [curr] ; // (*p)是对象所指的 vector } std::string* operator-\u0026gt; () const { //将实际工作委托给解引用运算符 return \u0026amp; this-\u0026gt;operator*(); } //其他成员与之前的版本一致 } 八、函数调用运算符 如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象\n可以像使用函数一样，调用该类的对象。因为这样对待类同时也能存储状态，所以与普通函数相比更加灵活。 函数调用运算符必须是成员函数。 一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。 如果累定义了调用运算符，则该类的对象称作函数对象。 1 2 3 4 5 6 7 8 9 struct abslnt { int operator()(int val) const {return val \u0026lt; 0 ? -val : val} }; int i = -42; abslnt absObj; int ui = absObj(i); 1、lambda是函数对象 lambda捕获变量：lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数。 2、标准库定义的函数对象 标准库函数对象 标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。例如，plus类定义了一个函数调用运算符用于对一 对运算对象执行+的操作；modulus类定义了一个调用运算符执行二元的号操作； equal_to类执行== , 等等。 这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，这里的类型即调 用运算符的形参类型。例如，plus\u0026lt;string\u0026gt;令 string加法运算符作用于string对象； plus\u0026lt;int\u0026gt;的运算对象是 int； plus\u0026lt;Sales_data\u0026gt;对 Sales_data 对象执行加 法运算，以此类推\n1 2 3 4 5 6 7 8 plus\u0026lt;int\u0026gt; intAdd; //可执行int加法的函数对 negate\u0026lt;int\u0026gt; intNegate; //可对int值取反的函数对象 // intAdd::operator (int, int)求 10 和 20 的和 int sum = intAdd (10, 20) ; // 等价于 sum = 30 sum = intNegate (intAdd (10, 20) ) ; // 等价于 sum = 30 // 使用 intNegate: :operator (int) // 然后将-10作为 intAdd::operator (int, int)的第二个参数 sum = intAdd(10, intNegate(10)); // sum = 0 算术 关系 逻辑 plus\u0026lt;Type\u0026gt; equal_to\u0026lt;Type\u0026gt; logical_and\u0026lt;Type\u0026gt; minus\u0026lt;Type\u0026gt; not_equal_to\u0026lt;Type\u0026gt; logical_or\u0026lt;Type\u0026gt; multiplies\u0026lt;Type\u0026gt; greater\u0026lt;Type\u0026gt; logical_not\u0026lt;Type\u0026gt; divides\u0026lt;Type\u0026gt; greater_equal\u0026lt;Type\u0026gt; modulus\u0026lt;Type\u0026gt; less\u0026lt;Type\u0026gt; negate\u0026lt;Type\u0026gt; less_equal\u0026lt;Type\u0026gt; 3、可调用对象与function C++语言中有几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。\n调用对象本身也是有类型的\n1 2 3 4 5 6 7 8 9 10 11 //普通函数类型 int add(int i , int j); //未命名的函数对象类 auto mod = [](int i, int j){return i%j;}; //函数对象类 struct divide{ int operator()(int denominator , int divisor) { return denominator / divisor ; } } 想象一种场景，我们要设计一个计算，希望通过用户键入的符号来判断进行那种函数，可以用map来实现这样的函数表，细看上述的三个函数，似乎都是返回值为int，需要两个参数的函数形式int (int , int) 故可以声明函数表：map\u0026lt;string , int(*)(int , int)\u0026gt; 但是,这样就有一个问题，因为调用对象本身也有类型，而int (*)(int , int)的类型是一个函数指针，不能指向函数类类型，所以不能将mod和divide类传入\n为了解决这个问题，我们可以使用function标准库来解决这个问题\n标准库function类型： 我们可以使用一个名为function的新的标准库类型解决上述问题，function 定义在functional头文件中。function是一个模板，和其他模板一样，当创建一个具体的 function 类型时我们必须提供额外的信息。在此例中，所谓额外的信息是指该 function 类型能够表示的对象的调用形式。\n操作 解释 function\u0026lt;T\u0026gt; f; f是一个用来存储可调用对象的空function，这些可调用对象的调用形式应该与类型T相同。 function\u0026lt;T\u0026gt; f(nullptr); 显式地构造一个空function function\u0026lt;T\u0026gt; f(obj) 在f中存储可调用对象obj的副本 f 将f作为条件：当f含有一个可调用对象时为真；否则为假。 定义为function\u0026lt;T\u0026gt;的成员的类型 result_type 该function类型的可调用对象返回的类型 argument_type 当T有一个或两个实参时定义的类型。如果T只有一个实参，则argument_type first_argument_type 第一个实参的类型 second_argument_type 第二个实参的类型 1 2 function\u0026lt;int(int,int)\u0026gt; f1 = [](int i,int j){return i*j;} cout \u0026lt;\u0026lt; f1(4,2) \u0026lt;\u0026lt; endl; 这样就可以重新定义函数表\n1 2 3 4 5 6 7 map\u0026lt;string , function\u0026lt;int(int,int)\u0026gt;\u0026gt; binops = { {\u0026#34;+\u0026#34; , add}, {\u0026#34;-\u0026#34; , std::minus\u0026lt;int\u0026gt;()}, {\u0026#34;/\u0026#34; , divide()}, {\u0026#34;*\u0026#34; , [](int i, int j){return i*j;}}, {\u0026#34;%\u0026#34; , mod} }; 重载函数与function 不能将重载函数的名字存入function类型的对象，但是可以两个方法解决\n1 2 3 4 int add(int i , int j){return i+j;} Sales_data add(const Sales_data\u0026amp; , const Sales_data\u0026amp;); map\u0026lt;string , function\u0026lt;int(int , int)\u0026gt;\u0026gt; binops; binops.insert({\u0026#34;+\u0026#34; , add}); //× ，which add 存储函数指针 1 2 int (*fp)(int , int) = add; binops.insert({\u0026#34;+\u0026#34;,fp}); lamba 1 binops.insert({\u0026#34;+\u0026#34;,[](int a , int b){return add(a,b);}}); 九、重载、类型转换、运算符 1、类型转换运算符 [[类#2.4 转换构造函数]]\n类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下： 1 operator type() const; 一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是const。 避免过度使用类型转换函数。 C++11引入了显式的类型转换运算符。 向bool的类型转换通常用在条件部分，因此operator bool一般定义成explicit的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class SmallInt{ public: SmallInt(int i = 0):val(i) { if(i\u0026lt;0 || i \u0026gt; 255) throw std::out_of_range(\u0026#34;Bad SmallInt value\u0026#34;); } operator int() const{return val;} private: std::size_t val; } SmallInt si; si = 4 ; si + 3 ; SmallInt sj ; sj = 3,14 ; sj + 3.14 ; 2、避免有二义性的类型转换 通常，不要为类定义相同的类型转换，也不要在类中定义两个及以上转换源或转换目标是算术类型的转换。 在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。 3、函数匹配与重载运算符 如果a是一种类型，则表达式a sym b可能是： a.operatorsym(b); operatorsym(a,b); 如果我们队同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。 1 2 3 4 5 6 7 8 9 10 11 12 13 class SmallInt{ friend SmallInt operator+(const SmallInt\u0026amp; , const SmallInt\u0026amp;); public: SmallInt(int = 0); operator int() const {return val;} private: std::size_t val; } SmallInt s1, s2 ; SmallInt s3 = s1 + s2 ; int i = s3 + 0 ; //二义性 ","pubDate":"2021-10-19","title":"【C++ Primer(edition 5) 13】操作重载与类型转换"},{"link":"https://cnjslw.github.io/posts/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/","plain":"拷贝控制操作（copy control）: 拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。 拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。\n拷贝构造函数（copy constructor） 拷贝赋值运算符（copy-assignment operator） 移动构造函数（move constructor） 移动赋值函数（move-assignement operator） 析构函数（destructor） 一、拷贝、赋值和销毁 1、拷贝构造函数 如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。\n1 2 3 4 5 class Foo { public: Foo(const Foo\u0026amp;); } 1.1 合成的拷贝构造函数（synthesized copy constructor） 没有为一个类定义拷贝构造函数，编译器会为我们定义一个,即使我们定义了其他构造函数，编译器也会合成一个拷贝构造函数\n每个成员的类型决定了它如何拷贝：\n对类类型的成员，会使用其拷贝构造函数来拷贝； 内置类型的成员则直接拷贝。 虽然我们不能直接拷贝一个数组，但合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝。 1.2 拷贝初始化 当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。 当我们使用拷贝初 始 化 （copy initialization） 时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。\n拷贝初始化通常使用拷贝构造函数来完成。 但是，如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。\n拷贝初始化发生的时机\n将一个对象作为实参传递给一个非引用类型的形参 从一个返回类型为非引用类型的函数返回一个对象 为什么拷贝构造函数的参数必须是引用形参 因为，将一个对象作为实参传递给一个非引用类型的形参时，会发生拷贝构造，这样就会发生套娃现象\n1.3 拷贝构造的限制 [[类#2.4 转换构造函数|拷贝构造遇到explicit]]\n1 2 3 4 5 vector\u0026lt;int\u0026gt; vl(10) ; // 正确：直接初始化 vector\u0026lt;int\u0026gt; v2 = 10; // 错误：接受大小参教的构造函数是explicit的 void f(vector\u0026lt;int\u0026gt;） ; //f 的参数进行拷贝初始化 f(10) ; // 错误：不能用一个explicit的构造函数拷贝一个实参 f(vector\u0026lt;int\u0026gt;(10)) ; // 正确：从一个int直接构造一个临时vector 2、拷贝赋值运算符 与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。 重写一个名为operator=的函数，通常返回一个指向其左侧运算对象的引用。\n1 Foo\u0026amp; operator=(const Foo\u0026amp;); 合成拷贝赋值运算符 拷贝赋值运算符接受一个与其所在类相同类型的参数\n将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员。 3、析构函数 释放对象所使用的资源，并销毁对象的非static数据成员。\n名字由波浪号接类名构成。没有返回值，也不接受参数。 1 ~Foo(); 调用时机\n变量在离开其作用域时。 当一个对象被销毁时，其成员被销毁。 容器被销毁时，其元素被销毁。 动态分配的对象，当对指向它的指针应用delete运算符时。 对于临时对象，当创建它的完整表达式结束时。 当指向一个对象的引用或指针离开作用域时,析构函数不会执行。 合成析构函数\n空函数体执行完后，成员会被自动销毁。 注意：析构函数体本身并不直接销毁成员。 析构函数完成的工作 在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。\n4、三/五法则 需要析构函数的类也需要拷贝和赋值操作。 需要拷贝操作的类也需要赋值操作，反之亦然。 5、使用=default 可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。合成的函数将隐式地声明为内联的。\n6、阻止拷贝 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。\n定义删除的函数：=delete。 虽然声明了它们，但是不能以任何方式使用它们。 析构函数不能是删除的成员。 如果一个类有数据成员不能默认构造、拷贝、复制或者销毁，则对应的成员函数将被定义为删除的。 老版本使用private声明来阻止拷贝。 二、拷贝控制和资源管理 类的行为可以像一个值，也可以像一个指针。 行为像值：对象有自己的状态，副本和原对象是完全独立的。 行为像指针：共享状态，拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class HasPtr{ public: HasPtr(const std::string \u0026amp;s = std::string()): ps(new std::string(s)),i(0){ } //对ps指向的string，每个HasPtr对象都有自己的拷贝 HasPtr(const HasPtr \u0026amp;p):ps( new std::string(*p.ps) ),i(p.i){ } HasPtr\u0026amp; operator=(const HasPtr \u0026amp;); ~HasPtr(){ delete ps; } private: std::string *ps; int i; }; HasPtr\u0026amp; HasPtr::operator=(const HasPtr \u0026amp;rhs) { auto newp = new string(*rhs.ps);//拷贝底层string delete ps; //释放就内存 ps = newp; //从右侧运算对象拷贝数据到本对象 i = rhs.i; return *this; //返回本对象 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class HasPtr{ public: //构造函数分配新的string和新的计数器，将计数器置为1 HasPtr(const std::string \u0026amp;s = std::string()): ps(new std::string(s)),i(0),use(new std::size_t(1)){ } //拷贝构造函数拷贝所有三个数据成员，并递增计数器 HasPtr(const HasPtr \u0026amp;p): ps(p.ps),i(p.i),use(p.use) {++*use;} HasPtr\u0026amp; operator=(const HasPtr\u0026amp;); ~HasPtr(); private: std::string *ps; int i; std::size_t *use; //用来记录有多少个对象共享*ps的成员 }; HasPtr::~HasPtr() { if(--*use==0){ //如果引用计数变为0 delete ps; //释放string内存 delete use; //释放计数器内存 } } HasPtr\u0026amp; HasPtr::operator=(const HasPtr \u0026amp;rhs) { ++*rhs.use; //递增右侧运算对象的引用计数 if(--*use == 0){ //然后递减本对象的引用计数 delete ps; delete use; } ps = rhs.ps; i = rhs.i; use = rhs.use; return * this; } 三、交换操作 管理资源的类通常还定义一个名为swap的函数。 经常用于重排元素顺序的算法。 用swap而不是std::swap。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class HasPtr{ public: HasPtr(const std::string \u0026amp;s = std::string()): ps(new std::string(s)),i(0){ } //对ps指向的string，每个HasPtr对象都有自己的拷贝 HasPtr(const HasPtr \u0026amp;p):ps( new std::string(*p.ps) ),i(p.i){ } HasPtr\u0026amp; operator=(const HasPtr \u0026amp;); ~HasPtr(){ delete ps; } private: std::string *ps; int i; }; class HasPtr{ friend void swap(HasPtr\u0026amp;,HasPtr\u0026amp;); //其他成员定义... }; inline void swap(HasPtr \u0026amp;lhs,HasPtr \u0026amp;rhs) { using std::swap; swap(lhs.ps,rhs.ps); //交换指针，而不是string数据 swap(lhs.i,rihs.i); //交换int成员 } 四、对象移动 很多拷贝操作后，原对象会被销毁，因此引入移动操作可以大幅度提升性能。 在新标准中，我们可以用容器保存不可拷贝的类型，只要它们可以被移动即可。 标准库容器、string和shared_ptr类既可以支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。\n1、右值引用 新标准引入右值引用以支持移动操作，所谓右值引用就是必须绑定到右值的引用。通过\u0026amp;\u0026amp;获得右值引用。 重要性质：只能绑定到一个将要销毁的对象。 右值引用特性：我们可以将一个右值引用绑定到要求转换的表达式、字面常量或是返回右值的表达式上，但不能将一个右值引用直接绑定到一个左值上。左边值引用则完全相反。\n1.1 左值引用VS右值引用 可绑定类型完全相反 引用 可绑定表达式 左值引用 返回左值引用的函数，赋值、下标、解引用和前置/递减运算符 右值引用 返回非引用类型的函数，算术、关系、位和后置递增/递减运算符 2. 左值持久、右值短暂 左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。 由于右值引用只能绑定到临时对象，我们得知 所引用的对象将要被销毁 该对象没有其他用户 1.2 move函数 虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件utility中\n1 int \u0026amp;\u0026amp;rr2 = std::move(rr1); move告诉编译器，我们有一个左值，但我希望像右值一样处理它。调用move意味着：除了对rr1赋值或者销毁它外，我们将不再使用它。\n2、移动构造函数和移动赋值运算符 2.1 移动构造函数 第一个参数是该类类型的一个引用，关键是这个引用参数是一个右值引用。\n1 2 3 4 5 StrVec::StrVec(StrVec \u0026amp;\u0026amp;s) noexcept: elements(s.elements),first_free(s.first_free),cap(s.cap) { s.elements = s.first_free = s.cap = nullptr; } 不分配任何新内存，只是接管给定的内存。接管内存后，源对象置空，防止源对象控制内存。 移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的，一旦资源完成移动，源对象必须不再指向被移动的资源—— 这些资源的所有权已经归属新创建的对象 任何额外的参数都必须有默认实参 2.2 移动操作、标准库容器和异常 使用移动操作必须通知标准库移动构造函数不会抛出异常，否则标准库总认为会有异常存在。可在声明中标明noexcept，承诺一个函数不抛出异常的一种方法。\n2.3 移动赋值运算符 1 StrVec\u0026amp; StrVec::operator=(StrVec \u0026amp;\u0026amp; rhs) noexcept{} 2.4 移后源对象必须可析构 当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。可以通过将移后源对象的指针成员置为nullptr来实现 移动操作还必须保证对象仍然是有效的——安全使用、不依赖当前值 移动操作对移后源对象中留下的值没有任何要求 2.5 合成的移动操作 编译器也会合成移动构造函数和移动赋值运算符。但是，合成移动操作的条件与合成拷贝操作的条件大不相同\n2.5.1 何时会合成移动操作？ 与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是，如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。\n1 2 3 4 5 6 7 8 9 10 //编译器会为X 和 hasX合成移动操作 struct X{ int i; // 内置类型可以移动 std::string s; // string定义了自己的移动操作 }; struct hasX { X mem; // X 有合成的移动操作 }; X x, x2 = std::move(x); // 使用合成的移动构造函数 hasX hx, hx2 = std::move(hx) ; // 使用合成的移动构造函数 2.5.2 删除的移动操作 如何删除移动操作？ 移动操作永远不会隐式定义为删除的函数\n显示地要求编译器生成=default，编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数 有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。 果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问 类似拷贝构造函数，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的 类似拷贝赋值运算符，如果有类成员是const的或是引用，则类的移动赋值运算 符被定义为删除的 2.5.3 调用时究竟使用哪个 如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。\n2.5.4 没有移动构造函数，右值被拷贝 如果一个美有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的。拷贝赋值运算符和移动赋值运算符的情况类似。\n2.5.5 同时实现拷贝和移动赋值运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 class HasPtr{ public: // 添加的移动构造函数 HasPtr(HasPtr \u0026amp;\u0026amp;p) noexcept : ps(p.ps), i (p.i) {p.ps = 0;} // 赋值运算符既是移动赋值运算符，也是拷贝赋值运算符 HasPtr\u0026amp; operator=(HasPtr rhs) {swap(*this, rhs); return *this; } ); HasPtr hp , hp2; hp = hp2; hp = std::move(hp2); 更新三/五法则：如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。\n3、右值引用和成员函数 如果一个成员函数同时提供拷贝和移动版本，它也能从中受益。这种允许移动的成员函数通常使用与拷贝/移动构造函数和赋值运算符相同的参数模式——一个版本接受一个指向const的左值引用，第二个版本接受一个指向非 const的右值引用\n为啥这样设置参数呢？ 一般来说，我们不需要为函数操作定义接受一个const X\u0026amp;\u0026amp;或是一个(普通的)X\u0026amp; 参数的版本。当我们希望从实参\u0026rsquo;\u0026lsquo;窃取”数据时，通常传递一个右值引用。为了达到这一目的，实参不能是const的。类似的，从一个对象进行拷贝的操作不应该改变该对象。 因此，通常不需要定义一个接受一个(普通的)X\u0026amp;参数的版本。\n3.1 引用限定符阻止灵活的右值操作 一个对象上调用成员函数，而不管该对象是一个左值还是一个右值\n1 2 3 string s1 = \u0026#34;a value\u0026#34;, s2 = \u0026#34;another\u0026#34;; auto n = (si + s2).find(\u0026#39;a\u0026#39;); //直接在右值对象使用成员函数 sl + s2 = \u0026#34;wow!\u0026#34;; //直接给右值对象赋值！！！ 在旧标准中，我们没有办法阻止这种使用方式。为了维持向后兼容性，新标准库类仍然允许向右值赋值。但是，我们可能希望在自己的类中阻止这种用法。在此情况下，我们希望强制左侧运算对象(即，this指向的对象)是一个左值。\n指出this的左值/右值属性的方式，在参数列表后放置一个引用限定符(reference qualifier) ，引用限定符可以是\u0026amp;或\u0026amp;\u0026amp;,分别指出this可以指向一个左值或右值。类似const限定符， 引用限定符只能用于(非static)成员函数，且必须同时出现在函数的声明和定义中，如果有const限定则引用限定位于其后\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Foo{ public: Foo \u0026amp;operator=(const Foo\u0026amp;) \u0026amp;; // 只能向可修改的左值赋值 }; Foo \u0026amp;Foo::operator=(const Foo \u0026amp;rhs) \u0026amp; { return *this; } Foo \u0026amp;retFoo(); // 返回一个引用；retFoo调用是一个左值 1 Foo retVal(); // 返回一个值；retVal调用是一个右值 Foo i, j; // i 和 j 是左值 i = j; // 正确：i是左值 retFoo() = j; // 正确：retFoo ()返回一个左值 retVal() = j; // 错误：retVal () 回一个右值 i = retVal(); // 正确：我们可以将一个右值作为赋值操作的右侧运算对象 class Foo { public: Foo anotherMem() const \u0026amp;; }; ","pubDate":"2021-10-11","title":"【C++ Primer(edition 5) 12】拷贝控制"},{"link":"https://cnjslw.github.io/posts/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/","plain":"动态内存的管理是通过一对运算符来完成的：new,在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；delete,接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。\n对象的生命周期：\n全局对象在程序启动时分配，结束时销毁。\n局部对象在进入程序块时创建，离开块时销毁。\n局部static对象在第一次使用前分配，在程序结束时销毁。\n动态分配对象：只能显式地被释放。\n对象的内存位置：\n静态内存用来保存局部static对象、类static对象、定义在任何函数之外的变量。 栈内存用来保存定义在函数内的非static对象。 堆内存，又称自由空间，用来存储动态分配的对象。 一、new和delete直接管理内存 1、new动态分配内存 1.1 用new动态分配和初始化对象 new无法为分配的对象命名（因为自由空间分配的内存是无名的），因此是返回一个指向该对象的指针。\n1 int *pi = new int(123); 1.2 初始化new分配的对象的方法 默认情况下，动态分配的对象是默认初始化的。这意味着内置类型和组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化 1 2 string *ps = new string; //初始化为空的string int *pi = new int; //pi指向一个未初始化的int 可以使用直接初始化的方式来初始化一个动态分配的对象。即传统的圆括号构造和新标准下的列表初始化 1 2 3 int *pi = new int(1024); string *ps = new string(10,\u0026#39;9\u0026#39;); vector\u0026lt;int\u0026gt; *pv = new vector\u0026lt;int\u0026gt;{0,1,2,3,4,5,6,7,8,9}; 也可以对动态分配的对象进行值初始化。只需要在其后加一对括号即可 1 2 3 4 string *ps1 = new string; //默认初始化为空string string *ps2 = new string(); //值初始化为空string int *pi1 = new int; //默认初始化；*pil的值未定义 int *pi2 = new int(); //值初始化为0； *pi2为 0 1.3 动态分配const对象 new返回的也是一个const指针 除非有默认构造函数的类，不然必须显示化初始化变量\n1.4 内存耗尽 一旦内存耗尽，会抛出类型是bad_alloc的异常。\n2、delete释放内存 2.1 释放动态内存 用delete将动态内存归还给系统。 接受一个指针，这个指针必须指向动态分配的内存或者一个空指针。完成两个动作 :\n销毁给定的指针指向的对象 释放对应的内存。 2.2 delete和指针 编译器不能分辨一个指针指向的是静态还是动态分配的对象，也不能判断是否指针已经被delete\n3、直接管理动态内存存在的常见问题 1.忘记delete内存。 2.使用已经释放掉的对象。 3.同一块内存释放两次。 4.多个指针指向同一块动态内存的删除问题 5.空悬指针问题：delete后的指针称为[[对 delete -ptr 的理解（释放内存、空悬指针、重复释放）.pdf | 空悬指针]]（dangling pointer）\nC/C++ 中为什么 delete 一块内存后，该内存不可复用\n坚持只使用智能指针可以避免上述所有问题。\n二、动态内存与智能指针 动态内存的使用很容易出问题，因为确保在正确的时间释放内存是极其困难的。有时我们会忘记释放内存，在这种情况下就会产生内存泄漏；有时在尚有指针引用内存的情况下我们就释放了它，在这种情况下就会产生引用非法内存的指针。 为了更容易（同时也更安全）地使用动态内存，新的标准库提供了两种智能指针（smart pointer）类型来管理动态对象。\n智能指针：\n管理动态对象。 行为类似常规指针。 负责自动释放所指向的对象。 智能指针也是模板。 shared_ptr允许多个指针指向同一个对象； unique_ptr则\u0026quot;独占”所指向的对象。 标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所 管理的对象。 这三种类型都定义在memory头文件中。\n1、shared_ptr类 1.1 定义 1 2 shared_ptr\u0026lt;string\u0026gt; p1; //p1可以指向string shared_ptr\u0026lt;list\u0026lt;int\u0026gt;\u0026gt; p2; //p2可以指向int的list 1.2 初始化 1.2.1 结合new初始化 用new返回的指针来初始化，但是必须直接初始化 ，因为智能指针的构造函数是explicit，所以不能将一个内置指针隐式转化为智能指针\n1 2 3 shared_ptr\u0026lt;double\u0026gt; pl; //shared_ptr可以指向一个double shared_ptr\u0026lt;int\u0026gt; p2(new int(42)); //p2指向一个值为42的int shared_ptr\u0026lt;int\u0026gt; p3 = new int(1024); //错误，只能直接初始化 1.2.2 make_shared函数 为什么使用 ：最安全的分配和使用动态内存的方法是调用一个名为make_shared 的标准函数 作用 ： 此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr 用法 ： make_shared 用其参数来构造给定类型的对象当要用make_shared时，必须指定想要创建的对象的类型。定义方式与模板类相同， 在函数名之后跟一个尖括号，在其中给出类型 1 2 3 4 shared_ptr\u0026lt;int\u0026gt; p3 = make_shared\u0026lt;int\u0026gt;(42); shared_ptr\u0026lt;string\u0026gt; p4 = make_shared\u0026lt;string\u0026gt;(10, \u0026#39;9\u0026#39;); shared_ptr\u0026lt;int\u0026gt; p5 = make_shared\u0026lt;int\u0026gt;(); auto p6 = make_shared\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt;(); 1.2.3 使用非动态内存初始化 默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。我们可以将智能指针绑定到一个指向其他类型的 资源的指针上，但是为了这样做，必须提供自己的操作来替代delete。\n1 shared_ptr\u0026lt;string\u0026gt; p(\u0026amp;c , end_string) //其中end_string是自己定义的删除函数 1.3 定义和改变shared_ptr的其他方法 操作 解释 shared_ptr\u0026lt;T\u0026gt; p(q) p管理内置指针q所指向的对象；q必须指向new分配的内存，且能够转换为T*类型 shared_ptr\u0026lt;T\u0026gt; p(u) p从unique_ptr u那里接管了对象的所有权；将u置为空 shared_ptr\u0026lt;T\u0026gt; p(q, d) p接管了内置指针q所指向的对象的所有权。q必须能转换为T*类型。p将使用可调用对象d来代替delete。 shared_ptr\u0026lt;T\u0026gt; p(p2, d) p是shared_ptr p2的拷贝，唯一的区别是p将可调用对象d来代替delete。 p.reset() 若p是唯一指向其对象的shared_ptr，reset会释放此对象。若传递了可选的参数内置指针q，会令p指向q，否则会将p置空。若还传递了参数d，则会调用d而不是delete来释放q。 p.reset(q) 同上 p.reset(q, d) 同上 1.4 shared_ptr类的操作 shared_ptr和unique_ptr都支持的操作\n操作 解释 shared_ptr\u0026lt;T\u0026gt; sp unique_ptr\u0026lt;T\u0026gt; up 空智能指针，可以指向类型是T的对象 p 将p用作一个条件判断，若p指向一个对象，则为true *p 解引用p，获得它指向的对象。 p-\u0026gt;mem 等价于(*p).mem p.get() 返回p中保存的指针，要小心使用，若智能指针释放了对象，返回的指针所指向的对象也就消失了。 swap(p, q) p.swap(q) 交换p和q中的指针 shared_ptr独有的操作\n操作 解释 make_shared\u0026lt;T\u0026gt;(args) 返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化此对象。 shared_ptr\u0026lt;T\u0026gt;p(q) p是shared_ptr q的拷贝；此操作会递增q中的计数器。q中的指针必须能转换为T* p = q p和q都是shared_ptr，所保存的指针必须能互相转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放。 p.unique() 若p.use_count()是1，返回true；否则返回false p.use_count() 返回与p共享对象的智能指针数量；可能很慢，主要用于调试。 使用动态内存的三种原因 程序不知道自己需要使用多少对象（比如容器类） 程序不知道所需要对象的准确类型。 程序需要在多个对象间共享数据。 1.5 智能指针和异常 如果使用智能指针，即使程序块由于异常过早结束，智能指针类也能确保在内存不需要的时候将其释放。 智能指针陷阱： 不用相同的内置指针初始化（或reset）多个智能指针 不delete get()返回的指针。 如果你使用get()返回的指针，记得当最后一个对应的智能指针销毁后，你的指针就无效了。 如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。 2、unique_ptr 某一个时刻只能有一个unique_ptr指向一个给定的对象，并“拥有”该对象。 当定义一个unique_ptr时，需要将其绑定到一个new返回的指针上，必须采用直接初始化形式。 不支持拷贝或者赋值操作。只能可以通过调用release或 reset将指针的所有权从一个(非const) unique_ptr转移给另一个 unique 1 2 3 4 5 6 7 // 将所有权从pl (指 向 string Stegosaurus )转移给p2 unique_ptr\u0026lt;string\u0026gt; p2 (pl.release () ) ; // release 将 pl 置为空 unique_ptr\u0026lt;string\u0026gt; p3(new string(\u0026#34;Trex\u0026#34;)); // 将所有权从p3转移给p2 p2.reset (p3.release () ) ; // reset 释放了 p2 原来指向的内存 向后兼容：auto_ptr：老版本，具有unique_ptr的部分特性。特别是，不能在容器中保存auto_ptr，也不能从函数返回auto_ptr。 不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr 1 2 3 4 5 //从函数返回unique_ptr unique_ptr\u0026lt;int\u0026gt; clone (int p) { //正确：从 int*创建一个unique_ptr\u0026lt;int\u0026gt; return unique_ptr\u0026lt;int\u0026gt;(new int(p)); } 1 2 3 4 5 6 //返回一个局部对象的拷贝 unique_ptr\u0026lt;int\u0026gt; clone(int p) { unique_ptr\u0026lt;int\u0026gt; ret (new int(p)); // return ret; } 重载删除器\n1 unique_ptr\u0026lt;objT , delT\u0026gt; p (new objT , fcn); unique_ptr操作:\n操作 解释 unique_ptr\u0026lt;T\u0026gt; u1 空unique_ptr，可以指向类型是T的对象。u1会使用delete来是释放它的指针。 unique_ptr\u0026lt;T, D\u0026gt; u2 u2会使用一个类型为D的可调用对象来释放它的指针。 unique_ptr\u0026lt;T, D\u0026gt; u(d) 空unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete u = nullptr 释放u指向的对象，将u置为空。 u.release() u放弃对指针的控制权，返回指针，并将u置空。 u.reset() 释放u指向的对象 u.reset(q) 令u指向q指向的对象 u.reset(nullptr) 将u置空 3、weak_ptr weak_ptr是一种不控制所指向对象生存期的智能指针。指向一个由shared_ptr管理的对象，不改变shared_ptr的引用计数。 一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，不管有没有weak_ptr指向该对象。\nweak_ptr操作:\n操作 解释 weak_ptr\u0026lt;T\u0026gt; w 空weak_ptr可以指向类型为T的对象 weak_ptr\u0026lt;T\u0026gt; w(sp) 与shared_ptr指向相同对象的weak_ptr。T必须能转换为sp指向的类型。 w = p p可以是shared_ptr或一个weak_ptr。赋值后w和p共享对象。 w.reset() 将w置为空。 w.use_count() 与w共享对象的shared_ptr的数量。 w.expired() 若w.use_count()为0，返回true，否则返回false w.lock() 如果expired为true，则返回一个空shared_ptr；否则返回一个指向w的对象的shared_ptr。 创建一个weak_ptr\n我们创建一个weak_ptr时，要用一个shared_ptr来初始化它\n1 2 auto p = make_shared\u0026lt;int\u0026gt;(42); weak_ptr\u0026lt;int\u0026gt; wp (p) ; // wp弱共享p； p 的引用计数未改变 由于对象可能不存在，我们不能使用weak_ptr直接访问对象，必须调用lock此函数检查weak_ptr指向的对象是否仍存在。如果存在，lock返回一个指向共享对象的 shared_ptr。\n1 2 if(shared_ptr\u0026lt;int\u0026gt; np = wp.lock()) {} 三、动态数组 1、new和数组 1.1 new一个动态数组 类型名之后加一对方括号，指明分配的对象数目（必须是整型，不必是常量）。 返回指向第一个对象的指针。 1 int *p = new int[size]; 方括号中的大小必须是整形，但不必是常量。也可以用一个表示数组类型的类型别名来分配一个数组这样new表达式中就不需要方括号了。 1 2 typedef int arrT [42] ; //arrT 表示 42 个 int 的数组类型 int *p = new arrT; //分配一个42个 int的数组；p 指向第一个int 动态分配一个空数组也是合法的，这样的指针就类似于尾后指针。 1.2 初始化动态数组 方法一：在数组大小之后跟一对空括号 1 2 3 4 int *pia = new int[10]; // 10个未初始化的int int *pia2 = new int[10](); // 10个值初始化为0 的 int string *psa = new string[10]; // 10 个空 string string *psa2 = new string[10](); // 10 个空 string 方法二：提供一个元素初始化器的花括号列表 1 2 3 4 // 10个 int分别用列表中对应的初始化器初始化 int *pia3 = new int[10]{0,1,2,3,4,5,6,7,8,9}; // 10个 string,前 4个用给定的初始化器初始化，剩余的进行值初始化 string *psa3 = new string [10] {\u0026#34;a\u0026#34;, \u0026#34;an\u0026#34;， \u0026#34;the\u0026#34;， string (3,\u0026#39;x\u0026#39;)}; 2、delete释放一个动态数组 为了释放动态数组，我们使用一种特殊形式的delete— 在指针前加上一个空方括号对\n1 delete [] p; //数组中的元素按逆序销毁 方括号对是必需的：它指示编译器此指针指向一个对象数组的第一个元素。即使使用类型别名，也需要方括号对\n3、智能指针unique_ptr和动态数组 3.1 定义与销毁 在定义时，在对象类型后面跟一对空方括号。 1 2 3 //up指向一个包含10个未初始化int的数组 unique_ptr\u0026lt;int[]\u0026gt; up(new int[10]); up.release(); // 自动用delete []销毁其指针 类型说明符中的方括号(\u0026lt;int[]\u0026gt;)指 出 up 指向一个int数组而不是一个int。由于 up指向一个数组，当 up销毁它管理的指针时，会自动使用delete[]\n3.2 操作 指向数组的unique_ptr不支持成员访问运算符（点和箭头）。当一个unique_ptr指向一个数组时, 我们可以使用下标运算符来访问数组中的元素\n操作 解释 unique_ptr\u0026lt;T[]\u0026gt; u u可以指向一个动态分配的数组，整数元素类型为T unique_ptr\u0026lt;T[]\u0026gt; u(p) u指向内置指针p所指向的动态分配的数组。p必须能转换为类型T*。 u[i] 返回u拥有的数组中位置i处的对象。u必须指向一个数组。 shared_ptr不直接支持管理动态数组，如果希望使用则需要定义自己的删除器。并且其未定义下标运算符，而且智能指针类型不支持指针算数术运算。为了访问元素,必须用get获取一个内置指针然后访问元素 4、allocator类 4.1 new、delete 管理动态数组之困 new、detele将内存分配和对象构造组合在了一 起 但是存在一种情况，希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作。 这暴露了这种管理动态数组的缺点：可能会造成不必要的浪费\n1 2 3 4 5 6 7 string *const p = new string [n] ; //构造 n 个空 string string s; string *q = p; // q 指向第一个 string while （cin\u0026gt;\u0026gt;s \u0026amp; \u0026amp; q ! = p + n ） *q++ = s; // 赋予*q一个新值 const size_t size = q - p; //记住我们读取了多少个string // 使用数组 delete [] p; // p 指向一个数组；记得用delete []来释放 问题1：在不知道有多少输入字符串时，就预先分配了n个元素的数组 问题2：赋值了两次，第一次默认初始化，随后又赋值 问题3：没有默认构造函数的类就不能动态分配数组\n4.2 allocator类 标准库allocator类定义在头文件memory中，帮助我们将内存分配和对象构造分离开。\n分配的是原始的、未构造的内存。 allocator是一个模板。当一个 allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置 4.2.1 allocator分配未构造的内存 标准库allocator类及其算法\n操作 解释 allocator\u0026lt;T\u0026gt; a 定义了一个名为a的allocator对象，它可以为类型为T的对象分配内存 a.allocate(n) 分配一段原始的、未构造的内存，保存n个类型为T的对象。 a.deallocate(p, n) 释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针。且n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy。 a.construct(p, args) p必须是一个类型是T*的指针，指向一块原始内存；args被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象。 a.destroy(p) p为T*类型的指针，此算法对p指向的对象执行析构函数。 allocator分配的内存是未构造的(unconstructed)。我们按需要在此内存中构造对 象。在新标准库中，construct成员函数接受一个指针和零个或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 allocator\u0026lt;string\u0026gt; alloc; //可以分配string的allocator对现 auto const p = alloc.allocate(n); //分配n个未初始化的string auto q = p; // q 指向最后构造的元素之后的位置 //为了使用allocate返回的内存，我们必须用construct构造对象 alloc.construct (q++) ; // *q 为空字符串 alloc.construct(q++, 10, \u0026#39;c\u0026#39; ); // *q 为 cccccccccc alloc.construct(q++, \u0026#34;hi\u0026#34;); //*q为hi! cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; // 正确：使用string的输出运算符 cout \u0026lt;\u0026lt; *q \u0026lt;\u0026lt; endl; // 灾难：q 指向未构造的内存！ //当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。函数destroy 接受一个指针，对指向的对象执行析构函数 while (q != p) alloc.destroy (--q) ; // 释放我们真正构造的string //元素销毁后，1.继续分配给其他元素 2.deallocate释放内存，还给系统 alloc.deallocate(p, n); allocator算法：\n操作 解释 uninitialized_copy(b, e, b2) 从迭代器b和e给定的输入范围中拷贝元素到迭代器b2指定的未构造的原始内存中。b2指向的内存必须足够大，能够容纳输入序列中元素的拷贝。 uninitialized_copy_n(b, n, b2) 从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中。 uninitialized_fill(b, e, t) 在迭代器b和e执行的原始内存范围中创建对象，对象的值均为t的拷贝。 uninitialized_fill_n(b, n, t) 从迭代器b指向的内存地址开始创建n个对象。b必须指向足够大的未构造的原始内存，能够容纳给定数量的对象。 定义在头文件memory中。 在给定目的位置创建元素，而不是由系统分配内存给他们。动态内存的管理是通过一对运算符来完成的：new,在动态内存中为对象 分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；delete,接 受一个动态对象的指针，销毁该对象，并释放与之关联的内存。 ","pubDate":"2021-10-07","title":"【C++ Primer(edition 5) 11】动态内存"},{"link":"https://cnjslw.github.io/posts/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/","plain":" 因为它们实现共同的操作，所以称之为“算法”；而“泛型”、指的是它们可以操作在多种容器类型上。 泛型算法本身不执行容器操作，只是单独依赖迭代器和迭代器操作实现。 头文件： #include \u0026lt;algorithm\u0026gt;或者 #include \u0026lt;numeric\u0026gt;(算数相关) 大多数算法是通过遍历两个迭代器标记的一段元素来实现其功能。 必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但不能直接添加或者删除元素。 一、find vector\u0026lt;int\u0026gt;::const_iterator result = find(vec.begin(), vec.end(), search_value); 输入：两个标记范围的迭代器和目标查找值。返回：如果找到，返回对应的迭代器，否则返回第二个参数，即标记结尾的迭代器。 二、初识泛型算法 标准库提供了超过100个算法，但这些算法有一致的结构。 理解算法的最基本的方法是了解它们是否读取元素、改变元素、重排元素顺序。 1、只读算法 只读取范围中的元素，不改变元素。 如 find和 accumulate（在numeric中定义，求和）。 find_first_of，输入：两对迭代器标记两段范围，在第一段中找第二段中任意元素，返回第一个匹配的元素，找不到返回第一段的end迭代器。 通常最好使用cbegin和cend。 equal：确定两个序列是否保存相同的值。 2、写容器元素的算法 一些算法将新值赋予序列中的元素。 算法不检查写操作。 fill： fill(vec.begin(), vec.end(), 0); 将每个元素重置为0 fill_n： fill_n(vec.begin(), 10, 0); 插入迭代器back_inserter： 用来确保算法有足够的空间存储数据。 #include \u0026lt;iterator\u0026gt; back_inserter(vec) 拷贝算法copy： 输入：前两个参数指定输入范围，第三个指向目标序列。 copy (ilst.begin(), ilst.end(), back_inserter(ivec)); copy时必须保证目标目的序列至少要包含与输入序列一样多的元素。 3、重排容器元素的算法 这些算法会重排容器中元素的顺序。 排序算法sort： 接受两个迭代器，表示要排序的元素范围。 消除重复unique： 之前要先调用sort 返回的迭代器指向最后一个不重复元素之后的位置。 顺序会变，重复的元素被“删除”。 并没有真正删除，真正删除必须使用容器操作。 三、定制操作 1、向算法传递函数： 谓词（predicate）：\n是一个可调用的表达式，返回结果是一个能用作条件的值 一元谓词：接受一个参数 二元谓词：接受两个参数 例子：\nstable_sort： 保留相等元素的原始相对位置。 stable_sort(words.begin(), words.end(), isShorter); 2、lambda表达式 2.1 可调用对象 可调用==对象==：==对象==或一个==表达式==，如果可以对其使用调用运算符则称它为可调用的。\n函数 函数指针 重载了函数调用运算符的类 Lambda表达式 2.2 lambda表达式 有时可能希望操作可以接受更多的参数。\nLambda表达式主要解决了以下两个技术问题：\n匿名函数的问题：传统C++语言中，如果要使用一个函数对象，必须定义一个具名的函数对象或使用函数指针，这会导致代码冗长，不便于代码重构和维护。Lambda表达式可以直接定义匿名的函数对象，方便代码编写。 捕获变量的问题：Lambda表达式可以在定义时捕获外部变量，并在表达式中使用，这种方式解决了函数对象使用外部变量时需要定义多个函数对象的问题。同时Lambda表达式提供了捕获变量的多种方式，如值捕获、引用捕获和引用捕获并修改等，方便了变量的使用和修改。 lambda表达式表示一个可调用的代码单元，可以理解成是一个未命名的内联函数。 形式 1 [capture list](parameter list) -\u0026gt; return type {function body} 其中capture list捕获列表是一个lambda所在函数定义的局部变量的列表（通常为空）。不可忽略。 return type是返回类型。可忽略。 parameter是参数列表。可忽略。 function body是函数体。不可忽略。 auto f = [] {return 42;} 与函数的差别\n必须使用尾置类型来表示返回类型 可以忽略返回类型。默认情况下，如果一个Lambda体内含有return之外的任何语句，则编译器假定Lambda返回void。但是与函数不同，返回void的lambda不能返回值 不能有默认参数 例子\nfind_if: 接受一对表示范围的迭代器和一个谓词，用来查找第一个满足特定要求的元素。返回第一个使谓词返回非0值的元素。 auto wc = find_if(words.begin(), words.end(), [sz](const string \u0026amp;a){return a.size() \u0026gt;= sz;}); for_each： 接受一个可调用对象，并对序列中每个元素调用此对象。 for_each(wc, words.end(), [](const string \u0026amp;s){cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}) 3、lambda捕获和返回 定义lambda时会生成一个新的类类型和该类型的一个对象。 默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员，在lambda对象创建时被初始化。 值捕获：前提是变量可以拷贝，size_t v1 = 42; auto f = [v1] {return v1;};。 引用捕获：必须保证在lambda执行时，变量是存在的，auto f2 = [\u0026amp;v1] {return v1;}; 尽量减少捕获的数据量，尽可能避免捕获指针或引用。 隐式捕获：让编译器推断捕获列表，在捕获列表中写一个\u0026amp;（引用方式）或=（值方式）。auto f3 = [=] {return v1;} 可变Lambda: 改变值捕获的变量 : 1 size_t v1 = 42; auto f=[v1]()mutable{return ++v1}; v1=0; auto j=f(); // j=43 改变引用捕获变量 : 取决于引用指向的是一个const or not lambda捕获列表：\n捕获列表 解释 [] 空捕获列表。lambda不能使用所在函数中的变量。一个lambda只有在捕获变量后才能使用它们。 [names] names是一个逗号分隔的名字列表，这些名字都是在lambda所在函数的局部变量，捕获列表中的变量都被拷贝，名字前如果使用了\u0026amp;，则采用引用捕获方式。 [\u0026amp;] 隐式捕获列表，采用引用捕获方式。lambda体中所使用的来自所在函数的实体都采用引用方式使用。 [=] 隐式捕获列表，采用值捕获方式。 [\u0026amp;, identifier_list] identifier_list是一个逗号分隔的列表，包含0个或多个来自所在函数的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。identifier_list中的名字前面不能使用\u0026amp; [=, identifier_list] identifier_list中的变量采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。identifier_list中的名字不能包括this，且前面必须使用\u0026amp; 4、参数绑定 lambda表达式更适合在一两个地方使用的简单操作。 如果是很多地方使用相同的操作，还是需要定义函数。 函数如何包装成一元谓词？使用参数绑定。 bind参数绑定是解决回调函数传递参数问题的一种技术手段。 在C++中，回调函数是指在某个函数中传入另一个函数的指针，以便在主函数中调用。通常情况下，回调函数需要传递一些参数才能完成其功能。在调用时，需要在主函数中手动传递这些参数，这样就会导致代码冗长、可读性差、维护困难等问题。 使用bind参数绑定，可以将回调函数中需要传递的参数提前绑定，形成一个新的函数对象，这个函数对象可以像回调函数一样在主函数中使用，但不再需要手动传递参数。这样就可以大大简化代码，提高代码可读性和可维护性。\n例如，假设有一个回调函数func，需要传递两个参数a和b，在主函数中使用时，可以使用bind绑定这两个参数：\n1 2 3 4 5 6 7 int add(int x, int y) { return x + y; } auto add10 = std::bind(add, 10, std::placeholders::_1); std::cout \u0026lt;\u0026lt; add10(5) \u0026lt;\u0026lt; std::endl; // 输出 15 std::cout \u0026lt;\u0026lt; add10(7) \u0026lt;\u0026lt; std::endl; // 输出 17 标准库bind函数\n定义在头文件functional中，可以看做为一个通用的函数适配器。 auto newCallable = bind(callable, arg_list); 我们再调用newCallable的时候，newCallable会调用callable并传递给它arg_list中的参数。 _n代表第n个位置的参数。定义在placeholders的命名空间中。using std::placeholder::_1; auto g = bind(f, a, b, _2, c, _1);，调用g(_1, _2)实际上调用f(a, b, _2, c, _1) 非占位符的参数要使用引用传参，必须使用标准库ref函数或者cref函数。 在这个例子中，我们使用std::bind将add函数的第一个参数绑定为10，并将第二个参数留空，即使用占位符std::placeholders::_1表示。这样，我们得到了一个新的函数add10，它只需要一个参数（y），它将x固定为10，因此在调用add10时，只需要传递另一个参数即可。\nbind绑定参数的例子 假设我们有一个函数printNumAndString，需要同时输出一个整数和一个字符串，代码如下：\n1 2 3 4 void printNumAndString(int num, const std::string\u0026amp; str) { std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; } 现在我们有一个数组nums和一个字符串str，我们希望将printNumAndString应用于数组nums的所有元素和字符串str，使用for循环可以实现：\n1 2 3 4 5 int nums[] = {1, 2, 3, 4, 5}; std::string str = \u0026#34;hello\u0026#34;; for (int i = 0; i \u0026lt; 5; i++) { printNumAndString(nums[i], str); } 但是如果我们想要使用STL算法std::for_each来完成这个任务呢？在std::for_each中，我们可以指定一个可调用对象，它将应用于容器中的所有元素。在这个例子中，我们可以这样做：\n1 2 3 int nums[] = {1, 2, 3, 4, 5}; std::string str = \u0026#34;hello\u0026#34;; std::for_each(std::begin(nums), std::end(nums), [=](int num) { printNumAndString(num, str); }); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //编译器生成的代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; void printNumAndString(int num, const std::basic_string\u0026lt;char\u0026gt; \u0026amp; str) { std::operator\u0026lt;\u0026lt;(std::operator\u0026lt;\u0026lt;(std::cout.operator\u0026lt;\u0026lt;(num), \u0026#34;: \u0026#34;), str).operator\u0026lt;\u0026lt;(std::endl); } int main() { int nums[5] = {1, 2, 3, 4, 5}; std::basic_string\u0026lt;char\u0026gt; str = std::basic_string\u0026lt;char\u0026gt;(std::basic_string\u0026lt;char\u0026gt;(\u0026#34;hello\u0026#34;, std::allocator\u0026lt;char\u0026gt;())); //这个表达式是一个Lambda表达式生成的闭包对象（closure object）的类型名称，其中`__lambda_12_49`是一个自动生成的类名，用于标识这个Lambda表达式的类型，而后面的`{str}`则是Lambda表达式的参数列表，表示捕获了一个名为`str`的变量。在C++中，Lambda表达式的类型是一个未命名的闭包类（closure class），它会根据Lambda表达式的内容和上下文自动创建，其中捕获的变量会作为类的成员变量，Lambda表达式的函数体则会转化为类的一个成员函数。在使用Lambda表达式时，编译器会自动生成一个闭包对象，其类型就是Lambda表达式的类型，这个闭包对象可以像普通函数一样被调用和使用。在这个例子中，`__lambda_12_49`就是自动生成的闭包类的类型名称，其中的`{str}`表示捕获了一个名为`str`的变量。 class __lambda_12_49 { public: inline void operator()(int num) const { printNumAndString(num, str); } private: std::basic_string\u0026lt;char\u0026gt; str; public: // inline __lambda_12_49(__lambda_12_49 \u0026amp;\u0026amp;) noexcept = default; // inline __lambda_12_49 \u0026amp; operator=(const __lambda_12_49 \u0026amp;) /* noexcept */ = delete; __lambda_12_49(const std::basic_string\u0026lt;char\u0026gt; \u0026amp; _str) : str{_str} {} }; std::for_each(std::begin(nums), std::end(nums), __lambda_12_49(__lambda_12_49{str})); return 0; } //在这个lambda表达式中，只捕获了`str`而没有捕获`nums`数组的原因是，lambda表达式中使用的`nums`数组是通过迭代器传递给`std::for_each`算法的，而不是直接作为lambda表达式的捕获变量。当lambda表达式使用`std::for_each`算法时，迭代器会逐一遍历数组中的元素，并将每个元素作为lambda表达式的参数进行调用，因此不需要在lambda表达式中捕获`nums`数组。而对于`str`变量，由于lambda表达式中调用了`printNumAndString`函数，需要将其作为参数传递给函数，因此需要捕获它。 在这个例子中，我们使用lambda表达式来定义一个可调用对象，它将接受一个整数作为参数，并调用printNumAndString函数来打印整数和字符串。但是在调用printNumAndString函数时，我们需要传递两个参数，而不是一个整数。这时候，我们可以使用std::bind函数来绑定第二个参数：\n1 2 3 int nums[] = {1, 2, 3, 4, 5}; std::string str = \u0026#34;hello\u0026#34;; std::for_each(std::begin(nums), std::end(nums), std::bind(printNumAndString, std::placeholders::_1, str)); 在这个例子中，我们使用std::bind函数来绑定第二个参数str，并使用std::placeholders::_1来表示第一个参数num。现在我们可以将std::bind返回的可调用对象传递给std::for_each，它将在容器的每个元素上调用该对象，而不必手动绑定第二个参数。\n四、再探迭代器 1、插入迭代器 插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，能实现向给定容器添加元素。 三种类型： back_inserter：创建一个使用push_back的迭代器。 front_inserter：创建一个使用push_front的迭代器。 inserter创建一个使用insert的迭代器。接受第二个参数，即一个指向给定容器的迭代器，元素会被查到迭代器所指向的元素之前。 插入迭代器操作：\n操作 解释 it=t 在it指定的当前位置插入值t。假定c是it绑定的容器，依赖于插入迭代器的不同种类，此赋值会分别调用c.push_back(t)、c.push_front(t)、c.insert(t, p)，其中p是传递给inserter的迭代器位置 *it, ++it, it++ 这些操作虽然存在，但不会对it做任何事情，每个操作都返回it 插入迭代器是 C++ STL 中的一种迭代器，它可以用来将元素插入到容器中。和普通迭代器一样，它也支持迭代器操作，如 ++、* 等。但是它有一个特殊的地方，它不是指向某个容器的迭代器，而是一个模板类，通过模板参数来指定要插入的容器类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iterator\u0026gt; // 包含插入迭代器头文件 int main() { std::vector\u0026lt;int\u0026gt; v1{1, 2, 3, 4}; std::vector\u0026lt;int\u0026gt; v2{5, 6, 7, 8}; // 创建插入迭代器，将元素插入到 v1 的末尾 std::back_insert_iterator\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; inserter(v1); // 将 v2 中的元素插入到 v1 中 std::copy(v2.begin(), v2.end(), inserter); // 输出 v1 中的元素 for (const auto\u0026amp; elem : v1) { std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; std::endl; return 0; } 2、iostream迭代器 C++中的iostream迭代器可以将输入输出流转换为迭代器，使得可以像操作容器迭代器一样操作输入输出流。 使用iostream迭代器需要包含头文件\u0026lt;iterator\u0026gt;和\u0026lt;iostream\u0026gt;。\n流迭代器将它们对应的流当做一个特定类型的元素序列来处理通过使用流迭代器，我们可以用泛型算法对流对象读取数据以及向其写入数据。 迭代器可与输入或输出流绑定在一起，用于迭代遍历所关联的 IO 流。 通过使用流迭代器，我们可以用泛型算法从流对象中读取数据以及向其写入数据。 istream_iterator的操作：\n操作 解释 istream_iterator\u0026lt;T\u0026gt; in(is); in从输入流is读取类型为T的值 istream_iterator\u0026lt;T\u0026gt; end; 读取类型是T的值的istream_iterator迭代器，表示尾后位置 in1 == in2 in1和in2必须读取相同类型。如果他们都是尾后迭代器，或绑定到相同的输入，则两者相等。 in1 != in2 类似上条 *in 返回从流中读取的值 in-\u0026gt;mem 与*(in).mem含义相同 ++in, in++ 使用元素类型所定义的\u0026gt;\u0026gt;运算符从流中读取下一个值。前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值。 1 2 istream_iterator\u0026lt;int\u0026gt; in(cin) ,eof; cout \u0026lt;\u0026lt; accumulate(in,eof,0)\u0026lt;\u0026lt;endl; ostream_iterator的操作：\n操作 解释 ostream_iterator\u0026lt;T\u0026gt; out(os); out将类型为T的值写到输出流os中 ostream_iterator\u0026lt;T\u0026gt; out(os, d); out将类型为T的值写到输出流os中，每个值后面都输出一个d。d指向一个空字符结尾的字符数组。 out = val 用\u0026lt;\u0026lt;运算符将val写入到out所绑定的ostream中。val的类型必须和out可写的类型兼容。 *out, ++out, out++ 这些运算符是存在的，但不对out做任何事情。每个运算符都返回out。 1 2 3 4 5 6 ostream_iterator\u0026lt;int\u0026gt; out_iter(cout,\u0026#34; \u0026#34;); for(auto e:vec) { *out_iter++=e; //等价写法：out_iter=e; } cout\u0026lt;\u0026lt;endl; 下面是一些使用iostream迭代器的例子：\n1 2 3 4 5 6 7 8 9 10 //1. 从标准输入流中读取数据到容器中： #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iterator\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; v; std::copy(std::istream_iterator\u0026lt;int\u0026gt;(std::cin), std::istream_iterator\u0026lt;int\u0026gt;(), std::back_inserter(v)); return 0; } 这个例子中，std::istream_iterator\u0026lt;int\u0026gt;(std::cin)创建了一个输入流迭代器，表示从标准输入流中读取int类型的数据，std::istream_iterator\u0026lt;int\u0026gt;()创建了一个默认的输入流迭代器，表示输入流的结束。std::copy算法使用输入流迭代器和输出迭代器将数据从输入流复制到容器中。\n1 2 3 4 5 6 7 8 9 10 //2. 将容器中的数据输出到标准输出流中： #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iterator\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; v {1, 2, 3, 4, 5}; std::copy(std::begin(v), std::end(v), std::ostream_iterator\u0026lt;int\u0026gt;(std::cout, \u0026#34; \u0026#34;)); return 0; } 这个例子中，std::ostream_iterator\u0026lt;int\u0026gt;(std::cout, \u0026quot; \u0026quot;)创建了一个输出流迭代器，表示将int类型的数据输出到标准输出流中，每个数据之间用空格隔开。std::copy算法使用输入迭代器和输出流迭代器将数据从容器输出到标准输出流中。\n3、反向迭代器 反向迭代器是一种特殊的迭代器，它可以从容器的末尾向前遍历容器的元素。C++标准库中提供了反向迭代器std::reverse_iterator，可以用来迭代双向迭代器或随机访问迭代器。\n反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。 对于反向迭代器，递增和递减的操作含义会颠倒。 实现向后遍历，配合rbegin和rend reverse_iterator 的base成员 ![[Pasted image 20220516175615.png]]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; v {1, 2, 3, 4, 5}; // 从容器尾部构造一个反向迭代器 auto rit = v.rbegin(); // 遍历容器的元素，从尾部开始 while (rit != v.rend()) { std::cout \u0026lt;\u0026lt; *rit \u0026lt;\u0026lt; \u0026#34; \u0026#34;; ++rit; } std::cout \u0026lt;\u0026lt; std::endl; // 使用std::for_each算法和反向迭代器遍历容器的元素，从尾部开始 std::for_each(v.rbegin(), v.rend(), [](int i) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); std::cout \u0026lt;\u0026lt; std::endl; return 0; } 这个例子中，我们首先从容器尾部构造了一个反向迭代器，然后使用while循环遍历了容器的元素。在遍历时，我们通过*rit访问反向迭代器指向的元素，同时每次遍历完成后，通过++rit移动迭代器，直到反向迭代器指向容器的开头位置。 另外，我们还使用了std::for_each算法和反向迭代器来遍历容器的元素，从尾部开始。在这个例子中，我们使用了一个lambda表达式来输出遍历到的每个元素。\n五、泛型算法结构 1、5类迭代器 迭代器类别 解释 支持的操作 输入迭代器 只读，不写；单遍扫描，只能递增 ==,!=,++,*,-\u0026gt; 输出迭代器 只写，不读；单遍扫描，只能递增 ++,* 前向迭代器 可读写；多遍扫描，只能递增 ==,!=,++,*,-\u0026gt; 双向迭代器 可读写；多遍扫描，可递增递减 ==,!=,++,--,*,-\u0026gt; 随机访问迭代器 可读写，多遍扫描，支持全部迭代器运算 ==,!=,\u0026lt;,\u0026lt;=,\u0026gt;,\u0026gt;=,++,--,+,+=,-,-=,*,-\u0026gt;,iter[n]==*(iter[n]) 2、算法的形参模式 alg(beg, end, other args); alg(beg, end, dest, other args); alg(beg, end, beg2, other args); alg(beg, end, beg2, end2, other args); 其中，alg是算法名称，beg和end表示算法所操作的输入范围。dest、beg2、end2都是迭代器参数，是否使用要依赖于执行的操作。\n3、算法命名规范 一些算法使用重载形式传递一个谓词。 接受一个元素值的算法通常有一个不同名的版本：加_if，接受一个谓词代替元素值。 区分拷贝元素的版本和不拷贝的版本：拷贝版本通常加_copy。 六、特定容器算法 对于list和forward_list，优先使用成员函数版本的算法而不是通用算法。\nlist和forward_list成员函数版本的算法：\n操作 解释 lst.merge(lst2) 将来自lst2的元素合并入lst，二者都必须是有序的，元素将从lst2中删除。 lst.merge(lst2, comp) 同上，给定比较操作。 lst.remove(val) 调用erase删除掉与给定值相等(==)的每个元素 lst.remove_if(pred) 调用erase删除掉令一元谓词为真的每个元素 lst.reverse() 反转lst中元素的顺序 lst.sort() 使用\u0026lt;排序元素 lst.sort(comp) 使用给定比较操作排序元素 lst.unique() 调用erase删除同一个值的连续拷贝。使用==。 lst.unique(pred) 调用erase删除同一个值的连续拷贝。使用给定的二元谓词。 上面的操作都返回void list和forward_list的splice成员函数版本的参数：\n参数 解释 (p, lst2) p是一个指向lst中元素的迭代器，或者一个指向flst首前位置的迭代器。函数将lst2中的所有元素移动到lst中p之前的位置或是flst中p之后的位置。将元素从lst2中删除。lst2的类型必须和lst相同，而且不能是同一个链表。 (p, lst2, p2) 同上，p2是一个指向lst2中位置的有效的迭代器，将p2指向的元素移动到lst中，或将p2之后的元素移动到flst中。lst2可以是于lst或flst相同的链表。 (p, lst2, b, e) b和e表示lst2中的合法范围。将给定范围中的元素从lst2移动到lst或first中。lst2与lst可以使相同的链表，但p不能指向给定范围中的元素。 使用lst.splice(args)或flst.splice_after(args) ","pubDate":"2021-10-01","title":"【C++ Primer(edition 5) 10】泛型算法"},{"link":"https://cnjslw.github.io/posts/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/","plain":"关联容器和顺序容器的不同：关联容器中的元素时按照关键字来保存和访问的。 关联容器支持通过关键字来高效地查找和读取元素，基本的关联容器类型是 map和 set。\n关联容器类型：\n容器类型 解释 按顺序存储 map 关键数组：保存关键字-值对 set 关键字即值，即只保存关键字的容器 multimap 支持同一个键多次出现的map multiset 支持同一个键多次出现的set 无序集合 unordered_map 用哈希函数组织的map unordered_set 用哈希函数组织的set unordered_multimap 哈希组织的map，关键字可以重复出现 unordered_multiset 哈希组织的set，关键字可以重复出现 一、使用关联容器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //map map\u0026lt;int , size_t\u0026gt; word_count; string word; while(cin\u0026gt;\u0026gt;word) ++word_count[word]; for(const auto \u0026amp;w : word_count) cout\u0026lt;\u0026lt;w.first\u0026lt;\u0026lt;\u0026#34; occurs \u0026#34;\u0026lt;\u0026lt;w.second \u0026lt;\u0026lt;((w.second\u0026gt;1)?\u0026#34;times\u0026#34;:\u0026#34;time\u0026#34;)\u0026lt;\u0026lt;endl; //set map\u0026lt;string, size_t\u0026gt; word_count; // string 到 size_t 的空 map set\u0026lt;string\u0026gt; exclude = (\u0026#34;The\u0026#34;, \u0026#34;But\u0026#34;, \u0026#34;And”， MOr\u0026#39;*, \u0026#34;An\u0026#34;, \u0026#34;A”， \u0026#34;the”， “but”， \u0026#34;and”， norn , \u0026#34;ann , \u0026#34;a\u0026#34;}; string word; while (cin\u0026gt;\u0026gt;word) //只统计不在exclude中的单词 if (exclude.find(word) == exclude.end()) ++word_count [word] ; //获取并递增word的计数器 二、关联容器概述 关联容器基本支持普通容器的所有操作，但是不支持顺序容器的位置相关操作，例如push_back，push_front 关联容器还支持特有的操作和类型别名 无序容器还支持一些来调整哈希性能的操作 1、定义关联容器 必须需要指定元素类型，并且值符合要求或者可以转化。 默认构造 关联容器初始化为另一个同类型容器的拷贝 值范围初始化 列表初始化： map：map\u0026lt;string, int\u0026gt; word_count = {{\u0026quot;a\u0026quot;, 1}, {\u0026quot;b\u0026quot;, 2}}; set：set\u0026lt;string\u0026gt; exclude = {\u0026quot;the\u0026quot;, \u0026quot;a\u0026quot;}; 2、关键字类型的要求 对于有序容器，关键字类型必须定义元素比较的方法。默认是\u0026lt;。 如果想传递一个比较的函数，可以这样定义：multiset\u0026lt;Sales_data, decltype(compareIsbn)*\u0026gt; bookstore(compareIsbn); 3、pair 在utility头文件中定义。 一个pair保存两个数据成员，两个类型不要求一样。 pair的操作 操作 解释 pair\u0026lt;T1, T2\u0026gt; p; p是一个pair，两个类型分别是T1和T2的成员都进行了值初始化。 pair\u0026lt;T1, T2\u0026gt; p(v1, v2); first和second分别用v1和v2进行初始化。 pair\u0026lt;T1, T2\u0026gt;p = {v1, v2}; 等价于`p(v1, v2) make_pair(v1, v2); pair的类型从v1和v2的类型推断出来。 p.first 返回p的名为first的数据成员。 p.second 返回p的名为second的数据成员。 p1 relop p2 运算关系符按字典序定义。 p1 == p2 必须两对元素两两相等 p1 != p2 同上 三、关联容器操作 关联容器额外的类型别名：\n类型别名 解释 key_type 此容器类型的关键字类型 mapped_type 每个关键字关联的类型，只适用于map value_type 对于map，是pair\u0026lt;const key_type, mapped_type\u0026gt;; 对于set，和key_type相同。 1、关联容器迭代器 解引用一个关联容器迭代器时，会得到一个类型为容器的value_type的值的引用。 map中的迭代器解引用返回一个pair\u0026lt;const value_type , value_type\u0026gt; set的迭代器是const的。 遍历关联容器：使用begin和end，遍历map、multimap、set、multiset时，迭代器按关键字升序遍历元素。 2、添加元素 关联容器insert操作：\ninsert操作 关联容器 c.insert(v) c.emplace(args) v是value_type类型的对象；args用来构造一个元素。 对于map和set，只有元素的关键字不存在c中才插入或构造元素。函数返回一个pair，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的bool值。对于multimap和multiset则会插入范围中的每个元素。 c.insert(b, e) c.insert(il) b和e是迭代器，表示一个c::value_type\u001b类型值的范围；il是这种值的花括号列表。函数返回void。对于 map和set，只插入关键字不在c中的元素。 c.insert(p, v) c.emplace(p, args) 类似insert(v)，但将迭代器p作为一个提示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素。 向map添加元素：\nword_count.insert({word, 1}); word_count.insert(make_pair(word, 1)); word_count.insert(pair\u0026lt;string, size_t\u0026gt;(word, 1)); word_count.insert(map\u0026lt;string, size_t\u0026gt;::value_type (word, 1)); 3、删除元素 从关联容器中删除元素：\n操作 解释 c.erase(k) 从c中删除每个关键字为k的元素。返回一个size_type值，指出删除的元素的数量。 c.erase(p) 从c中删除迭代器p指定的元素。p必须指向c中一个真实元素，不能等于c.end()。返回一个指向p之后元素的迭代器，若p指向c中的尾元素，则返回c.end() c.erase(b, e) 删除迭代器对b和e所表示范围中的元素。返回e。 4、下标操作 map和unordered_map的下标操作：\n操作 解释 c[k] 返回关键字为k的元素；如果k不在c中，添加一个关键字为k的元素，对其值初始化。 c.at(k) 访问关键字为k的元素，带参数检查；若k不存在在c中，抛出一个out_of_range异常。 set不支持下标操作，multimap也不支持 对map使用下标操作 关键字存在，返回mapped_type 关键字不存在，添加下标元素 5、查找元素 在一个关联容器中查找元素:\n操作 解释 c.find(k) 返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，则返回尾后迭代器 c.count(k) 返回关键字等于k的元素的数量。对于不允许重复关键字的容器，返回值永远是0或1。 c.lower_bound(k) 返回一个迭代器，指向第一个关键字不小于k的元素。 c.upper_bound(k) 返回一个迭代器，指向第一个关键字大于k的元素。 c.equal_range(k) 返回一个迭代器pair，表示关键字等于k的元素的范围。若k不存在，pair的两个成员均等于c.end()。 lower_bound和upper_bound不适用于无序容器。 下标和at操作只适用于非const的map和unordered_map。 四、无序容器 有序容器使用比较运算符来组织元素；无序容器使用哈希函数和关键字类型的==运算符。 理论上哈希技术可以获得更好的性能。 无序容器在存储上组织为一组桶(bucket)，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。 无序容器管理操作：\n操作 解释 桶接口 c.bucket_count() 正在使用的桶的数目 c.max_bucket_count() 容器能容纳的最多的桶的数目 c.bucket_size(n) 第n个桶中有多少个元素 c.bucket(k) 关键字为k的元素在哪个桶中 桶迭代 local_iterator 可以用来访问桶中元素的迭代器类型 const_local_iterator 桶迭代器的const版本 c.begin(n)，c.end(n) 桶n的首元素迭代器 c.cbegin(n)，c.cend(n) 与前两个函数类似，但返回const_local_iterator。 哈希策略 c.load_factor() 每个桶的平均元素数量，返回float值。 c.max_load_factor() c试图维护的平均比桶大小，返回float值。c会在需要时添加新的桶，以使得load_factor\u0026lt;=max_load_factor c.rehash(n) 重组存储，使得bucket_count\u0026gt;=n，且bucket_count\u0026gt;size/max_load_factor c.reverse(n) 重组存储，使得c可以保存n个元素且不必rehash。 ","pubDate":"2021-09-28","title":"【C++ Primer(edition 5) 09】关联容器"},{"link":"https://cnjslw.github.io/posts/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/","plain":"一、容器库概述 1、容器内元素的类型约束 使用 C++ 标准库容器存储元素时，对于元素类型有一些要求：\n元素类型必须支持复制语义，即可以使用赋值运算符（=）将一个元素赋值给另一个元素，这是因为标准库容器需要在内部存储和复制元素。 元素类型必须支持等价性，即可以使用等价比较运算符（==）比较两个元素是否相等，这是因为标准库容器需要支持查找和删除元素等操作。 对于不同的标准库容器，元素类型要求也不尽相同。例如，std::vector 和 std::deque 都是动态数组，但 std::vector 支持随机访问，而 std::deque 支持在队列首尾进行 O(1) 操作。因此，在使用容器时需要根据具体的需求来选择适当的容器类型。 总的来说，如果您的元素类型支持复制语义和等价性，那么它就可以作为标准库容器的元素类型。如果您的元素类型不支持复制语义和等价性，那么您可以使用 C++ 指针或其他技巧来将它存储在容器 2、容器操作 容器的操作分成三类：\n所有容器都提供的操作 按照顺序容器，关联容器，无序容器分类，分别提供不同的操作 一小部分容器提供的操作 ⚠️ 随后的表格中，列出了所有顺序容器的操作，某些不提供这些操作的容器，在表后有说明！\n2.1 类型别名 操作 解释 iterator 此容器类型的迭代器类型 const_iterator 可以读取元素但不能修改元素的迭代器类型 size_type 无符号整数类型，足够保存此种容器类型最大可能的大小 difference_type 带符号整数类型，足够保存两个迭代器之间的距离 value_type 元素类型 reference 元素的左值类型；和value_type \u0026amp;含义相同 const_reference 元素的const左值类型，即const value_type \u0026amp; 2.2 构造函数 操作 解释 C c; 默认构造函数，构造空容器 C c1(c2);或C c1 = c2; 构造c2的拷贝c1 C c(b, e) 构造c，将迭代器b和e指定范围内的所有元素拷贝到c C c{a, b, c...} 列表初始化c 只有顺序容器的构造函数才接受大小参数，关联容器并不支持。 array具有固定大小。 和其他容器不同，默认构造的array是非空的。 array可以拷贝和对象赋值 , 这一点与内置数组不同 直接复制：将一个容器复制给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同。 使用迭代器复制：不要求容器类型相同，容器内的元素类型也可以不同。 2.3 赋值和swap 操作 解释 c1 = c2; 将c1中的元素替换成c2中的元素 c1 = {a, b, c...} 将c1中的元素替换成列表中的元素（不适用于array） c1.swap(c2) 交换c1和c2的元素 swap(c1, c2) 等价于c1.swap(c2) c.assign(b, e) 将c中的元素替换成迭代器b和e表示范围中的元素，b和e不能指向c中的元素 c.assign(il) 将c中的元素替换成初始化列表il中的元素 c.assign(n, r) 将c中的元素替换为n个值是t的元素 2.3.1 赋值 赋值左右大小若不一致，则两边都和右边一致\n[[顺序容器#4.3 array的拷贝与对象赋值| array赋值操作]]\n使用非成员版本的swap是一个好习惯。 swap不会导致容器的指针,迭代器,引用,失效, 他们仍然指向或者引用之前所指向或引用的那些元素，但是已经属于不同的容器了\nassign操作不适用于关联容器和array\n2.3.2 使用assign （仅顺序容器） 顺序容器（array除外）还定义了一个名为assign的成员， 允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值，只要能转换\n1 2 3 4 5 6 7 8 9 10 list\u0026lt;string\u0026gt; names; vector\u0026lt;const char*\u0026gt; oldstyle; names = oldstyle; // 错误：容器类型不匹配 // 正确：可以将const char* 转换为 string names.assign(oldstyle.cbegin(), oldstyle.cend()); // 等价于slistl.clear(); // 后跟slistl.insert(slistl.begin(), 10, \u0026#34;Hiya!\u0026#34;); list\u0026lt;string\u0026gt; slistl (1) ; // 1个元素，为空 string slistl.assign (10, \u0026#34;Hiya!\u0026#34;) ; // 10个元素，每个都是\u0026#34;Hiya!\u0026#34; 2.3.3 使用swap swap操作交换两个相同类型容器的内容。调用swap之后，两个容器中的元素将会交换；\n1 2 vector\u0026lt;string\u0026gt; svecl (10) ; // 10 个元素的 vector vector\u0026lt;string\u0026gt; svec2 (24) ; // 24 个元素的 vector swap(svecl, svec2); 交换两个容器内容的操作保证会很快—— 元素本身并未交换，swap只是交换了两个 容器的内部数据结构 除 array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证生 在常数时间内完成，但是array会真正的交换 这也意味着，指向容器的迭代器、引用和指针在swap操作之后不会失效，仍旧指向之前的元素 例如：假定iter在 swap之前指向svec1 [3]的string,那么在swap之后它指向svec2 [3]的元素\n2.4 大小 操作 解释 c.size() c中元素的数目（不支持forward_list） c.max_size() c中可保存的最大元素数目 c.empty() 若c中存储了元素，返回false，否则返回true 2.5 添加元素/删除元素 操作 解释 c.insert(args) 将args中的元素拷贝进c c.emplace(init) 使用inits构造c中的一个元素 c.erase (args) 删除args指定的元素 c.clear() 删除c中的所有元素，返回void 2.6 获取迭代器 操作 解释 c.begin(), c.end() 返回指向c的首元素和尾元素之后位置的迭代器 c.cbegin(), c.cend() 返回const_iterator 以c开头的版本是C++11新标准引入的 当不需要写访问时，应该使用cbegin和cend。 2.7 反向容器的额外成员 操作 解释 reverse_iterator 按逆序寻址元素的迭代器 const_reverse_iterator 不能修改元素的逆序迭代器 c.rbegin(), c.rend() 返回指向c的尾元素和首元素之前位置的迭代器 c.crbegin(), c.crend() 返回const_reverse_iterator 不支持forward_list 2.8 关系运算符 操作 解释 == != 所有容器都支持相等（不等）运算符 \u0026lt; , \u0026lt; = , \u0026gt; , \u0026gt; = 关系运算符（无序关联容器不支持） 关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素，比较两个容器实际上是进行元素的逐对比较 graph LR s[比较] s--\u0026gt;c_1[不相等:元素个数不同] s--\u0026gt;c_2[相等:元素个数和元素大小都相等] c_1--\u0026gt;c_2_1[存在包含关系,比个数] c_1--\u0026gt;c_2_2[有交集不包含,比较第一个不等的元素] 所谓元素的大小：容器的关系运算符使用元素的关系运算符完成比较\n2.9 迭代器 什么是迭代器？ 在 C++ 中，迭代器是一个对象，它提供了在容器（如数组、链表等）中遍历元素的方法。通俗地说，迭代器就像是容器中的一个指针，可以通过迭代器来访问容器中的元素，比如获取、修改、插入元素等。 C++ 中的迭代器类型分为五种：输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器。每种类型的迭代器都有不同的功能和性能，例如，随机访问迭代器支持 O(1) 的随机访问，而输入迭代器仅支持递增的遍历。 使用迭代器的好处是，它可以使代码变得更加简洁和可移植，因为迭代器抽象了对容器的遍历，从而使得代码对容器的具体实现细节更加独立。\n迭代器\nforward_list , list 不支持迭代器的算数运算 迭代器范围：begin到end，即第一个元素到最后一个元素的后面一个位置。 左闭合区间：[begin, end) 左闭合范围蕴含的编程设定： 如果begin和end相等，则范围为空。 如果二者不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素。 可以对begin递增若干次，使得begin == end。 2.10 容器定义和初始化 ![[Pasted image 20230211004318.png]]\n2.10.1 利用拷贝初始化 1. 拷贝整个容器 两个容器的类型及其元素类型必须匹配\n2. 拷贝由一个迭代器对指定的元素范围 当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换 为要初始化的容器的元素类型即可\n1 2 3 4 5 6 7 //每个容器有三个元素，用给定的初始化器进行初始化 list\u0026lt;string\u0026gt; authors = {\u0026#34;Milton\u0026#34;, \u0026#34;Shakespeare\u0026#34;, \u0026#34;Austen\u0026#34;}; vector\u0026lt;const char*\u0026gt; articles = {\u0026#34;a\u0026#34;, \u0026#34;an\u0026#34;， \u0026#34;the\u0026#34;}; list\u0026lt;string\u0026gt; list2(authors); // 正确 类型匹配 deque\u0026lt;string\u0026gt; authList (authors) ; // 错误 容器类型不匹配 vector\u0026lt;string\u0026gt; words (articles) ; // 错误 容器类型必须匹配 // 正确：可以将const char*元素转换为string forward_list\u0026lt;string\u0026gt; words(articles.begin(), articles.end()); 2.10.2 列表初始化 1 2 list\u0026lt;string\u0026gt; authors = {\u0026#34;Milton\u0026#34; , \u0026#34;Shakespeare\u0026#34;, \u0026#34;Austen\u0026#34;}; vector\u0026lt;const char*\u0026gt; articles = {\u0026#34;a\u0026#34;， \u0026#34;an\u0026#34;, \u0026#34;the\u0026#34;}; 对于除array之外的容器类型, 初始化列表还隐含地指定了容器的大小：容器将包含与初始值一样多的元素\n2.10.3 顺序容器特有的构造函数 除了与关联容器相同的构造函数外，顺序容器（array除外）还提供另一个构造函数, 它接受一个容器大小和一个（可选的）元素初始值。如果我们不提供元素初始值，则标准库会创建一个值初始化器\n1 2 3 4 vector\u0026lt;int\u0026gt; ivec(10,-1); list\u0026lt;string\u0026gt; svec(10,\u0026#34;hi!\u0026#34;); forward_list\u0026lt;int\u0026gt; ivec(10); //10个元素，初始为0 deque\u0026lt;string\u0026gt; svec(10); //10个元素，初始化为空 如果元素类型是类类型，只有当该类有默认构造函数才能不指定初始值，否则必须显示初始化\n二、顺序容器 顺序容器（sequential container）：顺序容器都提供了快速顺序访问元素的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。\n1、顺序容器类型 容器类型 介绍 vector 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。 deque 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。 list 双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快。 forward_list 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。 array 固定大小数组。支持快速随机访问。不能添加或者删除元素。 string 与vector相似的容器，但专门用于保存字符。随机访问块。在尾部插入/删除速度快。 除了固定大小的array外，其他容器都提供高效、灵活的内存管理。 forward_list和array是新C++标准增加的类型。 通常使用vector是最好的选择，除非你有很好的理由选择其他容器。 每个容器都定义在一个头文件中，文件名与类型名相同，容器均定义为模板类，按照[[模板与泛型编程|模板]]的使用规则来使用 新标准库的容器比旧版的快得多。 2、顺序容器操作 2.1 添加元素 操作 解释 c.push_back(t) 在c尾部创建一个值为t的元素，返回void c.emplace_back(args) 同上 c.push_front(t) 在c头部创建一个值为t的元素，返回void c.emplace_front(args) 同上 c.insert(p, t) 在迭代器p指向的元素之前创建一个值是t的元素，返回指向新元素的迭代器 c.emplace(p, args) 同上 c.insert(p, n, t) 在迭代器p指向的元素之前插入n个值为t的元素，返回指向第一个新元素的迭代器；如果n是0，则返回p c.insert(p, b, e) 将迭代器b和e范围内的元素，插入到p指向的元素之前；如果范围为空，则返回p c.insert(p, il) il是一个花括号包围中的元素值列表，将其插入到p指向的元素之前；如果il是空，则返回p 因为这些操作会改变大小，因此不适用于array。\nforward_list有自己专有版本的insert和emplace。\nforward_list不支持push_back和emplace_back。\nvector 和 string 不支持 push_front 和 emplace_front\n当我们用一个对象去初始化容器或者将对象插入到容器时，实际上放入的是对象的拷贝。\nemplace开头的函数是新标准引入的，这些操作是构造而不是拷贝元素。将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素\n1 c.emplace_back(\u0026#34;978-0590353403 \u0026#34;, 25, 15.99); 传递给emplace的参数必须和元素类型的构造函数相匹配。 2.2 访问元素 操作 解释 c.back() 返回c中尾元素的引用。若c为空，函数行为未定义 c.front() 返回c中头元素的引用。若c为空，函数行为未定义 c[n] 返回c中下标是n的元素的引用，n时候一个无符号证书。若n\u0026gt;=c.size()，则函数行为未定义 c.at(n) 返回下标为n的元素引用。如果下标越界，则抛出out_of_range异常 访问成员函数返回的是引用。 at和下标操作只适用于string、vector、deque、array。 back不适用于forward_list。 如果希望下标是合法的，可以使用at函数。 2.3 删除元素 操作 解释 c.pop_back() 删除c中尾元素，若c为空，则函数行为未定义。函数返回void c.pop_front() 删除c中首元素，若c为空，则函数行为未定义。函数返回void c.erase(p) 删除迭代器p指向的元素，返回一个指向被删除元素之后的元素的迭代器，若p本身是尾后迭代器，则函数行为未定义 c.erase(b, e) 删除迭代器b和e范围内的元素，返回指向最后一个被删元素之后元素的迭代器，若e本身就是尾后迭代器，则返回尾后迭代器 c.clear() 删除c中所有元素，返回void 会改变容器大小，不适用于array。 forward_list有特殊版本的erase forward_list不支持pop_back vector和string不支持pop_front 2.4 特殊的forward_list操作 链表在删除元素时需要修改前置节点的内容，双向链表会前驱的指针，但是单向链表没有保存，因此需要增加获取前置节点的方法。 forward_list定义了before_begin，即首前（off-the-begining）迭代器，允许我们再在首元素之前添加或删除元素。 操作 解释 lst.before_begin() 返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用。 lst.cbefore_begin() 同上，但是返回的是常量迭代器。 lst.insert_after(p, t) 在迭代器p之后插入元素。t是一个对象 lst.insert_after(p, n, t) 在迭代器p之后插入元素。t是一个对象，n是数量。若n是0则函数行为未定义 lst.insert_after(p, b, e) 在迭代器p之后插入元素。由迭代器b和e指定范围。 lst.insert_after(p, il) 在迭代器p之后插入元素。由il指定初始化列表。 emplace_after(p, args) 使用args在p之后的位置，创建一个元素，返回一个指向这个新元素的迭代器。若p为尾后迭代器，则函数行为未定义。 lst.erase_after(p) 删除p指向位置之后的元素，返回一个指向被删元素之后的元素的迭代器，若p指向lst的尾元素或者是一个尾后迭代器，则函数行为未定义。 lst.erase_after(b, e) 类似上面，删除对象换成从b到e指定的范围。 2.5 改变容器的大小 操作 解释 c.resize(n) 调整c的大小为n个元素，若n\u0026lt;c.size()，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化 c.resize(n, t) 调整c的大小为n个元素，任何新添加的元素都初始化为值t resize不适用与array 3、容器操作可能使迭代器失效 在向容器添加元素后： 如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、指针、引用都会失效。 对于deque，插入到除首尾位置之外的任何位置都会导致指向容器的迭代器、指针、引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在元素的引用和指针不会失效。 对于list和forward_list，指向容器的迭代器、指针和引用依然有效。 在从一个容器中删除元素后： 对于list和forward_list，指向容器其他位置的迭代器、引用和指针仍然有效。 对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、指针、引用都会失效；如果是删除deque的尾元素，则尾后迭代器会失效，但其他不受影响；如果删除的是deque的头元素，这些也不会受影响。 对于vector和string，指向被删元素之前的迭代器、引用、指针仍然有效。 注意：当我们删除元素时，尾后迭代器总是会失效。 注意：使用失效的迭代器、指针、引用是严重的运行时错误！ 建议：将要求迭代器必须保持有效的程序片段最小化。 建议：不要保存end返回的迭代器。 4、array 4.1 array 定义 与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时， 除了指定元素类型，还要指定容器大小\n1 2 3 4 5 6 array\u0026lt;int , 42\u0026gt; array\u0026lt;string, 10\u0026gt; //通过类型别名获得元素类型 array\u0026lt;int ,10\u0026gt;::size_type i ; array\u0026lt;int\u0026gt;::size_type j ; //wrong 4.2 array 初始化 4.2.1 默认初始化 array默认初始化包含和定义中一样多的元素，元素的值都被默认初始化，而非空，这一点与其他顺序容器不同\n4.2.2 列表初始化 如果我们对array进行列表初始化，初始值的数目必须等于或小于array的大小 如果元素类型是类类型，那么就一定要有可以值初始化的构造函数\n4.3 array的拷贝与对象赋值 array不同于内置数组类型，可以拷贝或对象赋值\n1 2 3 4 int digs[10] = {0,1,2,3,4,5,6,7,8,9}; int cpy[10] = digs; //错误，内置数组不能拷贝和赋值 array\u0026lt;int, 10\u0026gt; digits = {0,1,2,3,4,5,6,7,8,91}; array\u0026lt;int, 10\u0026gt; copy = digits; // 正确: 只要数组类型匹配即合法 两个限制：1.初始值类型一致 ； 2.大小必须一样\n三、vector对象是如何增长的 vector和string在内存中是连续保存的，如果原先分配的内存位置已经使用完，则需要重新分配新空间，将已有元素从就位置移动到新空间中，然后添加新元素。\nvector是如何扩容的 当不得不获取新的内存空间时，vector和 string的实现通常会分配比新的空间需求更大 的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。\n管理容量的成员函数 vector和 string类型提供了一些成员函数，允许我们与它的实现中内存分配部分互动\n操作 解释 c.shrink_to_fit() 将capacity()减少到和size()相同大小 c.capacity() 不重新分配内存空间的话，c可以保存多少个元素 c.reverse(n) 分配至少能容纳n个元素的内存空间 shrink_to_fit只适用于vector、string和deque capacity和reverse只适用于vector和string。 1 2 3 4 ivec.reserve (50) ; // 将 capacity至少设定为50,可能会更大 //size应该为24; capacity应该大于等于50,具体值依赖于标准库实现 cout\u0026lt;\u0026lt;\u0026#34;ivec: size: \u0026#34;\u0026lt;\u0026lt;ivec.size() \u0026lt;\u0026lt; \u0026#34;capacity: \u0026#34; \u0026lt;\u0026lt; ivec.capacity() \u0026lt;\u0026lt; endl; 总结一哈 只要size不超过capacity就不重新分配，reserve可以要求每次扩容，不少于reserve的实参，但是如果实参也满足不了，就会超过这个值，shrink_to_fit只是一个请求，并非一定会执行\n四、额外的string操作 string操作\n1、构造string的其他方法 ^5f2418\n操作 解释 string s(cp, n) s是cp指向的数组中前n个字符的拷贝，此数组 string s(s2, pos2) s是string s2从下标pos2开始的字符的拷贝。若pos2 \u0026gt; s2.size()，则构造函数的行为未定义。 string s(s2, pos2, len2) s是string s2从下标pos2开始的len2个字符的拷贝。 n,len2,pos2都是无符号值 这些构造函数接受const char* 和string参数 , 当从const char *创建string时,这样的数组必须以空字符结尾拷贝，操作遇到空字符时停止，如果我们还给构造函数一个计数值，数组就不必以空字符结尾。 substr操作\n操作 解释 s.substr(pos, n) 返回一个string，包含s中从pos开始的n个字符的拷贝。pos的默认值是0，n的默认值是s.size() - pos，即拷贝从pos开始的所有字符。 2、改变string的其他方法 操作 解释 s.insert(pos, args) 在pos之前插入args指定的字符。pos可以使是下标或者迭代器。接受下标的版本返回指向s的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。 s.erase(pos, len) 删除从pos开始的len个字符，如果len被省略，则删除后面所有字符，返回指向s的引用。 s.assign(args) 将s中的字符替换成args指定的字符。返回一个指向s的引用。 s.append(args) 将args指定的字符追加到s，返回一个指向s的引用。 s.replace(range, args) 删除s中范围range中的字符，替换成args指定的字符。返回一个指向s的引用。 3、string搜索操作 string类提供了6个不同的搜索函数，每个函数都有4个重载版本。 每个搜索操作都返回一个string::size_type值，表示匹配发生位置的下标。如果搜索失败则返回一个名为string::npos的static成员（类型是string::size_type，初始化值是-1，也就是string最大的可能大小）。 搜索操作 解释 s.find(args) 查找s中args第一次出现的位置 s.rfind(args) 查找s中args最后一次出现的位置 s.find_first_of(args) 在s中查找args中任何一个字符第一次出现的位置 s.find_last_of(args) 在s中查找args中任何一个字符最后一次出现的位置 s.find_first_not_of(args) 在s中查找第一个不在args中的字符 s.find_first_not_of(args) 在s中查找最后一个不在args中的字符 args必须是一下的形式之一：\nargs形式 解释 c, pos 从s中位置pos开始查找字符c。pos默认是0 s2, pos 从s中位置pos开始查找字符串s。pos默认是0 cp, pos 从s中位置pos开始查找指针cp指向的以空字符结尾的C风格字符串。pos默认是0 cp, pos, n 从s中位置pos开始查找指针cp指向的前n个字符。pos和n无默认值。 4、compare函数 逻辑类似于C标准库的strcmp函数，根据s是等于、大于还是小于参数指定的字符串，s.compare返回0、正数或负数。\ns.compare()的几种参数形式\n参数形式 解释 s2 比较s和s2 pos1, n1, s2 比较s从pos1开始的n1个字符和s2 pos1, n1, s2, pos2, n2 比较s从pos1开始的n1个字符和s2 cp 比较s和cp指向的以空字符结尾的字符数组 pos1, n1, cp 比较s从pos1开始的n1个字符和cp指向的以空字符结尾的字符数组 pos1, n1, cp, n2 比较s从pos1开始的n1个字符和cp指向的地址开始n2个字符 5、string和数值转换 转换 解释 to_string(val) 一组重载函数，返回数值val的string表示。val可以使任何算术类型。对每个浮点类型和int或更大的整型，都有相应版本的to_string()。和往常一样，小整型会被提升。 stoi(s, p, b) 返回s起始子串（表示整数内容）的数值，p是s中第一个非数值字符的下标，默认是0，b是转换所用的基数。返回int stol(s, p, b) 返回long stoul(s, p, b) 返回unsigned long stoll(s, p, b) 返回long long stoull(s, p, b) 返回unsigned long long stof(s, p) 返回s起始子串（表示浮点数内容）的数值，p是s中第一个非数值字符的下标，默认是0。返回float stod(s, p) 返回double stold(s, p) 返回long double 五、容器适配器（adapter） 1、什么是适配器 C++ 中的适配器是指一种对标准库容器或其他数据结构进行包装或修饰的结构，以提供不同的接口或行为。适配器在 C++ 中被广泛用于容器库中，可以简化程序代码，提高代码可读性和可维护性。 C++ 标准库提供了以下几种适配器：\nstd::stack：使用底层容器作为栈，提供了一个顶部的元素访问接口，支持 push 和 pop 操作。 std::queue：使用底层容器作为队列，提供了一个队列头部的元素访问接口，支持入队和出队操作。 std::priority_queue：使用底层容器作为优先队列，提供了一个优先级最高的元素访问接口，支持入队和出队操作。 2、适配器的通用操作和类型 操作 解释 size_type 一种类型，须以保存当前类型的最大对象的大小 value_type 元素类型 container_type 实现适配器的底层容器类型 A a; 创建一个名为a的空适配器 A a(c) 创建一个名为a的适配器，带有容器c的一个拷贝 关系运算符 每个适配器都支持所有关系运算符：==、!=、\u0026lt;、 \u0026lt;=、\u0026gt;、\u0026gt;=这些运算符返回底层容器的比较结果 a.empty() 若a包含任何元素，返回false;否则返回true a.size() 返回a中的元素数目 swap(a, b) 交换a和b的内容，a和b必须有相同类型，包括底层容器类型也必须相同 a.swap(b) 同上 可以使用适配器操作，而不能使用底层容器类型的操作。 3、定义一个适配器 stack和queue是基于deque实现的，priority_queue是在vector之上实现的，可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型\n1 2 3 4 // 在 vector _h实现的空栈 stack\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; str_stk; // str_stk2在vector上实现，初始化时保存svec的拷贝 stack\u0026lt;string, vector\u0026lt;string\u0026gt;str_stk2(svec); 每个适配器都定义两个构造函数 1.默认构造函数创建一个空对象\n1 stack\u0026lt;int\u0026gt; s; 2.接受一个容器的构造函数拷贝该容器来初始化适配器\n1 2 //假定deq是一个deque\u0026lt;int\u0026gt; stack\u0026lt;int\u0026gt; stk(deq); 4、stack 操作 解释 s.pop() 删除栈顶元素，不返回。 s.push(item) 创建一个新元素，压入栈顶，该元素通过拷贝或移动item而来 s.emplace(args) 同上，但元素由args来构造。 s.top() 返回栈顶元素，不删除。 定义在stack头文件中。 stack默认基于deque实现，也可以在list或vector之上实现。 5、queue和priority_queue 操作 解释 q.pop() 删除队首元素，但不返回。 q.front() 返回队首元素的值，不删除。 q.back() 返回队尾元素的值，不删除。只适用于queue q.top() 返回具有最高优先级的元素值，不删除。 q.push(item) 在队尾压入一个新元素。 q.emplace(args) 定义在queue头文件中。 queue默认基于deque实现，priority_queue默认基于vector实现。 queue可以在list或vector之上实现，priority_queue也可以用deque实现。 ","pubDate":"2021-09-25","title":"【C++ Primer(edition 5) 08】顺序容器"},{"link":"https://cnjslw.github.io/posts/%E7%B1%BB/","plain":" 类背后的基本思想：数据抽象（data abstraction）和封装（encapsulation）。 数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程技术。 封装实现了类的接口和实现的分离 一、定义抽象数据类型 1 2 3 class CLASSNAME{ //类成员 }; 1、类成员 （Member） 必须在类的内部声明，不能在其他地方增加成员。 成员可以是数据，函数，类型别名。 使用点运算符 . 调用成员函数 1.1 类的成员函数 成员函数的声明必须在类的内部。 成员函数的定义既可以在类的内部也可以在外部。 1 2 3 4 5 6 7 8 class ClassExample{ //... double avg_price() const; }; double ClassExample::avg_price() const{ //... } 必须对任何const或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。\n默认实参： Sales_item(const std::string \u0026amp;book): isbn(book), units_sold(0), revenue(0.0) { } 1.2 非成员函数 和类相关的非成员函数，定义和声明都应该在类的外部。\n1.3 常成员 1.3.1 常成员函数 若将成员函数设置为常成员函数，则只能引用本类中的数据成员，而不能修改它；常成员函数可以引用const数据成员，也可以引用非const的数据成员；常成员函数的一般形式为：\n1 类型名 函数名(形参列表) const 这里的const关键字是函数类型的一部分，在函数声明和函数定义时都要带const关键字，否则被编译器认为是不同的两个函数，但是在函数调用的时候不必带const；\n1 bool same_isbn(const Sales_item \u0026amp;rhs) const 这种函数称为“常量成员函数”（this指向的当前对象是常量）。\n这样做的好处是\n既可以将this绑定到常量对象上，也可以绑定到普通对象上（[[变量和基本类型#3、指针和const|指针与const的特殊性]]），提高了函数的灵活性 程序是安全的 ⚠️C++ 中常对象只能调用类中的常方法，但是常成员方法可以使用非常量数据成员 这是正确的。常对象是不能修改对象状态的，因此只能调用类中标记为常的方法，即常方法。如果试图调用非常方法，编译器会生成错误。因此，常对象可以保证对象状态不会被意外修改。常成员函数可以引用const数据成员，也可以引用非const的数据成员\n1 2 3 4 5 6 7 8 9 10 11 12 13 class A { public: A(){} void test1(){} void test2()const{} }; const A a; A b; a.test1(); //× a.test2(); //√ b.test1(); //√ b.test2(); //√ 常方法返回的任何值都具有常性 常方法返回的任何值都具有常性，不论是指针还是引用。这意味着，不能通过常方法返回的指针或引用来修改对象的值。然而，非常量方法则允许通过其返回的指针或引用来修改对象的值。\n1.3.2 常数据成员 如果我们希望在创建对象后，该对象的某个数据成员就保持不变，我们可以将这个数据成员设置为常数据成员；常数据成员只能通过构造函数初始化列表进行初始化，其他形式的函数均不能进行数据的赋值；\n数据成员 非const的普通成员函数 const成员函数 非const的普通数据成员 可以引用，也可以改变值 可以引用，但是不可以改变值 const数据成员 可以引用，但是不能改变值 可以引用，但是不可以改变值 const对象 不允许 可以引用，但是不可以改变值 1.4 this 每个成员函数都有一个额外的，隐含的形参this。 this总是指向当前对象，因此this是一个常量指针。 return *this;可以让成员函数连续调用。 1 2 3 4 5 6 Sale_data \u0026amp;Sales_data::combine(const Sales_data \u0026amp;rhs) { units_sold += rhs.units_sold; // revenue += rhs.revenue; return *this; } 形参表后面的const，改变了隐含的this形参的类型，如普通成员函数中的this类型为 CLASSNAME *const，而当声明常量成员函数后this类型为 const CLASSNAME *const\n普通的非const成员函数：this是指向类类型的const指针（可以改变this所指向的值，不能改变this保存的地址）。 const成员函数：this是指向const类类型的const指针（既不能改变this所指向的值，也不能改变this保存的地址）。 1.5 类的静态成员 非static数据成员存在于类类型的每个对象中。 static数据成员独立于该类的任意对象而存在。 每个static数据成员是与类关联的对象，并不与该类的对象相关联。\n声明 声明之前加上关键词static。\n使用 使用作用域运算符::直接访问静态成员:r = Account::rate(); 也可以使用对象访问：r = ac.rate();\n定义 在类外部定义时不用加static\n初始化 静态数据成员通常不在类的内部初始化，而是在定义时进行初始化，如 double Account::interestRate = initRate(); 如果一定要在类内部定义，则要求必须是字面值常量类型的constexpr。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Account ( public: void calculate() ( amount += amount * interestRate; ) static double rate() ( return interestRate; } static void rate(double); private: std::string owner; double amount； static double interestRate; static double initRate(); }; //静态成员函数的内外定义 void Account::rate(double newRate) {interestRate = newRate;} //静态数据成员的定义 double Account::interestRate = initRate(); //可以直接访问私有成员函数 double r ; r = Account::rate(); Account ac1; Account *ac2 = \u0026amp;ac1; r = ac1.rate(); r=ac2-\u0026gt;rate(); interestRate被所有Account对象共享 rate不包含this指针，不能声明成const 2、类的构造函数 类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。\n构造函数是特殊的成员函数。 构造函数放在类的public部分。 与类同名的成员函数。 2.1 默认构造函数 类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数(default constructor)，默认构造函数无须任何实参。编译器创建的构造函称为合成的默认构造函数。只有当类没有构造函数时，编译器才会这样做。 默认构造函数按照如下规则初始化类\n如果类内存在成员的初始值，则用它来初始化成员\n否则，默认初始化成员\n=default要求编译器合成默认的构造函数。(C++11)\n2.2 构造函数初始值列表 1 Sales_item(const std::string \u0026amp;s):bookNo(s),units_sold(0), revenue(0.0) { } 总之，没有出现在构造函数初始值列表中的成员将通过相应的类内初始值（如果存在）初始化，或者执行默认初始化\n1. const、引用类型的成员初始化 但还需要注意一个问题，有些时候有成员是必须通过初始值列表来初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class ConstRef{ public: ConstRef(int ii); private: int i ; const int ci; int \u0026amp;ri; } ConstRef::ConstRef(int ii) { i=ii; ci=ii; //WRONG ri=i; //WRONG } 随着构造函数体一开始执行，初始化就完成了!! 初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值\n1 ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) { } 2. 初始化顺序问题 构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序，执行顺序与其在类定义中出现的顺序一致 ^172c2c\n1 2 3 4 5 6 class X{ int i; int j; public: X(int val):j(val),i(j){} //真实的顺序为先初始化i，然后j，所以报错 } 2.3 委托构造函数 （delegating constructor, C++11） 委托构造函数将自己的职责委托给了其他构造函数。\nSale_data(): Sale_data(\u0026quot;\u0026quot;, 0, 0) {}\n2.4 转换构造函数 如果类的构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，这种构造函数成为转换构造函数\n在Sales_data类中，接受string的构造函数和接受istream的构造函数分别定义了从这面一种类型向Sales_data隐式转换的规则。 也就是说，在需要使用 Sales_data的地方，我们可以使用string或者istream作为替代：\n1 2 3 4 string null_book = \u0026#34;9-999-99999-9”; //构造一个临时的Sales_data时象 // 该时象的 units_sold 和 revenue 等于 0, bookNo 等于 null_book item.combine(null_book); 在这里我们用一个string实参调用了 Sales_data的combine成员。该调用是合法 的，编译器用给定的string自动创建了一个Sales_data对象。新生成的这个(临时) Sales_data对象被传递给combine。因为combine的参数是一个常引用，所以我们可以给该参数传递一个临时量\n但是只允许一步类类型转换\n1 item.combine(\u0026#34;9-999-99999-9”); 这种就是错误的，因为暗含了两种类型的转换，\u0026ldquo;9-999-99999-9”转换为string，string转换为Sales_data\n1 2 item.combine(string(\u0026#34;9-999-99999-9”)); item.combine(Sales_data(\u0026#34;9-999-99999-9”)); explicit抑制构造函数定义的隐式转换\n使用关键词explicit，有以下限制：\n只对一个实参的构造函数有效 只能在类内声明构造函数时使用关键字，类外部定义时不应重复 只能阻止隐式转换，但是不能阻止显示转换 只能用于直接初始化，不能用于拷贝形式的初始化。 1 2 3 4 5 6 7 8 class Salesdata { public: Sales_data() = default； Sales data (const std::string \u0026amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) { ) explicit Sales_data(const std::string \u0026amp;s):bookNo(s) { } explicit Sales_data(std::istream\u0026amp;); }； 1 2 3 4 string null_book(\u0026#34;999-999-999999\u0026#34;); Sales_data it item(null_book) ;\t// 正确：直接初始化 //错误：不能将explicit构造函数用于拷贝形式的初始化过程 Sales data item2 = null_book; 1 2 3 4 //正确：实参是一个显式构造的Sales_data对象 item.combine(Sales_data(null_book)); //正确：static_cast可以使用explicit的构造函数 item.combine(static cast\u0026lt;Sales data\u0026gt;(cin)); 3、拷贝构造函数 todo\n4、赋值函数 todo\n5、析构函数 当对象不在存在执行销毁操作，销毁的操作由类的析构函数完成\n6、关于构造、拷贝、赋值、析构函数的总结和深入 这四种成员函数，编译器会在没有定义时，生成默认构造、拷贝、赋值、析构函数 有些类不能依赖编译器生成的版本，因为这是不安全的 7、对象 对象是类的实例化，分为普通对象和常对象 定义普通对象的方法\n1 2 ClassName a; ClassName *a = new ClassName; 常对象是指该对象在其生命周期内，其所有的数据成员的值都不能被改变；定义对象时加上关键字const，该对象就是常对象，其一般形式如下：\n1 2 3 4 5 类名 const 对象名[(实参类别)]; 或者 const 类名 对象名[(实参类别)]; const CComplex num; 对象可以用.来访问成员 指向对象的指针用-\u0026gt;来访问成员 二、 聚合类 （aggregate class） 满足以下所有条件： 所有成员都是public的。 没有定义任何构造函数。 没有类内初始值。 没有基类，也没有virtual函数。 可以使用一个花括号括起来的成员初始值列表，初始值的顺序必须和声明的顺序一致。 1 2 3 4 5 6 struct Data{ int ival; string s; }; Data val1={0,\u0026#34;Anna\u0026#34;}; 如果初始值列表中的元素个 数少于类的成员数量，则靠后的成员被值初始化。 初始值列表的元素个数绝对不能超过类的成员数量。 C++中引入聚合类的主要原因是为了方便地对一组相关的数据进行组织和管理。聚合类可以看作是一个数据容器，它把多个数据成员封装在一起，形成一个单独的数据单元，从而更加方便地使用这些数据。通过将相关的数据成员放在同一个聚合类中，我们可以更好地组织代码，提高代码的可读性和可维护性。此外，聚合类还可以减少代码量，避免出现过多的全局变量或结构体定义，从而使代码更加简洁、易于理解和维护。另外，聚合类也为C++的面向对象编程提供了一种新的方式。通过定义成员函数和重载操作符等方法，我们可以对聚合类进行更加灵活和方便的操作，实现更优雅的代码设计。最后，值得注意的是，虽然聚合类和结构体看起来很相似，但它们在语义上有所不同。聚合类更强调对数据的组织和封装，而结构体则更强调对数据的描述和表示。因此，在选择使用聚合类还是结构体时，需要根据具体的应用场景和需要进行选择。\n一个比较典型的必须要使用聚合类的场景是数据库中的数据表。在实际开发中，我们通常需要使用一种数据结构来表示数据库中的数据表，这个数据结构需要包含每一行数据的各个字段，以及相关的属性和方法。对于这种情况，使用聚合类可以非常方便地组织和管理数据表中的数据。我们可以将每一行数据看作是一个对象，把所有行对象放在同一个聚合类中，形成一个数据表对象。这个聚合类可以包含各种成员函数和操作符重载，用于实现数据表的各种查询、排序、更新等操作。\n三、 字面值常量类 constexpr函数的参数和返回值必须是字面值。 字面值类型：除了算术类型、引用和指针外，某些类也是字面值类型。 数据成员都是字面值类型的聚合类是字面值常量类。 如果不是聚合类，则必须满足下面所有条件： 数据成员都必须是字面值类型。 类必须至少含有一个constexpr构造函数。 如果一个数据成员含有类内部初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。 类必须使用析构函数的默认定义，该成员负责销毁类的对象。 四、访问控制与封装 访问说明符（access specifiers）： public：定义在 public后面的成员在整个程序内可以被访问； public成员定义类的接口。 private：定义在 private后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； private隐藏了类的实现细节。 使用 class或者 struct：都可以被用于定义一个类。唯一的却别在于访问权限。 使用 class：在第一个访问说明符之前的成员是 priavte的。 使用 struct：在第一个访问说明符之前的成员是 public的。 1、友元 允许特定的非成员函数访问一个类的私有成员. 友元的声明以关键字 friend开始。 friend Sales_data add(const Sales_data\u0026amp;, const Sales_data\u0026amp;);表示非成员函数add可以访问类的非公有成员。 通常将友元声明成组地放在类定义的开始或者结尾。 类之间的友元： 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。 2、封装的益处 确保用户的代码不会无意间破坏封装对象的状态。 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。 五、类的其他特性 成员函数作为内联函数 inline： 在类的内部，常有一些规模较小的函数适合于被声明成内联函数。 定义在类内部的函数是自动内联的。 在类外部定义的成员函数，也可以在声明时显式地加上 inline。 可变数据成员 （mutable data member）： mutable size_t access_ctr; 永远不会是const，即使它是const对象的成员。 类类型： 每个类定义了唯一的类型。 六、类的作用域 每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。 函数的返回类型通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。 如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。 类中的类型名定义都要放在一开始。 ","pubDate":"2021-09-20","title":"【C++ Primer(edition 5) 07】类"},{"link":"https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0/","plain":"一、函数基础 函数定义：函数是一个命名了的代码块。 编写函数：包括返回类型、函数名字和0个或者多个形参（parameter）组成的列表和函数体。 调用运算符调用函数：调用运算符的形式是一对圆括号 ()，作用于一个表达式，该表达式是函数或者指向函数的指针。 圆括号内是用逗号隔开的实参（argument）列表。 函数调用过程： 1.主调函数（calling function）的执行被中断。 2.被调函数（called function）开始执行。 形参和实参：形参和实参的个数和类型必须匹配上。 返回类型： void表示函数不返回任何值。函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。 名字：名字的作用于是程序文本的一部分，名字在其中可见。 1、局部对象 生命周期：对象的生命周期是程序执行过程中该对象存在的一段时间。 局部变量（local variable）：形参和函数体内部定义的变量统称为局部变量。它对函数而言是局部的，对函数外部而言是隐藏的。 自动对象：只存在于块执行期间的对象。当块的执行结束后，它的值就变成未定义的了。 局部静态对象： static类型的局部变量，生命周期贯穿函数调用前后。 2、函数声明 函数声明：函数的声明和定义唯一的区别是声明无需函数体，用一个分号替代。函数声明主要用于描述函数的接口，也称函数原型。 在头文件中进行函数声明：建议变量在头文件中声明；在源文件中定义。 分离编译： CC a.cc b.cc直接编译生成可执行文件；CC -c a.cc b.cc编译生成对象代码a.o b.o； CC a.o b.o编译生成可执行文件。 二、参数传递 形参初始化的机理和变量初始化一样。 引用传递（passed by reference）：又称传引用调用（called by reference），指形参是引用类型，引用形参是它对应的实参的别名。 值传递（passed by value）：又称传值调用（called by value），指实参的值是通过拷贝传递给形参。 1、传值参数 当初始化一个非引用类型的变量时，初始值被拷贝给变量。 函数对形参做的所有操作都不会影响实参。 指针形参：常用在C中，C++建议使用引用类型的形参代替指针。 2、传引用参数 通过使用引用形参，允许函数改变一个或多个实参的值。 引用形参直接关联到绑定的对象，而非对象的副本。 使用引用形参可以用于返回额外的信息。 经常用引用形参来避免不必要的复制。 void swap(int \u0026amp;v1, int \u0026amp;v2) 如果无需改变引用形参的值，最好将其声明为常量引用。 3、const形参和实参 形参的顶层const被忽略。void func(const int i);调用时既可以传入const int也可以传入int。 我们可以使用非常量初始化一个底层const对象，但是反过来不行。 在函数中，不能改变实参的局部副本。 尽量使用常量引用。 4、数组形参 4.1 数组形参的定义 因为不能拷贝数组，所以无法以值传递的方式使用数组参数，因为数组会转换成指针，所以当为函数传递一个数组时，实际上传递的是指向数组首元素的指针\n1 2 3 4 5 6 7 8 9 void print(const int *); void print(const int[]); void print(const int[10]); //这里的10只是期望数组含有多少元素，实际不一定 //三种print函数声明等价,形参都是const int* 类型 int i = 0 , j[2] = {0,1}; print(\u0026amp;i); print(j); 4.2 数组形参的越界问题 要注意在函数中使用数组时，不能越界。管理指针形参有三种常用的技术。\n1. 使用标记指定的数组长度 管理数据实参的第一个方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。C风格的是字符串是以\\0为结束的，函数在处理C风格字符串时，遇到空字符停止\n1 2 3 4 5 6 void print(const char *cp) { if(cp) //非空指针 while(*cp) //非空字符 count \u0026lt;\u0026lt; *cp++; } 2.使用标准库规范 管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针\n1 2 3 4 5 6 7 8 void print(const int *beg , const int *end) { while(beg != end) cout \u0026lt;\u0026lt;*beg++\u0026lt;\u0026lt;endl; } int j[2]={0,1}; print(begin(j),end(j)); 3.显示传递一个表示数组大小的形参 第三种管理方法，就是专门定义一个表示数组大小的形参\n1 2 3 4 5 6 7 8 9 void print(const int ia[], size_t size) { for(size_t i=0 ; i != size ; ++i){ cout\u0026lt;\u0026lt;ia[i]\u0026lt;\u0026lt;endl; } } int j[] = {0,1}; print(j,end(j)-begin(j)); 4.3 数组引用形参 1 2 3 4 5 6 7 8 f(int \u0026amp;arr[10]); //arr是一个数组，每一个元素都引用变量 f(int (\u0026amp;arr)[10]); //arr是引用变量，指向一个含有10个元素的数组 int i = 0 , j[2] = {0,1}; int k[10] = {0,1,2,3,4,5,6,7,8,9}; f(\u0026amp;i); //错误 f(j); //错误 f(k); //正确 4.4 传递多维数组 1 void print(int (*matrix)[10] , int rowSize); 5、main处理命令行选项 int main(int argc, char *argv[]){...} 第一个形参代表参数的个数；第二个形参是参数C风格字符串数组。 6、可变形参 如果函数的实参数量未知但是全部实参的类型都相同，可以使用initializer_list类型的形参，这是一种标准库类型，用于表示某种特定类型的值的数组。定能一在同名头文件中。\ninitializer_list提供的操作（C++11）：\n操作 解释 initializer_list\u0026lt;T\u0026gt; lst; 默认初始化；T类型元素的空列表 initializer_list\u0026lt;T\u0026gt; lst{a,b,c...}; lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是const。 lst2(lst) 拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 lst2 = lst 同上 lst.size() 列表中的元素数量 lst.begin() 返回指向lst中首元素的指针 lst.end() 返回指向lst中微元素下一位置的指针 initializer_list使用demo：\n1 2 3 4 5 6 7 8 void err_msg(ErrCode e, initializer_list\u0026lt;string\u0026gt; il){ cout \u0026lt;\u0026lt; e.msg \u0026lt;\u0026lt; endl; for (auto bed = il.begin(); beg != il.end(); ++ beg) cout \u0026lt;\u0026lt; *beg \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; endl; } err_msg(ErrCode(0), {\u0026#34;functionX\u0026#34;, \u0026#34;okay}); 所有实参类型相同，可以使用 initializer_list的标准库类型。 实参类型不同，可以使用可变参数模板。 省略形参符： ...，便于C++访问某些C代码，这些C代码使用了 varargs的C标准功能。 三、返回类型和return语句 1、无返回值函数 没有返回值的 return语句只能用在返回类型是 void的函数中，返回 void的函数不要求非得有 return语句。\n2、有返回值函数 return语句的返回值的类型必须和函数的返回类型相同，或者能够隐式地转换成函数的返回类型。\n2.1 值是如何被返回的 ![[c++ 临时对象以及引用的一些知识]] 返回的值用于初始化调用点的一个临时量(除了指针和引用)，该临时量就是函数调用的结果。\n函数返回的是一个string对象，意味着返回值将被拷贝到调用点，因此，该函数返回word的副本或者一个未命名的临时string对象\n1 2 3 4 5 6 7 string make_plural(size_t ctr , const string \u0026amp;word, const string \u0026amp;ending) { return (ctr \u0026gt; 1) ? word+ending : word; } string word = make_plural(0,word,\u0026#34;s\u0026#34;); 如果函数返回引用，该引用仅是它所引用对象的一个别名\n2.2 不要返回局部对象的引用或指针 1 2 3 4 5 6 7 8 9 // 严重错误：这个函数试图返回局部对象的引用 const string \u0026amp;mainp() { string ret ; if(!ret.empty()) return ret; else return \u0026#34;Empty\u0026#34;; } 返回局部对象的引用是错误的；同样，返回局部对象的指针也是错误的。 一旦函数完成，局部对象被释放，指针将指向一个不存在的对象。要想确保返回值的安全，不妨提问：引用所引（指针所指向）的是在函数之前已经存在的哪个对象？\n⚠️不要，而不是不能 ![[C++中返回临时变量指针问题]]\n2.3 返回类类型的函数和调用运算符 1 2 //调用string对象的size成员，该string对象是由shorterString函数返回的 auto sz = shorterString(s1,s2).size(); 2.4 引用返回左值 函数的返回类型决定函数调用是否是左值。==调用一个返回引用的函数得到左值==；其他返回类型得到右值。\n2.5 列表初始化返回值 函数可以返回花括号包围的值的列表。（C++11） 此处的列表也用来对表示函数返回的临时量进行初始化\n1 2 3 4 5 6 7 8 9 10 vector\u0026lt;string\u0026gt; process() { //string expected , actual if(expected.empty()) return {}; else if(expected == actual) return {\u0026#34;functionX\u0026#34; ,\u0026#34;okay\u0026#34;}; else return {\u0026#34;fuctionX\u0026#34;,expected,actual}; } 如果函数返回的是内置类型,则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间。如果函数返回的是类类型，由类本身定义初始值如何使用。\n2.6 主函数main的返回值 main函数可以没有return语句直接结束 如果结尾没有return，编译器将隐式地插入一条返回0的return语句。返回0代表执行成功。main的返回值可以看作状态指示器，0表示成功，其他表示失败，其中非0的具体含义根据机器定夺，如果期望返回值与机器无关，则可调用cstdlib头文件中定义的两个预处理变量\n1 2 3 4 5 6 7 int main() { if(some_failure) return EXIT_FAILURE; else return EXIT_SUCCESS; } 其为预处理变量，所以不用在前面添加std::\n2.7 返回数组指针 因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。虽然从语法上来说，要想定义一个返回数组的指针或引用 的函数比较烦琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名：\n1 2 3 typedef int arrT[10]; //arrT是包含10个整数的数组 using arrT = int[10]; //等价声明 arrT* func() {...} //func返回一个指向含有10个整数的数组指针 如果不使用类型别名\n1 int (*func(int i))[10] func (int i)表示调用func函数时需要一个int类型的实参。 (*func(int i))意味着我们可以对函数调用的结果执行解引用操作。 (*func(int i)) [10]表示解引用func的调用将得到一个大小是10的数组, int (*func (int i)) [10]表示数组中的元素是int类型 使用 decltype 如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型\n1 2 3 4 5 6 int odd[] = {1,3,5,7,9}; int even[] = {2,4,6,8,10}; decltype(odd) *arrPtr(int i) { return ( i%2 ) ? \u0026amp;odd : \u0026amp;even; } 尾置返回类型 使用尾置返回类型 (trailing return type)。任何函数的定义都能使用，但是这种形式对返回类型复杂的函数最有效，比如返是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以-\u0026gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，在本应该出现返回类型的地方放置一个auto：\n1 auto func(int i) -\u0026gt; int(*)[10] 四、函数重载 1、重载概念 重载：如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载（overload）函数。 main函数不能重载。 重载和const形参： 一个有顶层const的形参和没有它的函数无法区分。 Record lookup(Phone* const)和 Record lookup(Phone*)无法区分。 相反，是否有某个底层const形参可以区分。 Record lookup(Account*)和 Record lookup(const Account*)可以区分。 重载和作用域：若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名。 2、函数匹配 重载函数匹配的三个步骤：1.候选函数；2.可行函数；3.寻找最佳匹配。 候选函数：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。 可行函数：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。 寻找最佳匹配：基本思想：实参类型和形参类型越接近，它们匹配地越好。 1 2 3 4 5 6 7 8 9 10 11 12 string read(); void print(const string \u0026amp;); void print(double); void fooBar(int val) { bool read = false; string s = read(); //WRONG void print(int); print(\u0026#34;Value:\u0026#34;); //WRONG print(val); print(3.14); } 五、特殊用途语言特性 1、默认实参 string screen(sz ht = 24, sz wid = 80, char backgrnd = ' '); 一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值。 2、内联（inline）函数 普通函数的缺点：调用函数比求解等价表达式要慢得多。 inline函数可以避免函数调用的开销，可以让编译器在编译时内联地展开该函数。 inline函数应该在头文件中定义。 1 2 cout \u0026lt;\u0026lt; shorterString(s1,s2)\u0026lt;\u0026lt;endl; //inline cout \u0026lt;\u0026lt; (s1.size() \u0026lt; s2.size() ? s1 : s2) \u0026lt;\u0026lt;endl; //编译时 3、constexpr函数 指能用于常量表达式的函数。编译器会把所有调用constexpr函数的地方替换成结果值，被隐式的指定成内联函数 函数的返回类型及所有形参类型都要是字面值类型，并且有且仅有一条return语句 1 2 3 4 5 6 7 8 constexpr int new_sz() {return 42;} constexpr int foo = new new_sz(); //foo是一个常量表达式 //返回值可以不是常量 constexpr size_t scale(size_t cnt){return new_sz()*cnt;} int arr[scale(2)]; int i =2 ; int a2[scale(i)]; //WRONG constexpr函数应该在头文件中定义。 4、调试帮助 4.1 assert 预处理宏（preprocessor macro） assert(expr); 如果expr为假（0），输出信息并终止程序的执行 如果为真（1），什么也不做 定义在cassert头文件中，预处理器而不是编译器管理\n4.2 NDEBUG assert的行为依赖于一个名为NDEBUG的预处理变量，该变量定义，则不是执行，未定义，则执行检查\n定义NDEBUG的方法\n利用#define NDEBUG 关闭assert 利用编译器参数控制调试状态： CC -D NDEBUG main.c可以定义这个变量NDEBUG。 利用NDEBUG编写条件调试代码 如果定义了NDEBUG，忽略掉调试代码 如果未定义NDEBUG，执行 #ifndef 和 #endif之间的代码\n1 2 3 4 5 void print(){ #ifndef NDEBUG cerr \u0026lt;\u0026lt; __func__ \u0026lt;\u0026lt; \u0026#34;...\u0026#34; \u0026lt;\u0026lt; endl; #endif } 预处理器定义的一些变量\n变量名 含义 __FILE__ 存放文件名的字符串字面量 __LINE__ 存放当前行号的整型字面值 __FILE__ 存放文件编译时间的字符串字面值 __FILE__ 存放文件编译日期的字符串字面量 六、函数指针 1、函数指针 是指向函数的指针。 bool (*pf)(const string \u0026amp;, const string \u0026amp;); 注：两端的括号不可少。 将函数名作为一个值使用时，该函数自动转换为指针\n1 2 bool *pf = func; bool *pf = \u0026amp;func; //\u0026amp;可选 2、函数指针形参 形参中使用函数定义或者函数指针定义效果一样。\n1 2 3 4 5 6 7 8 void useBigger(const string \u0026amp;s1 , const string \u0026amp;s2, bool pf(const string \u0026amp; , const string \u0026amp;)); void useBigger(const string \u0026amp;s1 , const string \u0026amp;s2, bool (*pf)(const string \u0026amp; , const string \u0026amp;)); //调用 useBigger(s1,s2,func); 过于冗余的形参，可以使用类型别名或者decltype来简化\n1 2 3 4 5 6 7 8 9 10 11 12 13 //func1 , func2 , funcU1 都是函数类型 typedef bool func1(const string \u0026amp; , const string \u0026amp;); typedef decltype(lengthCompare) func2; using funcU1 = bool(const string \u0026amp; , const tring \u0026amp;); //func3 , func4 , funcU2是指向函数的指针 typedef bool(*func3)(const string \u0026amp; , const string \u0026amp;); typedef decltype(lengthCompare) *func4; using funcU2 = bool(*)(const string \u0026amp; , const tring \u0026amp;); //更加简洁的形式 void useBigger(const string \u0026amp;s1 , const string \u0026amp;s2, func1); void useBigger(const string \u0026amp;s1 , const string \u0026amp;s2, func3); void useBigger(const string \u0026amp;s1 , const string \u0026amp;s2, funcU1); void useBigger(const string \u0026amp;s1 , const string \u0026amp;s2, funcU2); 这里直接给函数名字作为形参，会自动转为函数指针\n3、返回指向函数的指针 直接声明\n1 int (*f1(int))(int *,int*); 类型别名 和形参不同，返回类型不会自动识别函数名为函数指针类型，所以要明确的定义\n1 2 3 4 5 using F = int(int *, int*); using Fp = int(*)(int *,int*); Fp f1(int); F f2(int); //WRONG 尾置返回类型\n1 auto f1(int)-\u0026gt;int(*)(int *,int*); 4、重载函数的指针 定义指向重载函数的指针必须精准匹配\n1 2 3 4 5 6 7 void ff(int *); void ff(unsigned int); void (*pf1)(unsigned int) = ff; //pf1指向ff(unsigned int) void (*pf2)(int) = ff; //WRONG double (*pf3)(int *) =ff; //WRONG ","pubDate":"2021-09-13","title":"【C++ Primer(edition 5) 06】函数"},{"link":"https://cnjslw.github.io/posts/%E8%AF%AD%E5%8F%A5/","plain":"简单语句 表达式语句：一个表达式末尾加上分号，就变成了表达式语句。 空语句：只有一个单独的分号。 复合语句（块）：用花括号 {}包裹起来的语句和声明的序列。一个块就是一个作用域。 条件语句 悬垂else（dangling else）：用来描述在嵌套的if else语句中，如果if比else多时如何处理的问题。C++使用的方法是else匹配最近没有配对的if。 迭代语句 while：当不确定到底要迭代多少次时，使用 while循环比较合适，比如读取输入的内容。 for： for语句可以省略掉 init-statement， condition和 expression的任何一个；甚至全部。 范围for： for (declaration: expression) statement 跳转语句 break：break语句负责终止离它最近的while、do while、for或者switch语句，并从这些语句之后的第一条语句开始继续执行。 continue：终止最近的循环中的当前迭代并立即开始下一次迭代。只能在while、do while、for循环的内部。 try语句块和异常处理 throw表达式：异常检测部分使用 throw表达式来表示它遇到了无法处理的问题。我们说 throw引发 raise了异常。 try语句块：以 try关键词开始，以一个或多个 catch字句结束。 try语句块中的代码抛出的异常通常会被某个 catch捕获并处理。 catch子句也被称为异常处理代码。 异常类：用于在 throw表达式和相关的 catch子句之间传递异常的具体信息。 1 2 3 4 Sales_item item1,item2; cin \u0026gt;\u0026gt; item1\u0026gt;\u0026gt;item2; if(item1.isbn() != item2.isbn()) throw runtime_error(\u0026#34;Data must refer to same ISBN\u0026#34;); runtime_error：异常类，抛出异常将终止当前函数并将控制权给能处理该异常的代码 1 2 3 4 5 6 7 8 9 10 11 12 while(cin\u0026gt;\u0026gt;iteml\u0026gt;\u0026gt;item2){ try{ //...... }catch(runtime_error err){ cout \u0026lt;\u0026lt; err.what() \u0026lt;\u0026lt; \u0026#34;\\nTry Agiain?\u0026#34;\u0026lt;\u0026lt;endl; char c; cin \u0026gt;\u0026gt; c; if(!cin || c==\u0026#39;n\u0026#39;) break; } } 标准异常 《C++Primer（edition 5）》P197\n","pubDate":"2021-09-12","title":"【C++ Primer(edition 5) 05】语句"},{"link":"https://cnjslw.github.io/posts/%E8%A1%A8%E8%BE%BE%E5%BC%8F/","plain":"表达式由一个或多个运算对象(operand)组成，对表达式求值将得到一个结果(result )。字面值和变量是最简单的表达式(expression),其结果就是字面值和变量的值。把一个运算符(operator)和一个或多个运算对象组合起来可以生成较复杂的表达式。 ^0c892c\n一、表达式基础 运算对象转换：小整数类型会被提升为较大的整数类型 重载运算符：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。 左值和右值： C中原意：左值可以在表达式左边，右值不能。 C++：当一个对象被用作右值的时候，用的是对象的值（内容）； 被用做左值时，用的是对象的身份（在内存中的位置）。 求值顺序：int i = f1() + f2() 先计算f1() + f2(),再计算int i = f1() + f2()。但是f1和f2的计算先后不确定 但是，如果f1、f2都对同一对象进行了修改，因为顺序不确定，所以会编译出错，显示未定义 二、算术运算符 溢出：当计算的结果超出该类型所能表示的范围时就会产生溢出。 bool类型不应该参与计算 1 2 3 4 bool b=true; bool b2=-b; //仍然为true //b为true，提升为对应int=1，-b=-1 //b2=-1≠0，所以b2仍未true 取余运算m%n，结果符号与m相同 三、逻辑运算符 短路求值：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。先左再右 小技巧，声明为引用类型可以避免对元素的拷贝，如下，如string特别大时可以节省大量时间。 1 2 3 4 vector\u0026lt;string\u0026gt; text; for(const auto \u0026amp;s: text){ cout\u0026lt;\u0026lt;s; } 四、赋值运算符 赋值运算的返回结果时它的左侧运算对象，且是一个左值。类型也就是左侧对象的类型。 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。 赋值运算符满足右结合律，这点和其他二元运算符不一样。 ival = jval = 0;等价于ival = (jval = 0); 赋值运算优先级比较低，使用其当条件时应该加括号。 复合赋值运算符，复合运算符只求值一次，普通运算符求值两次。（对性能有一点点点点影响） 任意复合运算符op等价于a = a op b; 五、递增递减运算符 前置版本j = ++i，先加一后赋值 后置版本j = i++，先赋值后加一 优先使用前置版本，后置多一步储存原始值。（除非需要变化前的值）\n混用解引用和递增运算符 *iter++等价于*(iter++)，递增优先级较高\n1 2 3 auto iter = vi.begin(); while (iter!=vi.end()\u0026amp;\u0026amp;*iter\u0026gt;=0) cout\u0026lt;\u0026lt;*iter++\u0026lt;\u0026lt;endl;\t// 输出当前值，指针向前移1 简洁是一种美德，追求简洁能降低程序出错可能性\n六、成员访问运算符 ptr-\u0026gt;mem等价于(*ptr).mem\n注意.运算符优先级大于*，所以记得加括号\n七、条件运算符 条件运算符（?:）允许我们把简单的if-else逻辑嵌入到单个表达式中去，按照如下形式：cond? expr1: expr2\n可以嵌套使用，右结合律，从右向左顺序组合\n1 2 3 finalgrade = (grade \u0026gt; 90) ? \u0026#34;high pass\u0026#34;:(grade \u0026lt; 60) ? \u0026#34;fail\u0026#34; : \u0026#34;pass\u0026#34;; //等价于 finalgrade = (grade \u0026gt; 90) ? \u0026#34;high pass\u0026#34;: ((grade \u0026lt; 60) ? \u0026#34;fail\u0026#34; : \u0026#34;pass\u0026#34;); 输出表达式使用条件运算符记得加括号，条件运算符优先级太低。 八、位运算符 用于检查和设置二进制位的功能。\n位运算符是作用于整数类型的运算对象。 二进制位向左移（\u0026lt;\u0026lt;）或者向右移（\u0026gt;\u0026gt;），移出边界外的位就被舍弃掉了。 位取反（~）（逐位求反）、与（\u0026amp;）、或（|）、异或（^） 有符号数负值可能移位后变号，所以强烈建议位运算符仅用于无符号数。\n应用：\n1 2 3 4 5 unsigned long quiz1 = 0; // 每一位代表一个学生是否通过考试 1UL \u0026lt;\u0026lt; 12; // 代表第12个学生通过 quiz1 |= (1UL \u0026lt;\u0026lt; 12); // 将第12个学生置为已通过 quiz1 \u0026amp;= ~(1UL \u0026lt;\u0026lt; 12); // 将第12个学生修改为未通过 bool stu12 = quiz1 \u0026amp; (1UL \u0026lt;\u0026lt; 12); // 判断第12个学生是否通过 位运算符使用较少，但是重载cout、cin大家都用过\n位运算符满足左结合律，优先级介于中间，使用时尽量加括号。\n九、sizeof运算符 返回一条表达式或一个类型名字所占的字节数。 返回的类型是 size_t的常量表达式。 sizeof并不实际计算其运算对象的值。 两种形式： sizeof (type)，给出类型名 sizeof expr，给出表达式 可用sizeof返回数组的大小 1 2 3 4 5 int ia[10]; // sizeof(ia)返回整个数组所占空间的大小 // sizeof(ia)/sizeof(*ia)返回数组的大小 constexpr size_t sz = sizeof(ia)/sizeof(*ia); int arr[sz]; 十、逗号运算符 从左向右依次求值。\n左侧求值结果丢弃，逗号运算符结果是右侧表达式的值。\n十一、类型转换 1、隐式类型转换 设计为尽可能避免损失精度，即转换为更精细类型。\n比 int类型小的整数值先提升为较大的整数类型。 条件中，非布尔转换成布尔。 初始化中，初始值转换成变量的类型。 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型。 函数调用时也会有转换。 1.1 算术转换 算术转换(arithmetic conversion) 的含义是把一种算术类型转换成另外一种算术类型\n1.1.1 整型提升 常见的char、bool、short能存在int就会转换成int，否则提升为unsigned int wchar_t,char16_t,char32_t提升为整型中int,long,long long ……最小的，且能容纳原类型所有可能值的类型。 1.1.2 无符号类型的运算对象 都带符号 or 都不带符号，小类型转大类型 一个带符号，另一个不带符号 带符号\u0026gt;不带符号：无符号能存入带符号类型，则转化为带符号类型，反之则转为无符号类型 带符号≤不带符号：带符号转为不带符号 不同符号的类型转换带来了隐患，比如 unsigned int 类型的变量大于int类型的变量，则有转为为 int-\u0026gt;unsigned int , 如果恰巧这个int 是一个负数，则转化为就会产生歧义 1.2 其他转换 p143\n2、显式类型转换（尽量避免） 2.1 static_cast 任何明确定义的类型转换，只要不包含底层const，都可以使用。\n1 2 3 int i,j ; cin \u0026gt;\u0026gt; i \u0026gt;\u0026gt; j; double slope = static_cast\u0026lt;double\u0026gt;(j)/i; 常用于较大算数运算符转换为较小算数运算符，旨在告诉编译器，不在乎精度的损失。\n2.2 dynamic_cast 支持运行时类型识别。\n2.3 const_cast 只能改变运算对象的底层const，一般可用于去除const性质。\n1 2 const char *pc; char *p = const_cast\u0026lt;char*\u0026gt;(pc) 只有const_cast 可以消除底层const，其他类型转换会报错，但是如果被消除的变量本身就是常量对象，通过const_cast消除其底层const后再修改，就是未定义的行为\n2.4 reinterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释。\n3、旧式强制类型转换 1 char *pc = (char *) ip; //ip原类型为指向整数的指针 十二、运算符优先级表 《C++ Primer（edition 5）》p166\n十三、常量表达式 常量表达式是指不会改变并且在编译过程中就能得到计算结果的表达式，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。\n1 2 const int max_file = 20 ; const int limit = max_file + 1 ; ","pubDate":"2021-09-09","title":"【C++ Primer(edition 5) 04】表达式"},{"link":"https://cnjslw.github.io/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/","plain":"一、string 标准库类型string表示可变长的字符序列。 #include \u0026lt;string\u0026gt;，然后 using std::string; string对象：注意，不同于字符串字面值。 1、定义和初始化string对象 定义string对象的方式：\n方式 解释 string s1 默认初始化，s1是个空字符串 string s2(s1) s2是s1的副本 string s2 = s1 等价于s2(s1)，s2是s1的副本 string s3(\u0026quot;value\u0026quot;) s3是字面值“value”的副本，除了字面值最后的那个空字符外 string s3 = \u0026quot;value\u0026quot; 等价于s3(\u0026quot;value\u0026quot;)，s3是字面值\u0026quot;value\u0026quot;的副本 string s4(n, 'c') 把s4初始化为由连续n个字符c组成的串 [[顺序容器#^5f2418|构造string的其他方法]]\n拷贝初始化（copy initialization）：使用等号=将一个已有的对象拷贝到正在创建的对象。 直接初始化（direct initialization）：通过括号给对象赋值。 2、string对象上的操作 string的操作：\n操作 解释 os \u0026lt;\u0026lt; s 将s写到输出流os当中，返回os is \u0026gt;\u0026gt; s 从is中读取字符串赋给s，字符串以空白分割，返回is getline(is, s) 从is中读取一行赋给s，返回is s.empty() s为空返回true，否则返回false s.size() 返回s中字符的个数 s[n] 返回s中第n个字符的引用，位置n从0计起 s1+s2 返回s1和s2连接后的结果 s1=s2 用s2的副本代替s1中原来的字符 s1==s2 如果s1和s2中所含的字符完全一样，则它们相等；string对象的相等性判断对字母的大小写敏感 s1!=s2 同上 \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;= 利用字符在字典中的顺序进行比较，且对字母的大小写敏感（对第一个不相同的位置进行比较） string io： 执行读操作\u0026gt;\u0026gt;：忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止。 getline：读取一整行，包括空白符。 s.size()返回的时string::size_type类型，记住是一个无符号类型的值，不要和int混用 s1+s2使用时，保证至少一侧是string类型。string s1 = \u0026quot;hello\u0026quot; + \u0026quot;world\u0026quot; // 错误，两侧均为字符串字面值 字符串字面值和string是不同的类型。 3、处理string对象中的字符 ctype.h vs. cctype：C++修改了c的标准库，名称为去掉.h，前面加c。 如c++版本为cctype，c版本为ctype.h\n尽量使用c++版本的头文件，即cctype cctype头文件中定义了一组标准函数：\n函数 解释 isalnum(c) 当c是字母或数字时为真 isalpha(c) 当c是字母时为真 iscntrl(c) 当c是控制字符时为真 isdigit(c) 当c是数字时为真 isgraph(c) 当c不是空格但可以打印时为真 islower(c) 当c是小写字母时为真 isprint(c) 当c是可打印字符时为真 ispunct(c) 当c是标点符号时为真 isspace(c) 当c是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） isupper(c) 当c是大写字母时为真 isxdigit(c) 当c是十六进制数字时为真 tolower(c) 当c是大写字母，输出对应的小写字母；否则原样输出c toupper(c) 当c是小写字母，输出对应的大写字母；否则原样输出c 遍历字符串：使用范围for（range for）语句： for (auto c: str)，或者 for (auto \u0026amp;c: str)使用引用直接改变字符串中的字符。 （C++11） str[x],[]输入参数为string::size_type类型，给出int整型也会自动转化为该类型 二、vector [[C++Primer#第九章|深层次的介绍]]\nvector是一个容器，也是一个类模板； #include \u0026lt;vector\u0026gt; 然后 using std::vector; 容器：包含其他对象。 类模板：本身不是类，但可以实例化instantiation(编译器根据模板创建类或函数的过程称为实例化)出一个类。 vector是一个模板， vector\u0026lt;int\u0026gt;是一个类型。 通过将类型放在类模板名称后面的尖括号中来指定类型，如vector\u0026lt;int\u0026gt; ivec。 1、定义和初始化vector对象 初始化vector对象的方法\n方法 解释 vector\u0026lt;T\u0026gt; v1 v1是一个空vector，它潜在的元素是T类型的，执行默认初始化 vector\u0026lt;T\u0026gt; v2(v1) v2中包含有v1所有元素的副本 vector\u0026lt;T\u0026gt; v2 = v1 等价于v2(v1)，v2中包含v1所有元素的副本 vector\u0026lt;T\u0026gt; v3(n, val) v3包含了n个重复的元素，每个元素的值都是val vector\u0026lt;T\u0026gt; v4(n) v4包含了n个重复地执行了值初始化的对象 vector\u0026lt;T\u0026gt; v5{a, b, c...} v5包含了初始值个数的元素，每个元素被赋予相应的初始值 vector\u0026lt;T\u0026gt; v5={a, b, c...} 等价于v5{a, b, c...} 列表初始化： vector\u0026lt;string\u0026gt; v{\u0026quot;a\u0026quot;, \u0026quot;an\u0026quot;, \u0026quot;the\u0026quot;}; （C++11） 元素由内默认初始化有两个限制，其一有些类必须明确的提供初始值，其二,如果只提供了元素的数量，而没有设定初始值，只能使用直接初始化。 如果初始化时使用了花括号的形式，但是提供了值又不能用来列表初始化就要考虑用这样的值来构造vector对象。 2、向vector对象中添加元素 v.push_back(e) 在尾部增加元素。 3、其他vector操作 vector支持的操作：\n操作 解释 v.emtpy() 如果v不含有任何元素，返回真；否则返回假 v.size() 返回v中元素的个数 v.push_back(t) 向v的尾端添加一个值为t的元素 v[n] 返回v中第n个位置上元素的引用 v1 = v2 用v2中的元素拷贝替换v1中的元素 v1 = {a,b,c...} 用列表中元素的拷贝替换v1中的元素 v1 == v2 v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同 v1 != v2 同上 \u0026lt;,\u0026lt;=,\u0026gt;, \u0026gt;= 以字典顺序进行比较 范围for语句内不应该改变其遍历序列的大小。 vector对象（以及string对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。 三、迭代器iterator 所有标准库容器都可以使用迭代器。 类似于指针类型，迭代器也提供了对对象的间接访问。 1、使用迭代器 vector\u0026lt;int\u0026gt;::iterator iter。 auto b = v.begin();返回指向第一个元素的迭代器。 auto e = v.end();返回指向最后一个元素的下一个（哨兵，尾后,one past the end）的迭代器（off the end）。 如果容器为空， begin()和 end()返回的是同一个迭代器，都是尾后迭代器。 使用解引用符*访问迭代器指向的元素。 养成使用迭代器和!=的习惯（泛型编程）。 容器：可以包含其他对象；但所有的对象必须类型相同。 迭代器（iterator）：每种标准容器都有自己的迭代器。C++倾向于用迭代器而不是下标遍历元素。 const_iterator：只能读取容器内元素不能改变。 箭头运算符： 解引用 + 成员访问，it-\u0026gt;mem等价于 (*it).mem 谨记：但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。 标准容器迭代器的运算符:\n运算符 解释 *iter 返回迭代器iter所指向的元素的引用 iter-\u0026gt;mem 等价于(*iter).mem ++iter 令iter指示容器中的下一个元素 --iter 令iter指示容器中的上一个元素 iter1 == iter2 判断两个迭代器是否相等 2、迭代器运算 vector和string迭代器支持的运算：\n运算符 解释 iter + n 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 iter - n 迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。 iter1 += n 迭代器加法的复合赋值语句，将iter1加n的结果赋给iter1 iter1 -= n 迭代器减法的复合赋值语句，将iter2减n的加过赋给iter1 iter1 - iter2 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。 \u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;= 迭代器的关系运算符，如果某迭代器 difference_type：保证足够大以存储任何两个迭代器对象间的距离，可正可负。 三、数组 相当于vector的低级版，长度固定。 如果不清楚元素的确切个数，请使用vector。 1、定义和初始化内置数组 初始化：char input_buffer[buffer_size];，长度必须是const表达式，或者不写，让编译器自己推断。 数组不允许直接赋值给另一个数组。 字符数组的特殊性 : 字符数组有一种额外的初始化形式，可以用字符串字面值对此类数组初始化。一定要注意字符串字面值的结尾处还有一个空字符。 1 2 char a1[] = {\u0026#39;c\u0026#39; , \u0026#39;+\u0026#39;, \u0026#39;+\u0026#39;};//列表初始化,没有空字符 char a2[]=\u0026#34;C++\u0026#34; //自动添加表示字符串结束的空字符 理解复杂的数组声明 : 由内向外，从右向左。 用数组初始化 vector： int a[] = {1,2,3,4,5}; vector\u0026lt;int\u0026gt; v(begin(a), end(a)); 。 2、访问数组元素 数组下标的类型：size_t 。 字符数组的特殊性：结尾处有一个空字符，如 char a[] = \u0026quot;hello\u0026quot;; 。 3、数组和指针 使用数组时，编译器一般会把它转换成指针。 标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值。 int *p=a[2] ; int k= p[-2]; //k=a[0]* 指针访问数组：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针。 当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组。当使用decltype的关键字时，上述转换不会发生。 在宿主中引入begin和end函数来获取数组的首元素和数组的尾后元素。 两个指向数组的指针相减的结果是它们之间的距离。 结果类型为ptrdiff_t的标准库类型。 4、C风格字符串 C风格的字符串是一种特殊的字符数组\n1 2 const char *c = \u0026#34;Halo,World\u0026#34;; const char c[] = {\u0026#39;H\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;,\u0026#39;,\u0026#39;W\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;\\0\u0026#39;}; 两者等价，请注意，该数组的最后一个字符为空字符\\0，这也被称为字符串结束字符，因为它告诉编译器， 字符串到此结束。这种C风格字符串是特殊的字符数组，因为总是在最后一个字符后加上空字符\\0，在代码中使用字符串字面量时，编译器将负责在它后面添加\\0。 在数组中间插入\\0并不会改变数组的长度，而只会导致将该数组作为输入的字符串处理将到这 个位置结束，如果不加\\0，则会导致在打印或者计算长度等操作是无法停止或者输出垃圾数据，从而程序奔溃。\nC风格字符串不仅使用起来不方便而且极易引发程序漏洞是, 诸多安全问题的根本原因。\n从C继承来的字符串。 用空字符结束（\\0）。 对大多数应用来说，使用标准库 string比使用C风格字符串更安全、更高效。 获取 string 中的 cstring ： const char *str = s.c_str(); 1 2 3 char ca[] = {\u0026#39;C\u0026#39; , \u0026#39;+\u0026#39; , \u0026#39;+\u0026#39;}; cout \u0026lt;\u0026lt; strlen(ca)\u0026lt;\u0026lt;endl; //严重错误CA没有以空字符结束。 Strlen函数将有可能沿着ca在内存中的位置不断向前寻找，直到遇到空字符才停下。 C标准库String函数，定义在\u0026lt;cstring\u0026gt; 中：\n函数 介绍 strlen(p) 返回p的长度，空字符不计算在内 strcmp(p1, p2) 比较p1和p2的相等性。如果p1==p2，返回0；如果p1\u0026gt;p2，返回一个正值；如果p1\u0026lt;p2，返回一个负值。 strcat(p1, p2) 将p2附加到p1之后，返回p1 strcpy(p1, p2) 将p2拷贝给p1，返回p1 尽量使用vector和迭代器，少用数组\n5、与旧代码的接口 混用string对象和C风格字符串\n允许使用以空字符结束的字符数组来初始化string对象，或为string对象赋值。 允许使用以空字符结束的字符数组作为string对象加法运算中的一个对象，不能两个运算对象都是 ， 在string对象的复合赋值运算中，允许使用以空字符结束的字符数组作为右侧的运算对象。 上述性质反过来只能用string专门提供的一个名为c_str的成员函数来初始化指向字符的指针。string s =\u0026quot;C++\u0026quot; ; const char *str = s.c_str();该函数的返回结果是一个指针，该指针指向的一个以空字符结束的字读数组, 也就是C风格的字符串，而这个数组所存的数据恰好与那个string对象是一样的，结果指针的类型是const char*，从而确保我们不会改变字符数组的类型。 六、多维数组 多维数组的初始化： int ia[3][4] = {{0,1,2,3}, ...}。 使用范围for语句时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。 七、动态数组 使用 new和 delete表达和c中malloc和free类似的功能，即在堆（自由存储区）中分配存储空间。 定义： int *pia = new int[10]; 10可以被一个变量替代。 释放： delete [] pia;，注意不要忘记[]。 ","pubDate":"2021-09-08","title":"【C++ Primer(edition 5) 03】字符串、向量和数组"},{"link":"https://cnjslw.github.io/posts/%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/","plain":"一、引用 1、左值引用 1.1、引用的定义 引用是一个对象的别名，引用类型引用（refer to）另外一种类型。如int \u0026amp;refVal = val;。 引用的类型要和与之绑定的对象(对象)严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起\n引用必须初始化。 引用和它的初始值是绑定在一起的，而不是拷贝。一旦定义就不能更改绑定为其他的对象 1.2、引用规则的两种例外情况 第一个例外 在初始化常量引用时允许用任意表达式作为初始值，只要表达式的结果能够转换为引用的类型即可，允许一个常量引用绑定非常量的对象，字面值，甚至一个表达式 ^d7c880\n1 2 3 4 5 int i = -42; const int \u0026amp;rl = i;\t//允许将 const int\u0026amp; 绑定到一个普通int对象上 const int \u0026amp;r2 = 42;\t//正确：rl是一个常量引用 const int \u0026amp;r3 = rl*2;\t//正确：r3是一个常量引用 int \u0026amp;r4 = rl*2;\t//\t错误：r4是一个普通的非常量引用 1 2 double dval = 3.14; const int \u0026amp;ri = dval; 理解这种例外的核心就是搞清楚当一个常量引用被绑定到另外一种类型上发生了什么。\n1 2 3 const int temp = dval; //由双精度浮点数生成一个临时的整型常量 const int \u0026amp;ri = temp; //让ri绑定这个临时量 在这种情况下，ri绑定了一个临时量(temporary)对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。c++程序员们常常把临时量对象简称为临时量。\n第二个例外 存在继承关系的类是一个例外，可以将基类的指针或者引用绑定到派生类对象上 可以将基类的指针或引用绑定到派生类对象上有一层极为至要的含义：当使用基类的 引用（或指针）时，实际我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。 ^9b1798\n1.3 sizeof()和引用 sizeof()取的是引用变量的类型大小\n3、为什么要有引用 避免无休止的拷贝，极大提高了性能\n二、指针 1、定义 指针是一种 \u0026ldquo;指向（point to）\u0026ldquo;另外一种类型的复合类型。也可以说是指向内存单元的特殊变量。指针的类型与所指向的对象类型必须一致\n1.1 声明指针 int *ip1;，从右向左读有助于阅读，ip1是指向int类型的指针。\n1.2 取变量地址 指针存放某个对象的地址，获取对象的地址： int i=42; int *p = \u0026amp;i;。 \u0026amp;是取地址符。\n1.3 利用指针访问对象 使用解引用符（*）来访问对象 指针访问对象： cout \u0026lt;\u0026lt; *p;\n1.4 sizeof()和指针 sizeof()用于普通变量是指变量类型的内存大小，即编译器为变量预留的内存空间大小。 但是，当用于指针变量时，取决于编译器和操作系统存储地址所需的内存空间，与指向什么类型的变量空间是没有关系的。\n2、指针操作 2.1 递增和递减 如果对指针执行递增或递减运算，编译器将认为要指向内存块中相邻的值（并假定这个值的 类型与前一个值相同）,而不是相邻的字节（除非值的长度刚好是1字节，如char）。 将指针递增或递减的结果 将指针递增或递减时，其包含的地址将增加或减少指向的数据类型的sizeof （并不一定是1字节）。这样，编译器将琉保指针不会指向数据的中间或末尾，而只会指向数据的开头。 如果声明了如下指针：\n1 Type* pType = Address; 则执行++piype后，pType 将包含（指向）Address + sizeoffiype。\n2.2 将关键字const用于指针 ![[变量和基本类型#3、指针和const|指针和const]]\n2.3 将指针传递给函数 3、指针定义的两种例外情况 指针的类型与所指向的对象类型必须一致这个规则有两种例外 第一种 允许令一个指向常量的指针指向一个非常量对象 ^413a8b\n1 2 3 const double *cptr ; double dval = 3.14 ; cptr = \u0026amp;dval ; 和常量引用一样，指向常量的指针也没有规定其所指的对象必须是个常量。所谓的指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过 其他途径改变。 可以这样想，所谓的常量引用和常量指针，不过是指针和引用的“自以为是”，他们觉得自己指向了常量，所以自觉的不去改变所指向的对象的值罢了。\n第二种 [[复合类型#^9b1798|继承关系中存在例外]]\n4、指针的值的四种状态 1.指向一个对象； 2.指向紧邻对象的下一个位置； 3.空指针； 4.无效指针。\n对无效指针的操作均会引发错误，第二种和第三种虽为有效的，但理论上是不被允许的\n5、空指针 空指针不指向任何对象。使用int *p=nullptr;来使用空指针。\n6、空类型指针 void*指针可以存放任意对象的地址。因无类型，仅操作内存空间，对所存对象无法访问。 利用void*指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void*指针。不能直接操作void*指针所指的对象，因为我们并不知道 这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。\n7、使用指针时常犯的错误 7.1 野指针 “野指针”则是不确定其具体指向的指针。“野指针”最常来自于未初始化的指针\n1 2 void *p; // 此时 p 是“野指针” 因为“野指针”可能指向任意内存段，因此它可能会损坏正常的数据，也有可能引发其他未知错误，所以C语言中的“野指针”危害性甚至比“悬空指针”还要严重。在实际的C语言程序开发中，定义指针时，一般都要尽量避免“野指针”的出现（赋初值）：\n1 void *p = NULL; 7.2 内存泄漏 这可能是C++应用程序最常见的问题之一：运行时间越长，占用的内存越多，系统越慢。如果在使用new动态分配的内存不再需要后，程序员没有使用配套的delete释放，通常就会出现这种情况。\n7.3 指向无效的内存单元 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { // uninitialized pointer (bad) int* pTemperature; cout \u0026lt;\u0026lt; \u0026#34;Is it sunny (y/n)?\u0026#34; \u0026lt;\u0026lt; endl; char Userinput = \u0026#39;y\u0026#39;; cin \u0026gt;\u0026gt; Userinput; if (Userinput == \u0026#39;y\u0026#39;) { pTemperature = new int; *pTemperature = 30; } // pTemperature contains invalid value if user entered \u0026#39;n\u0026#39; cout « \u0026#34;Temperature is: \u0026#39; « *pTemperature; // delete also being invoked for those cases new wasn\u0026#39;t done delete pTemperature; return 0; } 7.4 悬空指针 指针可以指向一块内存，如果这块内存稍后被操作系统回收（被释放），但是指针仍然指向这块内存，那么，此时该指针就是“悬空指针”\n三、指针与引用的不同 本质上： 引用本质是一个指针\n使用上： 指针与引用类似，都实现了对其他对象的间接访问。 然而指针与引用相比也有很多不同点。\n其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在==指针的生命周期内它可以先后指向几个不同的对象==，但是引用一旦初始化后就不可以再改变。\n其二，==指针无须在定义时赋初值==。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有个不确定的值。\n其三，作为参数传递时，指针是==拷贝==同样的地址，如果函数作用域中改变指针变量的地址，则不再影响实参。引用参数实质上==传递的是实参本身==，即传递进来的不是实参的一个拷贝，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。\n四、理解复合类型的声明 变量的定义包括一个基本数据类型(base type) 和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。也就是说， 条定义语句可能定义出不同类型的变量：\n1 int i = 1024, *p = \u0026amp;i , \u0026amp;r = i; 甚至可以有多个声明符，组合出更为复杂的变量\n指向指针的指针\n1 int **p; 指向指针的引用 要理解变量到底是什么，最简单的方法就是==从右向左==阅读r的定义，距离变量名最近的符号对变量的类型有直接的影响\n1 2 3 4 5 6 int i = 42; int *p; int *\u0026amp;r = p; //r是一个引用变量，引用一个指向int型变量的指针变量 r = \u0026amp;i; *r=0; ","pubDate":"2021-09-06","title":"【C++ Primer(edition 5) 02】复合类型"},{"link":"https://cnjslw.github.io/posts/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/","plain":"一、基本内置类型 基本算数类型\n类型 含义 最小尺寸 bool 布尔类型 8bits char 字符 8bits wchar_t 宽字符 16bits char16_t Unicode字符 16bits char32_t Unicode字符 32bits short 短整型 16bits int 整型 16bits (在32位机器中是32bits) long 长整型 32bits long long 长整型 64bits （是在C++11中新定义的） float 单精度浮点数 6位有效数字 double 双精度浮点数 10位有效数字 long double 扩展精度浮点数 10位有效数字 如何选择类型\n1.当明确知晓数值不可能是负数时，选用无符号类型； 2.使用int执行整数运算。一般long的大小和int一样，而short常常显得太小。除非超过了int的范围，选择long long。 3.算术表达式中不要使用char或bool。 4.浮点运算选用double。 二、常量 在C++中，常量类似于变量，只是不能修改。与变量一样，常量也占用内存空间，并使用名称标识为其预留的空间的地址，但不能覆盖该空间的内容。在C++中，常量可以是： •字面常量； •使用关键字const声明的常量； •使用关键字constexpr声明的常量表达式（C++11新增的）; •使用关键字enum声明的枚举常量； •使用#define定义的常量（已摒弃，不推荐）。\n1、使用constexpr声明常量 在C++11之前，C++就支持常量表达式的概念，只是没有关键字constexpr，在程序清单3.5中， 22.0/7是一个常量表达式，C++11之前的编译器也支持它。然而，C++11之前的编译器不允许定义在编译阶段计算的函数。 在C++11中，可以编写下面这样的代码：\n1 constexpr double GetPi() {return 22.0 / 7;} 还可将GetPi与另一个常量一起使用，如下所示：\n1 constexpr double TwicePi() {return 2 * GetPi();} 乍一看，const和constexpr之间的差别很小，但从编译器和应用程序的角度看，关键字Constexpr 提供了优化应用程序的可能性。对于第二条语句，如果使用const,将在运行阶段执行计算，但使用遵 守C++11的编译器时，将在编译阶段计算该表达式的值，这提高了应用程序的运行速度。\n2、字面值常量 一个形如42的值被称作字面值常量（literal）。 整型和浮点型字面值。 字符和字符串字面值。 使用空格连接，继承自C。 字符字面值：单引号， 'a' 字符串字面值：双引号， \u0026quot;Hello World\u0026quot;\u0026quot; 分多行书写字符串。 1 2 std:cout\u0026lt;\u0026lt;\u0026#34;wow, a really, really long string\u0026#34; \u0026#34;literal that spans two lines\u0026#34; \u0026lt;\u0026lt;std::endl; 转义序列。\\n、\\t等。 布尔字面值。true，false。 指针字面值。nullptr 字符串型实际上时常量字符构成的数组，结尾处以'\\0'结束，所以字符串类型实际上长度比内容多1。\n3、使用const将变量声明为常量 [[变量和基本类型#五、const限定符]]\n4、枚举常量 在有些情况下，变量只能有一组特定的取值\n1 2 3 4 5 6 7 8 9 10 11 enum RainbowColors { Violet = 0 , //此后每个值都递增1，默认0开始 Indigo, Blue, Yellow, Orange, Red } RainbowColors MyWorldColor = Blue; 5、使用#define定义常量 【摒弃】 这是一个预处理器宏，让预处理器将随后出现的所有Pi都替换为3.14286。预处理器将进行文本替换，而不是智能替换。编译器既不知道也不关心常量的类型。\n1 #define Pi 3.14 三、变量 1、什么是变量 变量提供一个具名的，可供程序操作的存储空间 变量类型向编译器指出了变量可存储的数据的性质，编译器将为变量预留必要的空间。变量名由程序员选择，它替代了变量值在内存中的存储地址，但更友好。除非给变量赋初值，否则无法确保相应内存单元的内容是什么，这对程序可能不利。因此，初始化虽然是可选的，但对变量初始化通常是 一个不错的编程习惯。程序清单3.1将用户提供的两个数字相乘，演示了如何在程序中声明、初始化。\n变量名 是内存地址的别名，方便存取 类型 是告诉编译器可以存什么样的数据,需要多大的内存空间 初始化 是可选的，不然无法确保内存中的数据是啥 变量提供一个具名的、可供程序操作的存储空间。 C++中变量和对象一般可以互换使用。\n2、变量定义（define） 定义形式：类型说明符（type specifier） + 一个或多个变量名组成的列表。用于初始化变量的值可以是任意复杂的[[表达式#^0c892c|表达式]]\n1 int sum = 0, value, units_sold = 0; 3、初始化 初始化（initialize）：对象在创建时获得了一个特定的值。 初始化不是赋值！ 初始化 = 创建变量 + 赋予初始值 赋值 = 擦除对象的当前值 + 用新值代替\n3.1 直接初始化 略\n3.2 列表初始化(C++11 全面支持) 使用花括号{}\n1 2 3 4 int units_sold = 0; int units_sold = {0}; int units_sold{0}; int units_sold(0); 当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错\n1 2 3 long double Id = 3.1415926536; int a{Id}, b = {Id}; // 错误 ：转换未执行，因为存在丢失信息的危险 int c(ld), d = Id; // 正确：转换执行，且确实丢失了部分值 3.3 默认初始化 定义时没有指定初始值会被默认初始化，默认值到底是什么由变量类型决定\n在函数体内部的内置类型变量将不会被初始化, 函数体外的内置类型初始化为0，试图使用未定义的变量将发生错误。建议初始化每一个内置类型的变量。\n3.4 值初始化（类） 通常情况下，可以只提供Vector对象容纳的元素数量而不用略去初始值。此时库会创建一个值初始化的(value-initialized)元素初值，并把它赋给容器中的所有元素。这个 初值由vector对象中元素的类型决定。 限制：类中的元素必须支持默认初始化\n4、变量的声明（declaration） vs 定义（define） 为了支持分离式编译，C++将声明和定义区分开。声明使得名字为程序所知。定义负责创建与名字关联的实体。 extern：只是说明变量定义在其他地方。 只声明而不定义： 在变量名前添加关键字 extern，如extern int i;。但如果包含了初始值，就变成了定义：extern double pi = 3.14; 变量只能被定义一次，但是可以多次声明。定义只出现在一个文件中，其他文件使用该变量时需要对其声明。 名字的作用域（namescope）{} 第一次使用变量时再定义它。 嵌套的作用域 同时存在全局和局部变量时，已定义局部变量的作用域中可用::reused显式访问全局变量reused。 但是用到全局变量时，尽量不适用重名的局部变量。 5、变量命名规范 需体现实际意义 变量名用小写字母 自定义类名用大写字母开头：Sales_item 标识符由多个单词组成，中间须有明确区分：student_loan或studentLoan，不要用studentloan。 6、左值和右值 左值（l-value）可以出现在赋值语句的左边或者右边，比如变量； 右值（r-value）只能出现在赋值语句的右边，比如常量。 7、变量的作用域 C++作用域\n四、复合类型 复合类型\n五、const限定符 动机：希望定义一些不能被改变值的变量。 1、初始化和const const对象必须初始化，且不能被改变。 编译器将在编译过程中把用到const 变量的地方都替换成对应的值。 const变量默认不能被其他文件访问，非要访问，必须在指定const定义之前加extern。某些时候有这样种const变量，它的初始值不是个常量表达式，但又确实有必要在文件间共享。也就是说，只在一个文件中定义const,而在其他多个文件中声明并使用它。解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了： 1 2 3 4 // file_l.cc定义并初始化了一个常量，该常量能被其他文件访问 extern const int bufSize = fen(); // file_l.h 头丈件 extern const int bufSize; // 与\t.cc 中定义的 bufSize 是同一个 2、const的引用 [[复合类型#^d7c880|常量引用的特殊性]]\nreference to const（对常量的引用）：指向const对象的引用，如 const int ival=1; const int \u0026amp;refVal = ival;，可以读取但不能修改refVal。 临时量（temporary）对象：当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。 对临时量的引用是非法行为。 3、指针和const [[复合类型#^413a8b|常量指针的特殊性]]\npointer to const（指向常量的指针，简称常量指针）：不能用于改变其所指对象的值, 如 const double pi = 3.14; const double *cptr = \u0026amp;pi;。 const pointer：指针本身是常量（简称指针常量），也就是说指针固定指向该对象，（存放在指针中的地址不变，地址所对应的那个对象值可以修改）如 int i = 0; int *const ptr = \u0026amp;i; 4、顶层const与底层 顶层const：表示变量本身是个常量，对任何数据类型适用，如算数类型（int、double），类，指针。 底层const：表示指向的变量是个常量，用于指针和引用 六、处理类型 1、类型别名 传统别名：使用typedef来定义类型的同义词。 1 2 typedef double wages; typedef wages base,*p; //base = wages = double , p = wages * = double * 这里不仅有基本类型还包含声明符，需要理解[[复合类型#四、理解复合类型的声明|复合类型的声明]]\n新标准别名：别名声明（alias declaration）： using SI = Sales_item;（C++11） 指针、常量和类型别名\n1 2 3 4 5 6 7 8 9 // 对于复合类型（指针等）不能代回原式来进行理解 typedef char *pstring; // pstring是char*的别名 const pstring cstr = 0; // 指向char的常量指针 const pstring *ps; //ps是一个指针，他的对象是指向char的常量指针 // 如改写为const char *cstr = 0;不正确，为指向const char的指针 // 辅助理解（可代回后加括号） // const pstring cstr = 0;代回后const (char *) cstr = 0; // const char *cstr = 0;即为(const char *) cstr = 0; 2、auto类型说明符 c++11 auto类型说明符：让编译器自动推断类型。 一条声明语句只能有一个数据类型，所以一个auto声明多个变量时只能相同的变量类型(包括复杂类型\u0026amp;和*)。auto sz = 0, pi =3.14//错误 如何初始化的对象是引用类型，会根据引用变量的引用对象的值来推测，而非引用变量的类型，int i = 0, \u0026amp;r = i; auto a = r; 推断a的类型是int。 会忽略顶层const。const int ci = 1; const auto f = ci;推断类型是int，如果希望是顶层const需要自己加const；但是如果左值是一个引用变量，那么初始值中的顶层常量属性会被保存 1 2 3 4 5 6 7 8 9 10 11 12 int i = 0, \u0026amp;r = i; auto a = r; //a 是整型 const int ci = i, \u0026amp;cr = ci; auto b = ci; //b 是整型 auto c = cr; //c 是一个整型 auto d = \u0026amp;i; //d 是一个整型指针 auto e = \u0026amp;ci; //e 是一个指向整数常量的指针（对常量取地址是一种底层const） const auto f = ci; //ci的推演类型是int,f是cosnt int auto \u0026amp;g = ci; //g是一个整型常量引用，绑定到ci auto \u0026amp;h = 42; //错误：不能为非常量引用绑定到字面值 const auto \u0026amp;j = 42 //正确，这里是因为常量引用的特殊性，可以参考复合类型的笔记 3、decltype类型指示符 有时会遇到这种情况: 向往从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量（想用类型，不想用值）。 为了满足这一要求，C++1I新标准引入了第二种类型说明符decltype decltype：选择并返回操作数的数据类型，从表达式的类型推断出要定义的变量的类型。\n3.1 与auto的不同 decltype处理顶层const和引用的方式与auto有些许不同。 其一，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）:\n1 2 3 4 const int ci =0, \u0026amp;cj =ci; decltype(ci) x = 0 ; //x的类型是const int decltype(cj) y = x ; //y的类型是const int \u0026amp; decltype(cj) z; //错误，z是const int \u0026amp; ,需要初始化 其二，decltype的结果类型与表达式形式密切相关，如果对变量加括号（一层或者多层），因为变量是一种可以作为赋值语句左值的特殊表达式，编译器会因此将其认为是一个表达式\n1 2 decltype((i)) d; //错误，d是int\u0026amp;，必须初始化 decltype(i) e; //正确，e是一个未初始化的int 3.2 decltype和引用 如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的 类型。 1 2 3 4 5 6 decltype(f()) sum = x; // 推断sum的类型是函数f的返回类型。 int i = 42, *p = \u0026amp;i, \u0026amp;r = i ; decltype(r + 0) b; //正确，加法的结果是int,因此b是一个未初始化的int decltype(*p) c; //错误：c是int\u0026amp; , 必须初始化 decltype(\u0026amp;i) d; //d是 int **类型 因为r是一个引用，因此decltype (r)的结果是引用类型。如果想让结果类型是r所指 的类型，可以把r作为表达式的一部分，如r+0,显然这个表达式的结果将是一个具体值而非一个引用。 表达式的内容是解引用操作，则decltype将得到引用类型 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果 i 是 int，则表达式 i=x 的类型是 int\u0026amp;。 取地址运算符生成右值，所以decltype(\u0026amp;p)的结果是int ** ","pubDate":"2021-09-04","title":"【C++ Primer(edition 5) 01】变量和基本类型"}];
    var search_theEnd = "到底了";
    var search_nothing = "什么也没找到";
    var search_found = "找到";
    var search_result = "条结果";
    var search_results = "条结果";
    var enable_mermaid =  null 
</script>





        
    </body>
</html>

