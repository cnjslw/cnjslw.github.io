<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>AWei’s Kernel Tour | Categories</title>
    <meta name="description"
        content=" ">
    <link rel="canonical" href="https://cnjslw.github.io/categories/" />
    <link rel="icon" type="image/x-icon" href="/images/linux_pic.ico">
    <meta property="og:title" content="Categories" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cnjslw.github.io/categories/" />


    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Categories"/>
<meta name="twitter:description" content=""/>

    
    
    

    <link rel="stylesheet" href='/css/style.css' />
    <link rel="stylesheet" href='/css/search.css' />
    <link rel="stylesheet" href='/css/md_nb.css' />
    <link rel="stylesheet" href='/css/list.css' />
    <link rel="stylesheet" href='/css/terms.css' />
    <link rel="stylesheet" href='/css/taxonomy.css' />
    <link rel="stylesheet" href='/css/font-awesome-4.7.0/css/font-awesome.min.css' />
    <link rel="stylesheet" href='/css/home.css' />
    <link rel="stylesheet" href='/css/syntax.css' />
    
    <link rel="stylesheet" href='/css/shortcode.css' />

    
    <link rel="stylesheet" href='/css/_custom.css' />
    <style>
        {
                {
                if eq .Kind "404"
            }
        }

        body::after {
            display: none;
        }

            {
                {
                end
            }
        }
    </style>
    
    
    
    
    <script src="/js/lazysizes.min.js" async=""></script>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/search.js"></script>
    <script src="/js/md_nb.js"></script>
    <script src="/js/yes.js"></script>
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
</head><body style="font-family: ,'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Heiti SC', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;">
        <div class="loading">
            <div class="loading-bg"></div>
            <div class="loading-long">
                <div class="loading-short"></div>
            </div>
        </div>

        <header>
    <nav class="navbar">
        <div class="navbar-brand">
            <a href="/">
                <span class="logo">AWei’s Kernel Tour</span>
            </a>
        </div>
        <div class="navbar-menu">
            
                <a href="/">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-home'></i> 主页</div>
                        </div>
                    </div>
                </a>
            
                <a href="/posts">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-book'></i> 文章</div>
                        </div>
                    </div>
                </a>
            
                <a href="/categories">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-folder-open'></i> 分类</div>
                        </div>
                    </div>
                </a>
            
                <a href="/series">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-gears'></i> 系列</div>
                        </div>
                    </div>
                </a>
            
                <a href="/tags">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-tags'></i> 标签</div>
                        </div>
                    </div>
                </a>
            
                <a href="/about">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-info-circle'></i> 简历</div>
                        </div>
                    </div>
                </a>
            
            <div class="navbar-burger">
                <div class="burger-btn"><span><i class="fa fa-navicon"></i></span></div>
            </div>
            
            
            <div class="search-in"><span><i class="fa fa-search"></i></span></div>
            
                <div class="mode">
                    <span class="sun"><i class="fa fa-sun-o"></i></span>
                    <span class="moon"><i class="fa fa-moon-o"></i></span>
                </div>
            
        </div>
    </nav>
    <div class="burger-items">
        
        <a href="/">
            <div class="burger-item">
                <i class='fa fa-home'></i> 主页
            </div>
        </a>
        
        <a href="/posts">
            <div class="burger-item">
                <i class='fa fa-book'></i> 文章
            </div>
        </a>
        
        <a href="/categories">
            <div class="burger-item">
                <i class='fa fa-folder-open'></i> 分类
            </div>
        </a>
        
        <a href="/series">
            <div class="burger-item">
                <i class='fa fa-gears'></i> 系列
            </div>
        </a>
        
        <a href="/tags">
            <div class="burger-item">
                <i class='fa fa-tags'></i> 标签
            </div>
        </a>
        
        <a href="/about">
            <div class="burger-item">
                <i class='fa fa-info-circle'></i> 简历
            </div>
        </a>
        
    </div>
    <div class="header-rest"></div>
</header>


        <div id="content">
    






    
        
        
        
    




    <div class="hero">
        
            <div class="hero-img">
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/categories.jpg" alt="">
            </div>
        
        <div class="hero-content">
            <div class="hero-title">分类</div>
            <div>description of categories page</div>
        </div>
    </div>




<div class="zhuti-0">
    <div class="container">
        <div class="zhuti">
            <div class="zhuti-l">
                




    


<div class="taxo-body">
    <div class="long">
        <button class="tosides-1 text-wbd">
            <i class="fa fa-arrow-right"></i>
        </button>
        <button class="tosides-2 text-wbd">
            <i class="fa fa-arrow-left"></i>
        </button>
        <button class="toup text-wbd">
            <i class="fa fa-arrow-up"></i>
        </button>
    </div>
    
        <div class='taxo-row '>
            
                



<div class="taxo-col">
    <a href="https://cnjslw.github.io/categories/cpp/">
        <div class="taxo-card">
            <div class="folder-rear"></div>
                
                
                    <div class="taxo-img" style="background-image: url(  );"></div>
                
            <div class="folder-front">
                <div class="taxo-text">
                    <div>Cpp</div>
                    <div class="jipian">5 篇</div>
                </div>
            </div>
        </div>
    </a>
</div>


            
        </div>
    
</div>


            </div>
            <div class="zhuti-r">
                
<div class="zhuti-r-0">
    <div class="zhuti-r-1">
        
        <div id="r1">
            

<div class="about-zuozhe">
    <div class="zuozhe">
        
            <div class="datou">
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/author.png" alt="">
            </div>
        
        <div class="name-jianjie">
            <div class="name">AWei</div>
            <div class="jianjie">
                Be Water, My Friend.
            </div>
        </div>
    </div>

    <div class="type">
        <a href='
                    /posts/
                '>
            <p>文章</p>
            <p>5</p>
        </a>
        <a href='
                    /categories/
                '>
            <p>分类</p>
            <p>1</p>
        </a>
        <a href='
                    /tags/
                '>
            <p>标签</p>
            <p>5</p>
        </a>
    </div>

    <a href="https://github.com/cnjslw">
        <div class="follow">Follow Me</div>
    </a>
    <div class="link">
        
        <a href="https://github.com/cnjslw" class="link-item is-hidden-desktop" title="GitHub">
            <span class="icon"><i class='fa fa-github'></i></span>
        </a>
        
        <a href="https://www.youtube.com" class="link-item is-hidden-desktop" title="YouTube">
            <span class="icon"><i class='fa fa-youtube'></i></span>
        </a>
        
    </div>
</div>
            <div class="mulu">
    <div class="dong"></div>
    <div class="zhi">
        <div class="wenzi">
            <div class="zhi-mulu text-wbd">目录</div>
            <div class="mulu-items">
            </div>
        </div>
    </div>
</div>
            




<div class="other">
    <div class="other-up">
        <div class="other-qita text-wbd">最新文章</div>
        <div class="xian"></div>
    </div>
    <div class="list">
        
            <a href="https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">
                
<a href="https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【模板与泛型编程01】函数模板
            </div>
            <div class="other-summary">函数模板</div>
            <div class="other-date">2022-6-8</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cnjslw.github.io/posts/%E8%A1%A8%E8%BE%BE%E5%BC%8F/">
                
<a href="https://cnjslw.github.io/posts/%E8%A1%A8%E8%BE%BE%E5%BC%8F/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【C&#43;&#43; Primer(edition 5) 04】表达式
            </div>
            <div class="other-summary">表达式</div>
            <div class="other-date">2021-9-9</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cnjslw.github.io/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/">
                
<a href="https://cnjslw.github.io/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【C&#43;&#43; Primer(edition 5) 03】字符串、向量和数组
            </div>
            <div class="other-summary">字符串、向量和数组</div>
            <div class="other-date">2021-9-8</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cnjslw.github.io/posts/%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/">
                
<a href="https://cnjslw.github.io/posts/%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【C&#43;&#43; Primer(edition 5) 02】复合类型
            </div>
            <div class="other-summary">复合类型</div>
            <div class="other-date">2021-9-6</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cnjslw.github.io/posts/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/">
                
<a href="https://cnjslw.github.io/posts/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【C&#43;&#43; Primer(edition 5) 01】变量和基本类型
            </div>
            <div class="other-summary">变量和基本类型</div>
            <div class="other-date">2021-9-4</div>
        </div>
    </div>
</a>
            </a>
        
    </div>
</div>
        </div>
        <div id="r2">
            
        </div> 
    </div>
</div>

            </div>
        </div>
    </div>
</div>


        </div>

        <footer class="footer">
    
        <div class="container">
            <div class="footer-items">
                
                    <div class="footer-item">
                        <i class="fa fa-user"></i> <span id="busuanzi_value_site_pv"></span> |
                        <i class="fa fa-eye"></i> <span id="busuanzi_value_site_uv"></span>
                    </div>
                
                
                    <div class="footer-item">
                        © 2022-2023 <a href="https://github.com/cnjslw">AWei</a>
                    </div>
                
                
                    <div class="footer-item">
                        Theme by <a href="https://github.com/xioyito/NewBee">NewBee</a> | Powered by <a href="https://gohugo.io/">Hugo</a>
                    </div>
                
            </div>
        </div>
    

    
</footer>


        
        <div class="search-root">
    <div class="search-zz"></div>
    <div class="search">
        <div class="sheader anniu">
            <div class="sh-l">
                <input type="text" placeholder='请输入关键词' id="search-key">
                <span class="sclear"><i class="fa fa-close"></i></span>
            </div>
            <div class="sh-r">
                <button>搜索</button>
            </div>
        </div>
        <div class="sbody">
            <div class="sbody-1">
                <div class="stip"></div>
            </div>
        </div>
    </div>
</div>
        









    
    

    
    

    
    

    
    

    
    


<script type="text/javascript">
    var mode_custom = "auto";
    var postsCount =  5 ;
    var arrPosts = [{"link":"https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/","plain":"一、定义函数模板 1、基本范例 1 2 3 4 5 6 7 template \u0026lt;typename T\u0026gt; int compare(const T \u0026amp;v1 , const T \u0026amp;v2) { if(v1 \u0026lt; v2) return -1; if(v2 \u0026lt; v1) return 1; return 0; } 模板定义以关键字 template开始，后接模板形参表，模板形参表是用尖括号\u0026lt;\u0026gt;括住的一个或多个模板形参的列表，用逗号分隔，不能为空。\n模板程序应该尽量减少对实参类型的要求。 函数模板和类模板成员函数的定义通常放在头文件中。 2、模板参数 2.1 类型参数 类型参数前必须使用关键字class或者typename，这两个关键字含义相同，可以互换使用。旧的程序只能使用class。但是有些时候，class并不合适\n2.2 默认参数 1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename T , typename F = FunType\u0026gt; void TestFunc(T i , T j , F funcpoint=mf) { cout\u0026lt;\u0026lt;funcpoint(i,j)\u0026lt;\u0026lt;endl; } int main() { TestFunc(15,16); return 0; } 调用testfunc()函数的时候，不用指定第3个实参，因为第3个参数有默认值。要注意默认参数的写法：针对当前的范例，类型模板参数F给了默认值，函数的形参也给了默认值。默认模板参数F是一个函数指针类型（FuncType），函数参数funcpoint = mf中的mf是函数名，代表函数首地址\n另外，函数模板的默认模板参数可以放在前面（这一点类模板默认模板参数不一样，类模板的模板参数一旦有一个是默认参数，则其后续的参数都需要是默认参数）。\n2.3 非类型参数 除了定义类型参数，还可以在模板中定义非类型参数(nontype parameter) 表示一个值而非一个类型。 当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达，从而允许编译器在编译时实例化模板。\n1 2 3 4 5 6 7 8 9 template\u0026lt;unsigned N , unsigned M\u0026gt; int compare(const char (\u0026amp;p1)[N] , const char (\u0026amp;p2)[M]) { return strcmp(p1,p2); } compare(\u0026#34;hi\u0026#34; , \u0026#34;mom\u0026#34;); //实例化模板 //int compare(const char (\u0026amp;p1)[3] , const char (\u0026amp;p2)[4]) 一个非类型参数可以是一个整形，或者是一个指向对象或函数类型的指针或引用，绑定到非类型整数参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参，必须具有静态的生存期。\n但是，并不是任何类型的参数都可以作为非类型模板参数，一般有以下一些是允许的 （1）整型或枚举类型。 （2）指针类型。 （3）左值引用类型。 （4）auto或decltype(auto)。对于decltype(auto)这个用法，其中的auto理解成要推导的类型，而decltype理解成推导过程采用decltype推导。 （5）可能还有其他类型，请读者自行在学习或阅读他人代码的过程中收集和总结。\n二、 实例化函数模板 这里可以给实例化一个定义：用具体的“类型”代替“类型模板参数”的过程就叫作实例化（也称为代码生成器）。\n1、一个错误的实例化示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template \u0026lt;typename T\u0026gt; T sub(T tv1 , T tv2) { return tv1 - tv2; } int main() { int v1 = 1; int v2 = 2; sub(v1,v2);//return -1 string s1 = \u0026#34;Hello\u0026#34;; string s2 = \u0026#34;World\u0026#34;; sub(s1,s2);//报错 return 0; } 所以，同样一个函数模板，可能以某种方式进行调用是合法的，而换一种方式调用就不合法了。尤其值得注意的是，这种合法性，在==编译阶段就可以由编译器判断出来==，因为这些对Sub()函数模板的调用代码就在这里摆着，编译器有能力在编译时就从这些调用代码中去推断Sub()函数模板中的模板参数T的类型。根据模板参数T的类型，编译器就能够判断出这个类型是否支持减法运算。\n2、编译器视角的实例化 1 2 sub(1,2); sub(1.1 , 2.2); 1 2 //.obj int __cdecl sub\u0026lt;int\u0026gt;(int,int) double __cdecl sub\u0026lt; double \u0026gt;( double, double) 这说明在编译阶段，在对模板进行具体针对某类型的实例化之前，编译器需要查看函数模板的函数体，确定能否针对该类型进行实例化\n当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码\n当编译器遇到类和普通函数\n普通函数 当我们调用一个函数时，编译器只需要掌握函数的声明 类 当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现 我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中 为了生成个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义，所以函数模板与类模板成员函数的定义通常放在头文件中。\n3、模板参数的实例化 1 2 3 4 5 template\u0026lt;typename T\u0026gt; T mydouble(T tmpvalue) { return tmpvalue * 2; } 3.1 显示实例化 1 2 int result = mydouble\u0026lt;int\u0026gt;(16); int result = mydouble\u0026lt;int\u0026gt;(17.7);//warning C4244: “参数”: 从“double”转换到“T”，可能丢失数据 3.2 隐式实例化 1 2 3 cout \u0026lt;\u0026lt; compare(1,0) \u0026lt;\u0026lt; endl; //实例化出一个特别版本的函数 //compare(const int\u0026amp; , const int\u0026amp;); 编译器用函数实参来为我们推断模板实参，实参类型是int。编译器会推断出模板实参为int , 并将它绑定到模板参数T。 编译器用推断出的模板参数来为我们实例化(instantiate) 一个特定版本的函数\n隐式实例化下的空参数列表\n1 auto result = mydouble\u0026lt;\u0026gt;(16.9); \u0026lt; \u0026gt;的作用：\u0026lt; \u0026gt;没什么用处，但是当有一个也叫作mydouble()的普通函数存在时，\u0026lt; \u0026gt;也许就会发挥作用\n3.3 部分实例化 1 2 3 4 5 6 7 8 9 10 11 12 template \u0026lt;typename V,typename T,typename U\u0026gt; V Add(T tv1, U tv2) { return tv1 + tv2; } int main() { Add(15,17.8);//error C2672: “Add”\u0026#34;: 找到匹配的重载函数 error C2783: “V Add(T,U)”: 未能为“V”推导模板参数 Add\u0026lt;double\u0026gt;(1.1 , 2); // return 3.1 return 0; } 通过尖括号指定一部分模板参数，另外一部分模板参数可以让编译器去推断。但是，一旦从某个模板参数开始推断，后续的所有模板参数都需要让编译器推断，==不可以自己指定第1个类型V和第3个类型U，然后推断中间第2个类型T，编译器不支持这种语法。==\n3.4 特化 1 2 3 4 5 6 7 template \u0026lt;typename T, typename U\u0026gt; void tfunc(T\u0026amp; tmprv, U\u0026amp; tmprv2) { cout \u0026lt;\u0026lt; \u0026#34;tfunc泛化版本\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; tmprv \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; tmprv2 \u0026lt;\u0026lt; endl; } 3.4.1 全特化 所谓全特化，就是把tfunc()这个泛化版本中的所有模板参数都用具体的类型代替，构成一个特殊的版本（全特化版本），既然所有模板参数都用具体的类型代替了，那么tfunc()泛化版本中template后面尖括号中的内容就变成空了。\n1 2 3 4 5 template\u0026lt;\u0026gt; void tfunc\u0026lt;int , double\u0026gt;(int\u0026amp; tmprv, double\u0026amp; tmprv2) { cout\u0026lt;\u0026lt;\u0026#34;tfunc特化\u0026#34;\u0026lt;\u0026lt;endl; } 全特化实际上等价于实例化一个函数模板，并不等价于一个函数重载\n1 2 3 4 void tfunc(int\u0026amp; tmprv, double\u0026amp; tmprv2) { cout\u0026lt;\u0026lt;\u0026#34;tfunc函数重载\u0026#34;\u0026lt;\u0026lt;endl; } ==调用优先级：普通函数 \u0026gt; 函数模板特化 \u0026gt; 函数模板泛化==\n3.4.2 偏特化 （1）模板参数数量上的偏特化 What is : 特化第1个模板参数类型为double类型，但第2个模板参数不特化\n实际上，从模板参数数量上来讲，函数模板不能偏特化，只有类模板才能偏特化\n（2）模板参数范围上的偏特化 What is : 所谓“参数范围”，比如原来是int类型，如果变成const int类型，那么与int类型相比，const int类型的范围就变小了；再比如，如果原来是任意类型T，现在变成T *（从任意类型缩小为任意指针类型），那这个类型的范围也是变小了；还有T \u0026amp;（左值引用）、T\u0026amp;\u0026amp;（右值引用），对于T，从类型范围上都属于变小了。\n对于函数模板，也不存在模板参数范围上的偏特化。因为这种所谓模板参数范围上的偏特化，实际上是函数模板的重载\n1 2 3 4 5 template \u0026lt;typename T , typename U\u0026gt; void tfunc(const T\u0026amp; tmprv1, U\u0026amp; tmprv2) { cout\u0026lt;\u0026lt;\u0026#34;函数模板的参数范围偏特化本质上是函数模板的重载\u0026#34;\u0026lt;\u0026lt;endl; } 3.5 实例化模板的返回值问题 显示实例化 1 Add\u0026lt;double\u0026gt;(1.1 , 3); auto 使用auto结合decltype完成返回值类型推断 1 2 3 4 5 6 template \u0026lt;typename V,typename T,typename U\u0026gt; auto Add(T tv1, U tv2) //auto Add(T tv1, U tv2) -\u0026gt; decltype(tv1 + tv2) { return tv1 + tv2; } 三、特异的语法 1、省略参数 不管是类型模板参数还是非类型模板参数，如果在代码中没有用到这个参数，则参数名可以省略\n1 2 3 template \u0026lt;typename T ,int value\u0026gt; auto Add2() {return 100;} 可以做如下省略\n1 2 3 template \u0026lt;typename ,int\u0026gt; auto Add2() {return 100;} 2、\u0026ldquo;无用\u0026quot;的typename 类型前面可以增加一个typename修饰以明确标识一个类型。有的时候为了表明其后面是一个类型，也需要用typename修饰\n1 2 3 4 5 template \u0026lt;typename T , typename int value\u0026gt; auto Add() { return 100; } 四、模板函数在工程中 1、inline和constexpr的含函数模板 inline或 constexpr说明符放在模板参数列表之后，返回类型之前：\n1 2 template \u0026lt;typename T\u0026gt; inline T min(const T\u0026amp;, const T\u0026amp;); template \u0026lt;typename T\u0026gt; constexpr T min(const T\u0026amp; , const T\u0026amp;); 2、编写与类型无关的代码 1 2 3 4 5 6 template \u0026lt;typename T\u0026gt; int compare(const T \u0026amp;v1 , const T \u0026amp;v2) { if(less\u0026lt;T\u0026gt;()(v1,v2)) return -1; if(less\u0026lt;T\u0026gt;()(v2,v1)) return 1; return 0; } 这样写的好处\nconst T \u0026amp;作为函数参数可以避免实参是不可调用类型 less\u0026lt;T\u0026gt;()使用标准库可以避免有些类型没有定义\u0026gt;的比较 ","pubDate":"2022-06-08","title":"【模板与泛型编程01】函数模板"},{"link":"https://cnjslw.github.io/posts/%E8%A1%A8%E8%BE%BE%E5%BC%8F/","plain":"表达式由一个或多个运算对象(operand)组成，对表达式求值将得到一个结果(result )。字面值和变量是最简单的表达式(expression),其结果就是字面值和变量的值。把一个运算符(operator)和一个或多个运算对象组合起来可以生成较复杂的表达式。 ^0c892c\n一、表达式基础 运算对象转换：小整数类型会被提升为较大的整数类型 重载运算符：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。 左值和右值： C中原意：左值可以在表达式左边，右值不能。 C++：当一个对象被用作右值的时候，用的是对象的值（内容）； 被用做左值时，用的是对象的身份（在内存中的位置）。 求值顺序：int i = f1() + f2() 先计算f1() + f2(),再计算int i = f1() + f2()。但是f1和f2的计算先后不确定 但是，如果f1、f2都对同一对象进行了修改，因为顺序不确定，所以会编译出错，显示未定义 二、算术运算符 溢出：当计算的结果超出该类型所能表示的范围时就会产生溢出。 bool类型不应该参与计算 1 2 3 4 bool b=true; bool b2=-b; //仍然为true //b为true，提升为对应int=1，-b=-1 //b2=-1≠0，所以b2仍未true 取余运算m%n，结果符号与m相同 三、逻辑运算符 短路求值：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。先左再右 小技巧，声明为引用类型可以避免对元素的拷贝，如下，如string特别大时可以节省大量时间。 1 2 3 4 vector\u0026lt;string\u0026gt; text; for(const auto \u0026amp;s: text){ cout\u0026lt;\u0026lt;s; } 四、赋值运算符 赋值运算的返回结果时它的左侧运算对象，且是一个左值。类型也就是左侧对象的类型。 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。 赋值运算符满足右结合律，这点和其他二元运算符不一样。 ival = jval = 0;等价于ival = (jval = 0); 赋值运算优先级比较低，使用其当条件时应该加括号。 复合赋值运算符，复合运算符只求值一次，普通运算符求值两次。（对性能有一点点点点影响） 任意复合运算符op等价于a = a op b; 五、递增递减运算符 前置版本j = ++i，先加一后赋值 后置版本j = i++，先赋值后加一 优先使用前置版本，后置多一步储存原始值。（除非需要变化前的值）\n混用解引用和递增运算符 *iter++等价于*(iter++)，递增优先级较高\n1 2 3 auto iter = vi.begin(); while (iter!=vi.end()\u0026amp;\u0026amp;*iter\u0026gt;=0) cout\u0026lt;\u0026lt;*iter++\u0026lt;\u0026lt;endl;\t// 输出当前值，指针向前移1 简洁是一种美德，追求简洁能降低程序出错可能性\n六、成员访问运算符 ptr-\u0026gt;mem等价于(*ptr).mem\n注意.运算符优先级大于*，所以记得加括号\n七、条件运算符 条件运算符（?:）允许我们把简单的if-else逻辑嵌入到单个表达式中去，按照如下形式：cond? expr1: expr2\n可以嵌套使用，右结合律，从右向左顺序组合\n1 2 3 finalgrade = (grade \u0026gt; 90) ? \u0026#34;high pass\u0026#34;:(grade \u0026lt; 60) ? \u0026#34;fail\u0026#34; : \u0026#34;pass\u0026#34;; //等价于 finalgrade = (grade \u0026gt; 90) ? \u0026#34;high pass\u0026#34;: ((grade \u0026lt; 60) ? \u0026#34;fail\u0026#34; : \u0026#34;pass\u0026#34;); 输出表达式使用条件运算符记得加括号，条件运算符优先级太低。 八、位运算符 用于检查和设置二进制位的功能。\n位运算符是作用于整数类型的运算对象。 二进制位向左移（\u0026lt;\u0026lt;）或者向右移（\u0026gt;\u0026gt;），移出边界外的位就被舍弃掉了。 位取反（~）（逐位求反）、与（\u0026amp;）、或（|）、异或（^） 有符号数负值可能移位后变号，所以强烈建议位运算符仅用于无符号数。\n应用：\n1 2 3 4 5 unsigned long quiz1 = 0; // 每一位代表一个学生是否通过考试 1UL \u0026lt;\u0026lt; 12; // 代表第12个学生通过 quiz1 |= (1UL \u0026lt;\u0026lt; 12); // 将第12个学生置为已通过 quiz1 \u0026amp;= ~(1UL \u0026lt;\u0026lt; 12); // 将第12个学生修改为未通过 bool stu12 = quiz1 \u0026amp; (1UL \u0026lt;\u0026lt; 12); // 判断第12个学生是否通过 位运算符使用较少，但是重载cout、cin大家都用过\n位运算符满足左结合律，优先级介于中间，使用时尽量加括号。\n九、sizeof运算符 返回一条表达式或一个类型名字所占的字节数。 返回的类型是 size_t的常量表达式。 sizeof并不实际计算其运算对象的值。 两种形式： sizeof (type)，给出类型名 sizeof expr，给出表达式 可用sizeof返回数组的大小 1 2 3 4 5 int ia[10]; // sizeof(ia)返回整个数组所占空间的大小 // sizeof(ia)/sizeof(*ia)返回数组的大小 constexpr size_t sz = sizeof(ia)/sizeof(*ia); int arr[sz]; 十、逗号运算符 从左向右依次求值。\n左侧求值结果丢弃，逗号运算符结果是右侧表达式的值。\n十一、类型转换 1、隐式类型转换 设计为尽可能避免损失精度，即转换为更精细类型。\n比 int类型小的整数值先提升为较大的整数类型。 条件中，非布尔转换成布尔。 初始化中，初始值转换成变量的类型。 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型。 函数调用时也会有转换。 1.1 算术转换 算术转换(arithmetic conversion) 的含义是把一种算术类型转换成另外一种算术类型\n1.1.1 整型提升 常见的char、bool、short能存在int就会转换成int，否则提升为unsigned int wchar_t,char16_t,char32_t提升为整型中int,long,long long ……最小的，且能容纳原类型所有可能值的类型。 1.1.2 无符号类型的运算对象 都带符号 or 都不带符号，小类型转大类型 一个带符号，另一个不带符号 带符号\u0026gt;不带符号：无符号能存入带符号类型，则转化为带符号类型，反之则转为无符号类型 带符号≤不带符号：带符号转为不带符号 不同符号的类型转换带来了隐患，比如 unsigned int 类型的变量大于int类型的变量，则有转为为 int-\u0026gt;unsigned int , 如果恰巧这个int 是一个负数，则转化为就会产生歧义 1.2 其他转换 p143\n2、显式类型转换（尽量避免） 2.1 static_cast 任何明确定义的类型转换，只要不包含底层const，都可以使用。\n1 2 3 int i,j ; cin \u0026gt;\u0026gt; i \u0026gt;\u0026gt; j; double slope = static_cast\u0026lt;double\u0026gt;(j)/i; 常用于较大算数运算符转换为较小算数运算符，旨在告诉编译器，不在乎精度的损失。\n2.2 dynamic_cast 支持运行时类型识别。\n2.3 const_cast 只能改变运算对象的底层const，一般可用于去除const性质。\n1 2 const char *pc; char *p = const_cast\u0026lt;char*\u0026gt;(pc) 只有const_cast 可以消除底层const，其他类型转换会报错，但是如果被消除的变量本身就是常量对象，通过const_cast消除其底层const后再修改，就是未定义的行为\n2.4 reinterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释。\n3、旧式强制类型转换 1 char *pc = (char *) ip; //ip原类型为指向整数的指针 十二、运算符优先级表 《C++ Primer（edition 5）》p166\n十三、常量表达式 常量表达式是指不会改变并且在编译过程中就能得到计算结果的表达式，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。\n1 2 const int max_file = 20 ; const int limit = max_file + 1 ; ","pubDate":"2021-09-09","title":"【C++ Primer(edition 5) 04】表达式"},{"link":"https://cnjslw.github.io/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/","plain":"一、string 标准库类型string表示可变长的字符序列。 #include \u0026lt;string\u0026gt;，然后 using std::string; string对象：注意，不同于字符串字面值。 1、定义和初始化string对象 定义string对象的方式：\n方式 解释 string s1 默认初始化，s1是个空字符串 string s2(s1) s2是s1的副本 string s2 = s1 等价于s2(s1)，s2是s1的副本 string s3(\u0026quot;value\u0026quot;) s3是字面值“value”的副本，除了字面值最后的那个空字符外 string s3 = \u0026quot;value\u0026quot; 等价于s3(\u0026quot;value\u0026quot;)，s3是字面值\u0026quot;value\u0026quot;的副本 string s4(n, 'c') 把s4初始化为由连续n个字符c组成的串 [[顺序容器#^5f2418|构造string的其他方法]]\n拷贝初始化（copy initialization）：使用等号=将一个已有的对象拷贝到正在创建的对象。 直接初始化（direct initialization）：通过括号给对象赋值。 2、string对象上的操作 string的操作：\n操作 解释 os \u0026lt;\u0026lt; s 将s写到输出流os当中，返回os is \u0026gt;\u0026gt; s 从is中读取字符串赋给s，字符串以空白分割，返回is getline(is, s) 从is中读取一行赋给s，返回is s.empty() s为空返回true，否则返回false s.size() 返回s中字符的个数 s[n] 返回s中第n个字符的引用，位置n从0计起 s1+s2 返回s1和s2连接后的结果 s1=s2 用s2的副本代替s1中原来的字符 s1==s2 如果s1和s2中所含的字符完全一样，则它们相等；string对象的相等性判断对字母的大小写敏感 s1!=s2 同上 \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;= 利用字符在字典中的顺序进行比较，且对字母的大小写敏感（对第一个不相同的位置进行比较） string io： 执行读操作\u0026gt;\u0026gt;：忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止。 getline：读取一整行，包括空白符。 s.size()返回的时string::size_type类型，记住是一个无符号类型的值，不要和int混用 s1+s2使用时，保证至少一侧是string类型。string s1 = \u0026quot;hello\u0026quot; + \u0026quot;world\u0026quot; // 错误，两侧均为字符串字面值 字符串字面值和string是不同的类型。 3、处理string对象中的字符 ctype.h vs. cctype：C++修改了c的标准库，名称为去掉.h，前面加c。 如c++版本为cctype，c版本为ctype.h\n尽量使用c++版本的头文件，即cctype cctype头文件中定义了一组标准函数：\n函数 解释 isalnum(c) 当c是字母或数字时为真 isalpha(c) 当c是字母时为真 iscntrl(c) 当c是控制字符时为真 isdigit(c) 当c是数字时为真 isgraph(c) 当c不是空格但可以打印时为真 islower(c) 当c是小写字母时为真 isprint(c) 当c是可打印字符时为真 ispunct(c) 当c是标点符号时为真 isspace(c) 当c是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） isupper(c) 当c是大写字母时为真 isxdigit(c) 当c是十六进制数字时为真 tolower(c) 当c是大写字母，输出对应的小写字母；否则原样输出c toupper(c) 当c是小写字母，输出对应的大写字母；否则原样输出c 遍历字符串：使用范围for（range for）语句： for (auto c: str)，或者 for (auto \u0026amp;c: str)使用引用直接改变字符串中的字符。 （C++11） str[x],[]输入参数为string::size_type类型，给出int整型也会自动转化为该类型 二、vector [[C++Primer#第九章|深层次的介绍]]\nvector是一个容器，也是一个类模板； #include \u0026lt;vector\u0026gt; 然后 using std::vector; 容器：包含其他对象。 类模板：本身不是类，但可以实例化instantiation(编译器根据模板创建类或函数的过程称为实例化)出一个类。 vector是一个模板， vector\u0026lt;int\u0026gt;是一个类型。 通过将类型放在类模板名称后面的尖括号中来指定类型，如vector\u0026lt;int\u0026gt; ivec。 1、定义和初始化vector对象 初始化vector对象的方法\n方法 解释 vector\u0026lt;T\u0026gt; v1 v1是一个空vector，它潜在的元素是T类型的，执行默认初始化 vector\u0026lt;T\u0026gt; v2(v1) v2中包含有v1所有元素的副本 vector\u0026lt;T\u0026gt; v2 = v1 等价于v2(v1)，v2中包含v1所有元素的副本 vector\u0026lt;T\u0026gt; v3(n, val) v3包含了n个重复的元素，每个元素的值都是val vector\u0026lt;T\u0026gt; v4(n) v4包含了n个重复地执行了值初始化的对象 vector\u0026lt;T\u0026gt; v5{a, b, c...} v5包含了初始值个数的元素，每个元素被赋予相应的初始值 vector\u0026lt;T\u0026gt; v5={a, b, c...} 等价于v5{a, b, c...} 列表初始化： vector\u0026lt;string\u0026gt; v{\u0026quot;a\u0026quot;, \u0026quot;an\u0026quot;, \u0026quot;the\u0026quot;}; （C++11） 元素由内默认初始化有两个限制，其一有些类必须明确的提供初始值，其二,如果只提供了元素的数量，而没有设定初始值，只能使用直接初始化。 如果初始化时使用了花括号的形式，但是提供了值又不能用来列表初始化就要考虑用这样的值来构造vector对象。 2、向vector对象中添加元素 v.push_back(e) 在尾部增加元素。 3、其他vector操作 vector支持的操作：\n操作 解释 v.emtpy() 如果v不含有任何元素，返回真；否则返回假 v.size() 返回v中元素的个数 v.push_back(t) 向v的尾端添加一个值为t的元素 v[n] 返回v中第n个位置上元素的引用 v1 = v2 用v2中的元素拷贝替换v1中的元素 v1 = {a,b,c...} 用列表中元素的拷贝替换v1中的元素 v1 == v2 v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同 v1 != v2 同上 \u0026lt;,\u0026lt;=,\u0026gt;, \u0026gt;= 以字典顺序进行比较 范围for语句内不应该改变其遍历序列的大小。 vector对象（以及string对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素。 三、迭代器iterator 所有标准库容器都可以使用迭代器。 类似于指针类型，迭代器也提供了对对象的间接访问。 1、使用迭代器 vector\u0026lt;int\u0026gt;::iterator iter。 auto b = v.begin();返回指向第一个元素的迭代器。 auto e = v.end();返回指向最后一个元素的下一个（哨兵，尾后,one past the end）的迭代器（off the end）。 如果容器为空， begin()和 end()返回的是同一个迭代器，都是尾后迭代器。 使用解引用符*访问迭代器指向的元素。 养成使用迭代器和!=的习惯（泛型编程）。 容器：可以包含其他对象；但所有的对象必须类型相同。 迭代器（iterator）：每种标准容器都有自己的迭代器。C++倾向于用迭代器而不是下标遍历元素。 const_iterator：只能读取容器内元素不能改变。 箭头运算符： 解引用 + 成员访问，it-\u0026gt;mem等价于 (*it).mem 谨记：但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。 标准容器迭代器的运算符:\n运算符 解释 *iter 返回迭代器iter所指向的元素的引用 iter-\u0026gt;mem 等价于(*iter).mem ++iter 令iter指示容器中的下一个元素 --iter 令iter指示容器中的上一个元素 iter1 == iter2 判断两个迭代器是否相等 2、迭代器运算 vector和string迭代器支持的运算：\n运算符 解释 iter + n 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 iter - n 迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。 iter1 += n 迭代器加法的复合赋值语句，将iter1加n的结果赋给iter1 iter1 -= n 迭代器减法的复合赋值语句，将iter2减n的加过赋给iter1 iter1 - iter2 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。 \u0026gt;、\u0026gt;=、\u0026lt;、\u0026lt;= 迭代器的关系运算符，如果某迭代器 difference_type：保证足够大以存储任何两个迭代器对象间的距离，可正可负。 三、数组 相当于vector的低级版，长度固定。 如果不清楚元素的确切个数，请使用vector。 1、定义和初始化内置数组 初始化：char input_buffer[buffer_size];，长度必须是const表达式，或者不写，让编译器自己推断。 数组不允许直接赋值给另一个数组。 字符数组的特殊性 : 字符数组有一种额外的初始化形式，可以用字符串字面值对此类数组初始化。一定要注意字符串字面值的结尾处还有一个空字符。 1 2 char a1[] = {\u0026#39;c\u0026#39; , \u0026#39;+\u0026#39;, \u0026#39;+\u0026#39;};//列表初始化,没有空字符 char a2[]=\u0026#34;C++\u0026#34; //自动添加表示字符串结束的空字符 理解复杂的数组声明 : 由内向外，从右向左。 用数组初始化 vector： int a[] = {1,2,3,4,5}; vector\u0026lt;int\u0026gt; v(begin(a), end(a)); 。 2、访问数组元素 数组下标的类型：size_t 。 字符数组的特殊性：结尾处有一个空字符，如 char a[] = \u0026quot;hello\u0026quot;; 。 3、数组和指针 使用数组时，编译器一般会把它转换成指针。 标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值。 int *p=a[2] ; int k= p[-2]; //k=a[0]* 指针访问数组：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针。 当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组。当使用decltype的关键字时，上述转换不会发生。 在宿主中引入begin和end函数来获取数组的首元素和数组的尾后元素。 两个指向数组的指针相减的结果是它们之间的距离。 结果类型为ptrdiff_t的标准库类型。 4、C风格字符串 C风格的字符串是一种特殊的字符数组\n1 2 const char *c = \u0026#34;Halo,World\u0026#34;; const char c[] = {\u0026#39;H\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;,\u0026#39;,\u0026#39;W\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;r\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;\\0\u0026#39;}; 两者等价，请注意，该数组的最后一个字符为空字符\\0，这也被称为字符串结束字符，因为它告诉编译器， 字符串到此结束。这种C风格字符串是特殊的字符数组，因为总是在最后一个字符后加上空字符\\0，在代码中使用字符串字面量时，编译器将负责在它后面添加\\0。 在数组中间插入\\0并不会改变数组的长度，而只会导致将该数组作为输入的字符串处理将到这 个位置结束，如果不加\\0，则会导致在打印或者计算长度等操作是无法停止或者输出垃圾数据，从而程序奔溃。\nC风格字符串不仅使用起来不方便而且极易引发程序漏洞是, 诸多安全问题的根本原因。\n从C继承来的字符串。 用空字符结束（\\0）。 对大多数应用来说，使用标准库 string比使用C风格字符串更安全、更高效。 获取 string 中的 cstring ： const char *str = s.c_str(); 1 2 3 char ca[] = {\u0026#39;C\u0026#39; , \u0026#39;+\u0026#39; , \u0026#39;+\u0026#39;}; cout \u0026lt;\u0026lt; strlen(ca)\u0026lt;\u0026lt;endl; //严重错误CA没有以空字符结束。 Strlen函数将有可能沿着ca在内存中的位置不断向前寻找，直到遇到空字符才停下。 C标准库String函数，定义在\u0026lt;cstring\u0026gt; 中：\n函数 介绍 strlen(p) 返回p的长度，空字符不计算在内 strcmp(p1, p2) 比较p1和p2的相等性。如果p1==p2，返回0；如果p1\u0026gt;p2，返回一个正值；如果p1\u0026lt;p2，返回一个负值。 strcat(p1, p2) 将p2附加到p1之后，返回p1 strcpy(p1, p2) 将p2拷贝给p1，返回p1 尽量使用vector和迭代器，少用数组\n5、与旧代码的接口 混用string对象和C风格字符串\n允许使用以空字符结束的字符数组来初始化string对象，或为string对象赋值。 允许使用以空字符结束的字符数组作为string对象加法运算中的一个对象，不能两个运算对象都是 ， 在string对象的复合赋值运算中，允许使用以空字符结束的字符数组作为右侧的运算对象。 上述性质反过来只能用string专门提供的一个名为c_str的成员函数来初始化指向字符的指针。string s =\u0026quot;C++\u0026quot; ; const char *str = s.c_str();该函数的返回结果是一个指针，该指针指向的一个以空字符结束的字读数组, 也就是C风格的字符串，而这个数组所存的数据恰好与那个string对象是一样的，结果指针的类型是const char*，从而确保我们不会改变字符数组的类型。 六、多维数组 多维数组的初始化： int ia[3][4] = {{0,1,2,3}, ...}。 使用范围for语句时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。 七、动态数组 使用 new和 delete表达和c中malloc和free类似的功能，即在堆（自由存储区）中分配存储空间。 定义： int *pia = new int[10]; 10可以被一个变量替代。 释放： delete [] pia;，注意不要忘记[]。 ","pubDate":"2021-09-08","title":"【C++ Primer(edition 5) 03】字符串、向量和数组"},{"link":"https://cnjslw.github.io/posts/%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/","plain":"一、引用 1、左值引用 1.1、引用的定义 引用是一个对象的别名，引用类型引用（refer to）另外一种类型。如int \u0026amp;refVal = val;。 引用的类型要和与之绑定的对象(对象)严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起\n引用必须初始化。 引用和它的初始值是绑定在一起的，而不是拷贝。一旦定义就不能更改绑定为其他的对象 1.2、引用规则的两种例外情况 第一个例外 在初始化常量引用时允许用任意表达式作为初始值，只要表达式的结果能够转换为引用的类型即可，允许一个常量引用绑定非常量的对象，字面值，甚至一个表达式 ^d7c880\n1 2 3 4 5 int i = -42; const int \u0026amp;rl = i;\t//允许将 const int\u0026amp; 绑定到一个普通int对象上 const int \u0026amp;r2 = 42;\t//正确：rl是一个常量引用 const int \u0026amp;r3 = rl*2;\t//正确：r3是一个常量引用 int \u0026amp;r4 = rl*2;\t//\t错误：r4是一个普通的非常量引用 1 2 double dval = 3.14; const int \u0026amp;ri = dval; 理解这种例外的核心就是搞清楚当一个常量引用被绑定到另外一种类型上发生了什么。\n1 2 3 const int temp = dval; //由双精度浮点数生成一个临时的整型常量 const int \u0026amp;ri = temp; //让ri绑定这个临时量 在这种情况下，ri绑定了一个临时量(temporary)对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。c++程序员们常常把临时量对象简称为临时量。\n第二个例外 存在继承关系的类是一个例外，可以将基类的指针或者引用绑定到派生类对象上 可以将基类的指针或引用绑定到派生类对象上有一层极为至要的含义：当使用基类的 引用（或指针）时，实际我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。 ^9b1798\n1.3 sizeof()和引用 sizeof()取的是引用变量的类型大小\n3、为什么要有引用 避免无休止的拷贝，极大提高了性能\n二、指针 1、定义 指针是一种 \u0026ldquo;指向（point to）\u0026ldquo;另外一种类型的复合类型。也可以说是指向内存单元的特殊变量。指针的类型与所指向的对象类型必须一致\n1.1 声明指针 int *ip1;，从右向左读有助于阅读，ip1是指向int类型的指针。\n1.2 取变量地址 指针存放某个对象的地址，获取对象的地址： int i=42; int *p = \u0026amp;i;。 \u0026amp;是取地址符。\n1.3 利用指针访问对象 使用解引用符（*）来访问对象 指针访问对象： cout \u0026lt;\u0026lt; *p;\n1.4 sizeof()和指针 sizeof()用于普通变量是指变量类型的内存大小，即编译器为变量预留的内存空间大小。 但是，当用于指针变量时，取决于编译器和操作系统存储地址所需的内存空间，与指向什么类型的变量空间是没有关系的。\n2、指针操作 2.1 递增和递减 如果对指针执行递增或递减运算，编译器将认为要指向内存块中相邻的值（并假定这个值的 类型与前一个值相同）,而不是相邻的字节（除非值的长度刚好是1字节，如char）。 将指针递增或递减的结果 将指针递增或递减时，其包含的地址将增加或减少指向的数据类型的sizeof （并不一定是1字节）。这样，编译器将琉保指针不会指向数据的中间或末尾，而只会指向数据的开头。 如果声明了如下指针：\n1 Type* pType = Address; 则执行++piype后，pType 将包含（指向）Address + sizeoffiype。\n2.2 将关键字const用于指针 ![[变量和基本类型#3、指针和const|指针和const]]\n2.3 将指针传递给函数 3、指针定义的两种例外情况 指针的类型与所指向的对象类型必须一致这个规则有两种例外 第一种 允许令一个指向常量的指针指向一个非常量对象 ^413a8b\n1 2 3 const double *cptr ; double dval = 3.14 ; cptr = \u0026amp;dval ; 和常量引用一样，指向常量的指针也没有规定其所指的对象必须是个常量。所谓的指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过 其他途径改变。 可以这样想，所谓的常量引用和常量指针，不过是指针和引用的“自以为是”，他们觉得自己指向了常量，所以自觉的不去改变所指向的对象的值罢了。\n第二种 [[复合类型#^9b1798|继承关系中存在例外]]\n4、指针的值的四种状态 1.指向一个对象； 2.指向紧邻对象的下一个位置； 3.空指针； 4.无效指针。\n对无效指针的操作均会引发错误，第二种和第三种虽为有效的，但理论上是不被允许的\n5、空指针 空指针不指向任何对象。使用int *p=nullptr;来使用空指针。\n6、空类型指针 void*指针可以存放任意对象的地址。因无类型，仅操作内存空间，对所存对象无法访问。 利用void*指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void*指针。不能直接操作void*指针所指的对象，因为我们并不知道 这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。\n7、使用指针时常犯的错误 7.1 野指针 “野指针”则是不确定其具体指向的指针。“野指针”最常来自于未初始化的指针\n1 2 void *p; // 此时 p 是“野指针” 因为“野指针”可能指向任意内存段，因此它可能会损坏正常的数据，也有可能引发其他未知错误，所以C语言中的“野指针”危害性甚至比“悬空指针”还要严重。在实际的C语言程序开发中，定义指针时，一般都要尽量避免“野指针”的出现（赋初值）：\n1 void *p = NULL; 7.2 内存泄漏 这可能是C++应用程序最常见的问题之一：运行时间越长，占用的内存越多，系统越慢。如果在使用new动态分配的内存不再需要后，程序员没有使用配套的delete释放，通常就会出现这种情况。\n7.3 指向无效的内存单元 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { // uninitialized pointer (bad) int* pTemperature; cout \u0026lt;\u0026lt; \u0026#34;Is it sunny (y/n)?\u0026#34; \u0026lt;\u0026lt; endl; char Userinput = \u0026#39;y\u0026#39;; cin \u0026gt;\u0026gt; Userinput; if (Userinput == \u0026#39;y\u0026#39;) { pTemperature = new int; *pTemperature = 30; } // pTemperature contains invalid value if user entered \u0026#39;n\u0026#39; cout « \u0026#34;Temperature is: \u0026#39; « *pTemperature; // delete also being invoked for those cases new wasn\u0026#39;t done delete pTemperature; return 0; } 7.4 悬空指针 指针可以指向一块内存，如果这块内存稍后被操作系统回收（被释放），但是指针仍然指向这块内存，那么，此时该指针就是“悬空指针”\n三、指针与引用的不同 本质上： 引用本质是一个指针\n使用上： 指针与引用类似，都实现了对其他对象的间接访问。 然而指针与引用相比也有很多不同点。\n其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在==指针的生命周期内它可以先后指向几个不同的对象==，但是引用一旦初始化后就不可以再改变。\n其二，==指针无须在定义时赋初值==。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有个不确定的值。\n其三，作为参数传递时，指针是==拷贝==同样的地址，如果函数作用域中改变指针变量的地址，则不再影响实参。引用参数实质上==传递的是实参本身==，即传递进来的不是实参的一个拷贝，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。\n四、理解复合类型的声明 变量的定义包括一个基本数据类型(base type) 和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。也就是说， 条定义语句可能定义出不同类型的变量：\n1 int i = 1024, *p = \u0026amp;i , \u0026amp;r = i; 甚至可以有多个声明符，组合出更为复杂的变量\n指向指针的指针\n1 int **p; 指向指针的引用 要理解变量到底是什么，最简单的方法就是==从右向左==阅读r的定义，距离变量名最近的符号对变量的类型有直接的影响\n1 2 3 4 5 6 int i = 42; int *p; int *\u0026amp;r = p; //r是一个引用变量，引用一个指向int型变量的指针变量 r = \u0026amp;i; *r=0; ","pubDate":"2021-09-06","title":"【C++ Primer(edition 5) 02】复合类型"},{"link":"https://cnjslw.github.io/posts/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/","plain":"一、基本内置类型 基本算数类型\n类型 含义 最小尺寸 bool 布尔类型 8bits char 字符 8bits wchar_t 宽字符 16bits char16_t Unicode字符 16bits char32_t Unicode字符 32bits short 短整型 16bits int 整型 16bits (在32位机器中是32bits) long 长整型 32bits long long 长整型 64bits （是在C++11中新定义的） float 单精度浮点数 6位有效数字 double 双精度浮点数 10位有效数字 long double 扩展精度浮点数 10位有效数字 如何选择类型\n1.当明确知晓数值不可能是负数时，选用无符号类型； 2.使用int执行整数运算。一般long的大小和int一样，而short常常显得太小。除非超过了int的范围，选择long long。 3.算术表达式中不要使用char或bool。 4.浮点运算选用double。 二、常量 在C++中，常量类似于变量，只是不能修改。与变量一样，常量也占用内存空间，并使用名称标识为其预留的空间的地址，但不能覆盖该空间的内容。在C++中，常量可以是： •字面常量； •使用关键字const声明的常量； •使用关键字constexpr声明的常量表达式（C++11新增的）; •使用关键字enum声明的枚举常量； •使用#define定义的常量（已摒弃，不推荐）。\n1、使用constexpr声明常量 在C++11之前，C++就支持常量表达式的概念，只是没有关键字constexpr，在程序清单3.5中， 22.0/7是一个常量表达式，C++11之前的编译器也支持它。然而，C++11之前的编译器不允许定义在编译阶段计算的函数。 在C++11中，可以编写下面这样的代码：\n1 constexpr double GetPi() {return 22.0 / 7;} 还可将GetPi与另一个常量一起使用，如下所示：\n1 constexpr double TwicePi() {return 2 * GetPi();} 乍一看，const和constexpr之间的差别很小，但从编译器和应用程序的角度看，关键字Constexpr 提供了优化应用程序的可能性。对于第二条语句，如果使用const,将在运行阶段执行计算，但使用遵 守C++11的编译器时，将在编译阶段计算该表达式的值，这提高了应用程序的运行速度。\n2、字面值常量 一个形如42的值被称作字面值常量（literal）。 整型和浮点型字面值。 字符和字符串字面值。 使用空格连接，继承自C。 字符字面值：单引号， 'a' 字符串字面值：双引号， \u0026quot;Hello World\u0026quot;\u0026quot; 分多行书写字符串。 1 2 std:cout\u0026lt;\u0026lt;\u0026#34;wow, a really, really long string\u0026#34; \u0026#34;literal that spans two lines\u0026#34; \u0026lt;\u0026lt;std::endl; 转义序列。\\n、\\t等。 布尔字面值。true，false。 指针字面值。nullptr 字符串型实际上时常量字符构成的数组，结尾处以'\\0'结束，所以字符串类型实际上长度比内容多1。\n3、使用const将变量声明为常量 [[变量和基本类型#五、const限定符]]\n4、枚举常量 在有些情况下，变量只能有一组特定的取值\n1 2 3 4 5 6 7 8 9 10 11 enum RainbowColors { Violet = 0 , //此后每个值都递增1，默认0开始 Indigo, Blue, Yellow, Orange, Red } RainbowColors MyWorldColor = Blue; 5、使用#define定义常量 【摒弃】 这是一个预处理器宏，让预处理器将随后出现的所有Pi都替换为3.14286。预处理器将进行文本替换，而不是智能替换。编译器既不知道也不关心常量的类型。\n1 #define Pi 3.14 三、变量 1、什么是变量 变量提供一个具名的，可供程序操作的存储空间 变量类型向编译器指出了变量可存储的数据的性质，编译器将为变量预留必要的空间。变量名由程序员选择，它替代了变量值在内存中的存储地址，但更友好。除非给变量赋初值，否则无法确保相应内存单元的内容是什么，这对程序可能不利。因此，初始化虽然是可选的，但对变量初始化通常是 一个不错的编程习惯。程序清单3.1将用户提供的两个数字相乘，演示了如何在程序中声明、初始化。\n变量名 是内存地址的别名，方便存取 类型 是告诉编译器可以存什么样的数据,需要多大的内存空间 初始化 是可选的，不然无法确保内存中的数据是啥 变量提供一个具名的、可供程序操作的存储空间。 C++中变量和对象一般可以互换使用。\n2、变量定义（define） 定义形式：类型说明符（type specifier） + 一个或多个变量名组成的列表。用于初始化变量的值可以是任意复杂的[[表达式#^0c892c|表达式]]\n1 int sum = 0, value, units_sold = 0; 3、初始化 初始化（initialize）：对象在创建时获得了一个特定的值。 初始化不是赋值！ 初始化 = 创建变量 + 赋予初始值 赋值 = 擦除对象的当前值 + 用新值代替\n3.1 直接初始化 略\n3.2 列表初始化(C++11 全面支持) 使用花括号{}\n1 2 3 4 int units_sold = 0; int units_sold = {0}; int units_sold{0}; int units_sold(0); 当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错\n1 2 3 long double Id = 3.1415926536; int a{Id}, b = {Id}; // 错误 ：转换未执行，因为存在丢失信息的危险 int c(ld), d = Id; // 正确：转换执行，且确实丢失了部分值 3.3 默认初始化 定义时没有指定初始值会被默认初始化，默认值到底是什么由变量类型决定\n在函数体内部的内置类型变量将不会被初始化, 函数体外的内置类型初始化为0，试图使用未定义的变量将发生错误。建议初始化每一个内置类型的变量。\n3.4 值初始化（类） 通常情况下，可以只提供Vector对象容纳的元素数量而不用略去初始值。此时库会创建一个值初始化的(value-initialized)元素初值，并把它赋给容器中的所有元素。这个 初值由vector对象中元素的类型决定。 限制：类中的元素必须支持默认初始化\n4、变量的声明（declaration） vs 定义（define） 为了支持分离式编译，C++将声明和定义区分开。声明使得名字为程序所知。定义负责创建与名字关联的实体。 extern：只是说明变量定义在其他地方。 只声明而不定义： 在变量名前添加关键字 extern，如extern int i;。但如果包含了初始值，就变成了定义：extern double pi = 3.14; 变量只能被定义一次，但是可以多次声明。定义只出现在一个文件中，其他文件使用该变量时需要对其声明。 名字的作用域（namescope）{} 第一次使用变量时再定义它。 嵌套的作用域 同时存在全局和局部变量时，已定义局部变量的作用域中可用::reused显式访问全局变量reused。 但是用到全局变量时，尽量不适用重名的局部变量。 5、变量命名规范 需体现实际意义 变量名用小写字母 自定义类名用大写字母开头：Sales_item 标识符由多个单词组成，中间须有明确区分：student_loan或studentLoan，不要用studentloan。 6、左值和右值 左值（l-value）可以出现在赋值语句的左边或者右边，比如变量； 右值（r-value）只能出现在赋值语句的右边，比如常量。 7、变量的作用域 C++作用域\n四、复合类型 复合类型\n五、const限定符 动机：希望定义一些不能被改变值的变量。 1、初始化和const const对象必须初始化，且不能被改变。 编译器将在编译过程中把用到const 变量的地方都替换成对应的值。 const变量默认不能被其他文件访问，非要访问，必须在指定const定义之前加extern。某些时候有这样种const变量，它的初始值不是个常量表达式，但又确实有必要在文件间共享。也就是说，只在一个文件中定义const,而在其他多个文件中声明并使用它。解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了： 1 2 3 4 // file_l.cc定义并初始化了一个常量，该常量能被其他文件访问 extern const int bufSize = fen(); // file_l.h 头丈件 extern const int bufSize; // 与\t.cc 中定义的 bufSize 是同一个 2、const的引用 [[复合类型#^d7c880|常量引用的特殊性]]\nreference to const（对常量的引用）：指向const对象的引用，如 const int ival=1; const int \u0026amp;refVal = ival;，可以读取但不能修改refVal。 临时量（temporary）对象：当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。 对临时量的引用是非法行为。 3、指针和const [[复合类型#^413a8b|常量指针的特殊性]]\npointer to const（指向常量的指针，简称常量指针）：不能用于改变其所指对象的值, 如 const double pi = 3.14; const double *cptr = \u0026amp;pi;。 const pointer：指针本身是常量（简称指针常量），也就是说指针固定指向该对象，（存放在指针中的地址不变，地址所对应的那个对象值可以修改）如 int i = 0; int *const ptr = \u0026amp;i; 4、顶层const与底层 顶层const：表示变量本身是个常量，对任何数据类型适用，如算数类型（int、double），类，指针。 底层const：表示指向的变量是个常量，用于指针和引用 六、处理类型 1、类型别名 传统别名：使用typedef来定义类型的同义词。 1 2 typedef double wages; typedef wages base,*p; //base = wages = double , p = wages * = double * 这里不仅有基本类型还包含声明符，需要理解[[复合类型#四、理解复合类型的声明|复合类型的声明]]\n新标准别名：别名声明（alias declaration）： using SI = Sales_item;（C++11） 指针、常量和类型别名\n1 2 3 4 5 6 7 8 9 // 对于复合类型（指针等）不能代回原式来进行理解 typedef char *pstring; // pstring是char*的别名 const pstring cstr = 0; // 指向char的常量指针 const pstring *ps; //ps是一个指针，他的对象是指向char的常量指针 // 如改写为const char *cstr = 0;不正确，为指向const char的指针 // 辅助理解（可代回后加括号） // const pstring cstr = 0;代回后const (char *) cstr = 0; // const char *cstr = 0;即为(const char *) cstr = 0; 2、auto类型说明符 c++11 auto类型说明符：让编译器自动推断类型。 一条声明语句只能有一个数据类型，所以一个auto声明多个变量时只能相同的变量类型(包括复杂类型\u0026amp;和*)。auto sz = 0, pi =3.14//错误 如何初始化的对象是引用类型，会根据引用变量的引用对象的值来推测，而非引用变量的类型，int i = 0, \u0026amp;r = i; auto a = r; 推断a的类型是int。 会忽略顶层const。const int ci = 1; const auto f = ci;推断类型是int，如果希望是顶层const需要自己加const；但是如果左值是一个引用变量，那么初始值中的顶层常量属性会被保存 1 2 3 4 5 6 7 8 9 10 11 12 int i = 0, \u0026amp;r = i; auto a = r; //a 是整型 const int ci = i, \u0026amp;cr = ci; auto b = ci; //b 是整型 auto c = cr; //c 是一个整型 auto d = \u0026amp;i; //d 是一个整型指针 auto e = \u0026amp;ci; //e 是一个指向整数常量的指针（对常量取地址是一种底层const） const auto f = ci; //ci的推演类型是int,f是cosnt int auto \u0026amp;g = ci; //g是一个整型常量引用，绑定到ci auto \u0026amp;h = 42; //错误：不能为非常量引用绑定到字面值 const auto \u0026amp;j = 42 //正确，这里是因为常量引用的特殊性，可以参考复合类型的笔记 3、decltype类型指示符 有时会遇到这种情况: 向往从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量（想用类型，不想用值）。 为了满足这一要求，C++1I新标准引入了第二种类型说明符decltype decltype：选择并返回操作数的数据类型，从表达式的类型推断出要定义的变量的类型。\n3.1 与auto的不同 decltype处理顶层const和引用的方式与auto有些许不同。 其一，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）:\n1 2 3 4 const int ci =0, \u0026amp;cj =ci; decltype(ci) x = 0 ; //x的类型是const int decltype(cj) y = x ; //y的类型是const int \u0026amp; decltype(cj) z; //错误，z是const int \u0026amp; ,需要初始化 其二，decltype的结果类型与表达式形式密切相关，如果对变量加括号（一层或者多层），因为变量是一种可以作为赋值语句左值的特殊表达式，编译器会因此将其认为是一个表达式\n1 2 decltype((i)) d; //错误，d是int\u0026amp;，必须初始化 decltype(i) e; //正确，e是一个未初始化的int 3.2 decltype和引用 如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的 类型。 1 2 3 4 5 6 decltype(f()) sum = x; // 推断sum的类型是函数f的返回类型。 int i = 42, *p = \u0026amp;i, \u0026amp;r = i ; decltype(r + 0) b; //正确，加法的结果是int,因此b是一个未初始化的int decltype(*p) c; //错误：c是int\u0026amp; , 必须初始化 decltype(\u0026amp;i) d; //d是 int **类型 因为r是一个引用，因此decltype (r)的结果是引用类型。如果想让结果类型是r所指 的类型，可以把r作为表达式的一部分，如r+0,显然这个表达式的结果将是一个具体值而非一个引用。 表达式的内容是解引用操作，则decltype将得到引用类型 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果 i 是 int，则表达式 i=x 的类型是 int\u0026amp;。 取地址运算符生成右值，所以decltype(\u0026amp;p)的结果是int ** ","pubDate":"2021-09-04","title":"【C++ Primer(edition 5) 01】变量和基本类型"}];
    var search_theEnd = "到底了";
    var search_nothing = "什么也没找到";
    var search_found = "找到";
    var search_result = "条结果";
    var search_results = "条结果";
    var enable_mermaid =  null 
</script>





        
    </body>
</html>

