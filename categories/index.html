<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>AWei’s Kernel Tour | Categories</title>
    <meta name="description"
        content=" ">
    <link rel="canonical" href="https://cnjslw.github.io/categories/" />
    <link rel="icon" type="image/x-icon" href="/images/linux_pic.ico">
    <meta property="og:title" content="Categories" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cnjslw.github.io/categories/" />


    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Categories"/>
<meta name="twitter:description" content=""/>

    
    
    

    <link rel="stylesheet" href='/css/style.css' />
    <link rel="stylesheet" href='/css/search.css' />
    <link rel="stylesheet" href='/css/md_nb.css' />
    <link rel="stylesheet" href='/css/list.css' />
    <link rel="stylesheet" href='/css/terms.css' />
    <link rel="stylesheet" href='/css/taxonomy.css' />
    <link rel="stylesheet" href='/css/font-awesome-4.7.0/css/font-awesome.min.css' />
    <link rel="stylesheet" href='/css/home.css' />
    <link rel="stylesheet" href='/css/syntax.css' />
    
    <link rel="stylesheet" href='/css/shortcode.css' />

    
    <link rel="stylesheet" href='/css/_custom.css' />
    <style>
        {
                {
                if eq .Kind "404"
            }
        }

        body::after {
            display: none;
        }

            {
                {
                end
            }
        }
    </style>
    
    
    
    
    <script src="/js/lazysizes.min.js" async=""></script>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/search.js"></script>
    <script src="/js/md_nb.js"></script>
    <script src="/js/yes.js"></script>
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
</head><body style="font-family: ,'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Heiti SC', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;">
        <div class="loading">
            <div class="loading-bg"></div>
            <div class="loading-long">
                <div class="loading-short"></div>
            </div>
        </div>

        <header>
    <nav class="navbar">
        <div class="navbar-brand">
            <a href="/">
                <span class="logo">AWei’s Kernel Tour</span>
            </a>
        </div>
        <div class="navbar-menu">
            
                <a href="/">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-home'></i> 主页</div>
                        </div>
                    </div>
                </a>
            
                <a href="/posts">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-book'></i> 文章</div>
                        </div>
                    </div>
                </a>
            
                <a href="/categories">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-folder-open'></i> 分类</div>
                        </div>
                    </div>
                </a>
            
                <a href="/series">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-gears'></i> 系列</div>
                        </div>
                    </div>
                </a>
            
                <a href="/tags">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-tags'></i> 标签</div>
                        </div>
                    </div>
                </a>
            
                <a href="/about">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-info-circle'></i> 简历</div>
                        </div>
                    </div>
                </a>
            
            <div class="navbar-burger">
                <div class="burger-btn"><span><i class="fa fa-navicon"></i></span></div>
            </div>
            
            
            <div class="search-in"><span><i class="fa fa-search"></i></span></div>
            
                <div class="mode">
                    <span class="sun"><i class="fa fa-sun-o"></i></span>
                    <span class="moon"><i class="fa fa-moon-o"></i></span>
                </div>
            
        </div>
    </nav>
    <div class="burger-items">
        
        <a href="/">
            <div class="burger-item">
                <i class='fa fa-home'></i> 主页
            </div>
        </a>
        
        <a href="/posts">
            <div class="burger-item">
                <i class='fa fa-book'></i> 文章
            </div>
        </a>
        
        <a href="/categories">
            <div class="burger-item">
                <i class='fa fa-folder-open'></i> 分类
            </div>
        </a>
        
        <a href="/series">
            <div class="burger-item">
                <i class='fa fa-gears'></i> 系列
            </div>
        </a>
        
        <a href="/tags">
            <div class="burger-item">
                <i class='fa fa-tags'></i> 标签
            </div>
        </a>
        
        <a href="/about">
            <div class="burger-item">
                <i class='fa fa-info-circle'></i> 简历
            </div>
        </a>
        
    </div>
    <div class="header-rest"></div>
</header>


        <div id="content">
    






    
        
        
        
    




    <div class="hero">
        
            <div class="hero-img">
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/categories.jpg" alt="">
            </div>
        
        <div class="hero-content">
            <div class="hero-title">分类</div>
            <div>description of categories page</div>
        </div>
    </div>




<div class="zhuti-0">
    <div class="container">
        <div class="zhuti">
            <div class="zhuti-l">
                




    


<div class="taxo-body">
    <div class="long">
        <button class="tosides-1 text-wbd">
            <i class="fa fa-arrow-right"></i>
        </button>
        <button class="tosides-2 text-wbd">
            <i class="fa fa-arrow-left"></i>
        </button>
        <button class="toup text-wbd">
            <i class="fa fa-arrow-up"></i>
        </button>
    </div>
    
        <div class='taxo-row '>
            
                



<div class="taxo-col">
    <a href="https://cnjslw.github.io/categories/cpp/">
        <div class="taxo-card">
            <div class="folder-rear"></div>
                
                
                    <div class="taxo-img" style="background-image: url(  );"></div>
                
            <div class="folder-front">
                <div class="taxo-text">
                    <div>Cpp</div>
                    <div class="jipian">3 篇</div>
                </div>
            </div>
        </div>
    </a>
</div>


            
        </div>
    
</div>


            </div>
            <div class="zhuti-r">
                
<div class="zhuti-r-0">
    <div class="zhuti-r-1">
        
        <div id="r1">
            

<div class="about-zuozhe">
    <div class="zuozhe">
        
            <div class="datou">
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/author.png" alt="">
            </div>
        
        <div class="name-jianjie">
            <div class="name">AWei</div>
            <div class="jianjie">
                Be Water, My Friend.
            </div>
        </div>
    </div>

    <div class="type">
        <a href='
                    /posts/
                '>
            <p>文章</p>
            <p>3</p>
        </a>
        <a href='
                    /categories/
                '>
            <p>分类</p>
            <p>1</p>
        </a>
        <a href='
                    /tags/
                '>
            <p>标签</p>
            <p>2</p>
        </a>
    </div>

    <a href="https://github.com/cnjslw">
        <div class="follow">Follow Me</div>
    </a>
    <div class="link">
        
        <a href="https://github.com/cnjslw" class="link-item is-hidden-desktop" title="GitHub">
            <span class="icon"><i class='fa fa-github'></i></span>
        </a>
        
        <a href="https://www.youtube.com" class="link-item is-hidden-desktop" title="YouTube">
            <span class="icon"><i class='fa fa-youtube'></i></span>
        </a>
        
    </div>
</div>
            <div class="mulu">
    <div class="dong"></div>
    <div class="zhi">
        <div class="wenzi">
            <div class="zhi-mulu text-wbd">目录</div>
            <div class="mulu-items">
            </div>
        </div>
    </div>
</div>
            




<div class="other">
    <div class="other-up">
        <div class="other-qita text-wbd">最新文章</div>
        <div class="xian"></div>
    </div>
    <div class="list">
        
            <a href="https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">
                
<a href="https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【模板与泛型编程01】函数模板
            </div>
            <div class="other-summary">函数模板</div>
            <div class="other-date">2022-6-8</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cnjslw.github.io/posts/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/">
                
<a href="https://cnjslw.github.io/posts/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【C&#43;&#43; Primer(edition 5) 01】变量和基本类型
            </div>
            <div class="other-summary">一、基本内置类型 基本算数类型</div>
            <div class="other-date">0001-1-1</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="https://cnjslw.github.io/posts/%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/">
                
<a href="https://cnjslw.github.io/posts/%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url(  );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                【C&#43;&#43; Primer(edition 5) 02】复合类型
            </div>
            <div class="other-summary">一、引用 1、左值引用 1.</div>
            <div class="other-date">0001-1-1</div>
        </div>
    </div>
</a>
            </a>
        
    </div>
</div>
        </div>
        <div id="r2">
            
        </div> 
    </div>
</div>

            </div>
        </div>
    </div>
</div>


        </div>

        <footer class="footer">
    
        <div class="container">
            <div class="footer-items">
                
                    <div class="footer-item">
                        <i class="fa fa-user"></i> <span id="busuanzi_value_site_pv"></span> |
                        <i class="fa fa-eye"></i> <span id="busuanzi_value_site_uv"></span>
                    </div>
                
                
                    <div class="footer-item">
                        © 2022-2023 <a href="https://github.com/cnjslw">AWei</a>
                    </div>
                
                
                    <div class="footer-item">
                        Theme by <a href="https://github.com/xioyito/NewBee">NewBee</a> | Powered by <a href="https://gohugo.io/">Hugo</a>
                    </div>
                
            </div>
        </div>
    

    
</footer>


        
        <div class="search-root">
    <div class="search-zz"></div>
    <div class="search">
        <div class="sheader anniu">
            <div class="sh-l">
                <input type="text" placeholder='请输入关键词' id="search-key">
                <span class="sclear"><i class="fa fa-close"></i></span>
            </div>
            <div class="sh-r">
                <button>搜索</button>
            </div>
        </div>
        <div class="sbody">
            <div class="sbody-1">
                <div class="stip"></div>
            </div>
        </div>
    </div>
</div>
        









    
    

    
    

    
    


<script type="text/javascript">
    var mode_custom = "auto";
    var postsCount =  3 ;
    var arrPosts = [{"link":"https://cnjslw.github.io/posts/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/","plain":"一、定义函数模板 1、基本范例 1 2 3 4 5 6 7 template \u0026lt;typename T\u0026gt; int compare(const T \u0026amp;v1 , const T \u0026amp;v2) { if(v1 \u0026lt; v2) return -1; if(v2 \u0026lt; v1) return 1; return 0; } 模板定义以关键字 template开始，后接模板形参表，模板形参表是用尖括号\u0026lt;\u0026gt;括住的一个或多个模板形参的列表，用逗号分隔，不能为空。\n模板程序应该尽量减少对实参类型的要求。 函数模板和类模板成员函数的定义通常放在头文件中。 2、模板参数 2.1 类型参数 类型参数前必须使用关键字class或者typename，这两个关键字含义相同，可以互换使用。旧的程序只能使用class。但是有些时候，class并不合适\n2.2 默认参数 1 2 3 4 5 6 7 8 9 10 template\u0026lt;typename T , typename F = FunType\u0026gt; void TestFunc(T i , T j , F funcpoint=mf) { cout\u0026lt;\u0026lt;funcpoint(i,j)\u0026lt;\u0026lt;endl; } int main() { TestFunc(15,16); return 0; } 调用testfunc()函数的时候，不用指定第3个实参，因为第3个参数有默认值。要注意默认参数的写法：针对当前的范例，类型模板参数F给了默认值，函数的形参也给了默认值。默认模板参数F是一个函数指针类型（FuncType），函数参数funcpoint = mf中的mf是函数名，代表函数首地址\n另外，函数模板的默认模板参数可以放在前面（这一点类模板默认模板参数不一样，类模板的模板参数一旦有一个是默认参数，则其后续的参数都需要是默认参数）。\n2.3 非类型参数 除了定义类型参数，还可以在模板中定义非类型参数(nontype parameter) 表示一个值而非一个类型。 当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达，从而允许编译器在编译时实例化模板。\n1 2 3 4 5 6 7 8 9 template\u0026lt;unsigned N , unsigned M\u0026gt; int compare(const char (\u0026amp;p1)[N] , const char (\u0026amp;p2)[M]) { return strcmp(p1,p2); } compare(\u0026#34;hi\u0026#34; , \u0026#34;mom\u0026#34;); //实例化模板 //int compare(const char (\u0026amp;p1)[3] , const char (\u0026amp;p2)[4]) 一个非类型参数可以是一个整形，或者是一个指向对象或函数类型的指针或引用，绑定到非类型整数参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参，必须具有静态的生存期。\n但是，并不是任何类型的参数都可以作为非类型模板参数，一般有以下一些是允许的 （1）整型或枚举类型。 （2）指针类型。 （3）左值引用类型。 （4）auto或decltype(auto)。对于decltype(auto)这个用法，其中的auto理解成要推导的类型，而decltype理解成推导过程采用decltype推导。 （5）可能还有其他类型，请读者自行在学习或阅读他人代码的过程中收集和总结。\n二、 实例化函数模板 这里可以给实例化一个定义：用具体的“类型”代替“类型模板参数”的过程就叫作实例化（也称为代码生成器）。\n1、一个错误的实例化示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template \u0026lt;typename T\u0026gt; T sub(T tv1 , T tv2) { return tv1 - tv2; } int main() { int v1 = 1; int v2 = 2; sub(v1,v2);//return -1 string s1 = \u0026#34;Hello\u0026#34;; string s2 = \u0026#34;World\u0026#34;; sub(s1,s2);//报错 return 0; } 所以，同样一个函数模板，可能以某种方式进行调用是合法的，而换一种方式调用就不合法了。尤其值得注意的是，这种合法性，在==编译阶段就可以由编译器判断出来==，因为这些对Sub()函数模板的调用代码就在这里摆着，编译器有能力在编译时就从这些调用代码中去推断Sub()函数模板中的模板参数T的类型。根据模板参数T的类型，编译器就能够判断出这个类型是否支持减法运算。\n2、编译器视角的实例化 1 2 sub(1,2); sub(1.1 , 2.2); 1 2 //.obj int __cdecl sub\u0026lt;int\u0026gt;(int,int) double __cdecl sub\u0026lt; double \u0026gt;( double, double) 这说明在编译阶段，在对模板进行具体针对某类型的实例化之前，编译器需要查看函数模板的函数体，确定能否针对该类型进行实例化\n当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码\n当编译器遇到类和普通函数\n普通函数 当我们调用一个函数时，编译器只需要掌握函数的声明 类 当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现 我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中 为了生成个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义，所以函数模板与类模板成员函数的定义通常放在头文件中。\n3、模板参数的实例化 1 2 3 4 5 template\u0026lt;typename T\u0026gt; T mydouble(T tmpvalue) { return tmpvalue * 2; } 3.1 显示实例化 1 2 int result = mydouble\u0026lt;int\u0026gt;(16); int result = mydouble\u0026lt;int\u0026gt;(17.7);//warning C4244: “参数”: 从“double”转换到“T”，可能丢失数据 3.2 隐式实例化 1 2 3 cout \u0026lt;\u0026lt; compare(1,0) \u0026lt;\u0026lt; endl; //实例化出一个特别版本的函数 //compare(const int\u0026amp; , const int\u0026amp;); 编译器用函数实参来为我们推断模板实参，实参类型是int。编译器会推断出模板实参为int , 并将它绑定到模板参数T。 编译器用推断出的模板参数来为我们实例化(instantiate) 一个特定版本的函数\n隐式实例化下的空参数列表\n1 auto result = mydouble\u0026lt;\u0026gt;(16.9); \u0026lt; \u0026gt;的作用：\u0026lt; \u0026gt;没什么用处，但是当有一个也叫作mydouble()的普通函数存在时，\u0026lt; \u0026gt;也许就会发挥作用\n3.3 部分实例化 1 2 3 4 5 6 7 8 9 10 11 12 template \u0026lt;typename V,typename T,typename U\u0026gt; V Add(T tv1, U tv2) { return tv1 + tv2; } int main() { Add(15,17.8);//error C2672: “Add”\u0026#34;: 找到匹配的重载函数 error C2783: “V Add(T,U)”: 未能为“V”推导模板参数 Add\u0026lt;double\u0026gt;(1.1 , 2); // return 3.1 return 0; } 通过尖括号指定一部分模板参数，另外一部分模板参数可以让编译器去推断。但是，一旦从某个模板参数开始推断，后续的所有模板参数都需要让编译器推断，==不可以自己指定第1个类型V和第3个类型U，然后推断中间第2个类型T，编译器不支持这种语法。==\n3.4 特化 1 2 3 4 5 6 7 template \u0026lt;typename T, typename U\u0026gt; void tfunc(T\u0026amp; tmprv, U\u0026amp; tmprv2) { cout \u0026lt;\u0026lt; \u0026#34;tfunc泛化版本\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; tmprv \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; tmprv2 \u0026lt;\u0026lt; endl; } 3.4.1 全特化 所谓全特化，就是把tfunc()这个泛化版本中的所有模板参数都用具体的类型代替，构成一个特殊的版本（全特化版本），既然所有模板参数都用具体的类型代替了，那么tfunc()泛化版本中template后面尖括号中的内容就变成空了。\n1 2 3 4 5 template\u0026lt;\u0026gt; void tfunc\u0026lt;int , double\u0026gt;(int\u0026amp; tmprv, double\u0026amp; tmprv2) { cout\u0026lt;\u0026lt;\u0026#34;tfunc特化\u0026#34;\u0026lt;\u0026lt;endl; } 全特化实际上等价于实例化一个函数模板，并不等价于一个函数重载\n1 2 3 4 void tfunc(int\u0026amp; tmprv, double\u0026amp; tmprv2) { cout\u0026lt;\u0026lt;\u0026#34;tfunc函数重载\u0026#34;\u0026lt;\u0026lt;endl; } ==调用优先级：普通函数 \u0026gt; 函数模板特化 \u0026gt; 函数模板泛化==\n3.4.2 偏特化 （1）模板参数数量上的偏特化 What is : 特化第1个模板参数类型为double类型，但第2个模板参数不特化\n实际上，从模板参数数量上来讲，函数模板不能偏特化，只有类模板才能偏特化\n（2）模板参数范围上的偏特化 What is : 所谓“参数范围”，比如原来是int类型，如果变成const int类型，那么与int类型相比，const int类型的范围就变小了；再比如，如果原来是任意类型T，现在变成T *（从任意类型缩小为任意指针类型），那这个类型的范围也是变小了；还有T \u0026amp;（左值引用）、T\u0026amp;\u0026amp;（右值引用），对于T，从类型范围上都属于变小了。\n对于函数模板，也不存在模板参数范围上的偏特化。因为这种所谓模板参数范围上的偏特化，实际上是函数模板的重载\n1 2 3 4 5 template \u0026lt;typename T , typename U\u0026gt; void tfunc(const T\u0026amp; tmprv1, U\u0026amp; tmprv2) { cout\u0026lt;\u0026lt;\u0026#34;函数模板的参数范围偏特化本质上是函数模板的重载\u0026#34;\u0026lt;\u0026lt;endl; } 3.5 实例化模板的返回值问题 显示实例化 1 Add\u0026lt;double\u0026gt;(1.1 , 3); auto 使用auto结合decltype完成返回值类型推断 1 2 3 4 5 6 template \u0026lt;typename V,typename T,typename U\u0026gt; auto Add(T tv1, U tv2) //auto Add(T tv1, U tv2) -\u0026gt; decltype(tv1 + tv2) { return tv1 + tv2; } 三、特异的语法 1、省略参数 不管是类型模板参数还是非类型模板参数，如果在代码中没有用到这个参数，则参数名可以省略\n1 2 3 template \u0026lt;typename T ,int value\u0026gt; auto Add2() {return 100;} 可以做如下省略\n1 2 3 template \u0026lt;typename ,int\u0026gt; auto Add2() {return 100;} 2、\u0026ldquo;无用\u0026quot;的typename 类型前面可以增加一个typename修饰以明确标识一个类型。有的时候为了表明其后面是一个类型，也需要用typename修饰\n1 2 3 4 5 template \u0026lt;typename T , typename int value\u0026gt; auto Add() { return 100; } 四、模板函数在工程中 1、inline和constexpr的含函数模板 inline或 constexpr说明符放在模板参数列表之后，返回类型之前：\n1 2 template \u0026lt;typename T\u0026gt; inline T min(const T\u0026amp;, const T\u0026amp;); template \u0026lt;typename T\u0026gt; constexpr T min(const T\u0026amp; , const T\u0026amp;); 2、编写与类型无关的代码 1 2 3 4 5 6 template \u0026lt;typename T\u0026gt; int compare(const T \u0026amp;v1 , const T \u0026amp;v2) { if(less\u0026lt;T\u0026gt;()(v1,v2)) return -1; if(less\u0026lt;T\u0026gt;()(v2,v1)) return 1; return 0; } 这样写的好处\nconst T \u0026amp;作为函数参数可以避免实参是不可调用类型 less\u0026lt;T\u0026gt;()使用标准库可以避免有些类型没有定义\u0026gt;的比较 ","pubDate":"2022-06-08","title":"【模板与泛型编程01】函数模板"},{"link":"https://cnjslw.github.io/posts/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/","plain":"一、基本内置类型 基本算数类型\n类型 含义 最小尺寸 bool 布尔类型 8bits char 字符 8bits wchar_t 宽字符 16bits char16_t Unicode字符 16bits char32_t Unicode字符 32bits short 短整型 16bits int 整型 16bits (在32位机器中是32bits) long 长整型 32bits long long 长整型 64bits （是在C++11中新定义的） float 单精度浮点数 6位有效数字 double 双精度浮点数 10位有效数字 long double 扩展精度浮点数 10位有效数字 如何选择类型\n1.当明确知晓数值不可能是负数时，选用无符号类型； 2.使用int执行整数运算。一般long的大小和int一样，而short常常显得太小。除非超过了int的范围，选择long long。 3.算术表达式中不要使用char或bool。 4.浮点运算选用double。 二、常量 在C++中，常量类似于变量，只是不能修改。与变量一样，常量也占用内存空间，并使用名称标识为其预留的空间的地址，但不能覆盖该空间的内容。在C++中，常量可以是： •字面常量； •使用关键字const声明的常量； •使用关键字constexpr声明的常量表达式（C++11新增的）; •使用关键字enum声明的枚举常量； •使用#define定义的常量（已摒弃，不推荐）。\n1、使用constexpr声明常量 在C++11之前，C++就支持常量表达式的概念，只是没有关键字constexpr，在程序清单3.5中， 22.0/7是一个常量表达式，C++11之前的编译器也支持它。然而，C++11之前的编译器不允许定义在编译阶段计算的函数。 在C++11中，可以编写下面这样的代码：\n1 constexpr double GetPi() {return 22.0 / 7;} 还可将GetPi与另一个常量一起使用，如下所示：\n1 constexpr double TwicePi() {return 2 * GetPi();} 乍一看，const和constexpr之间的差别很小，但从编译器和应用程序的角度看，关键字Constexpr 提供了优化应用程序的可能性。对于第二条语句，如果使用const,将在运行阶段执行计算，但使用遵 守C++11的编译器时，将在编译阶段计算该表达式的值，这提高了应用程序的运行速度。\n2、字面值常量 一个形如42的值被称作字面值常量（literal）。 整型和浮点型字面值。 字符和字符串字面值。 使用空格连接，继承自C。 字符字面值：单引号， 'a' 字符串字面值：双引号， \u0026quot;Hello World\u0026quot;\u0026quot; 分多行书写字符串。 1 2 std:cout\u0026lt;\u0026lt;\u0026#34;wow, a really, really long string\u0026#34; \u0026#34;literal that spans two lines\u0026#34; \u0026lt;\u0026lt;std::endl; 转义序列。\\n、\\t等。 布尔字面值。true，false。 指针字面值。nullptr 字符串型实际上时常量字符构成的数组，结尾处以'\\0'结束，所以字符串类型实际上长度比内容多1。\n3、使用const将变量声明为常量 [[变量和基本类型#五、const限定符]]\n4、枚举常量 在有些情况下，变量只能有一组特定的取值\n1 2 3 4 5 6 7 8 9 10 11 enum RainbowColors { Violet = 0 , //此后每个值都递增1，默认0开始 Indigo, Blue, Yellow, Orange, Red } RainbowColors MyWorldColor = Blue; 5、使用#define定义常量 【摒弃】 这是一个预处理器宏，让预处理器将随后出现的所有Pi都替换为3.14286。预处理器将进行文本替换，而不是智能替换。编译器既不知道也不关心常量的类型。\n1 #define Pi 3.14 三、变量 1、什么是变量 变量提供一个具名的，可供程序操作的存储空间 变量类型向编译器指出了变量可存储的数据的性质，编译器将为变量预留必要的空间。变量名由程序员选择，它替代了变量值在内存中的存储地址，但更友好。除非给变量赋初值，否则无法确保相应内存单元的内容是什么，这对程序可能不利。因此，初始化虽然是可选的，但对变量初始化通常是 一个不错的编程习惯。程序清单3.1将用户提供的两个数字相乘，演示了如何在程序中声明、初始化。\n变量名 是内存地址的别名，方便存取 类型 是告诉编译器可以存什么样的数据,需要多大的内存空间 初始化 是可选的，不然无法确保内存中的数据是啥 变量提供一个具名的、可供程序操作的存储空间。 C++中变量和对象一般可以互换使用。\n2、变量定义（define） 定义形式：类型说明符（type specifier） + 一个或多个变量名组成的列表。用于初始化变量的值可以是任意复杂的[[表达式#^0c892c|表达式]]\n1 int sum = 0, value, units_sold = 0; 3、初始化 初始化（initialize）：对象在创建时获得了一个特定的值。 初始化不是赋值！ 初始化 = 创建变量 + 赋予初始值 赋值 = 擦除对象的当前值 + 用新值代替\n3.1 直接初始化 略\n3.2 列表初始化(C++11 全面支持) 使用花括号{}\n1 2 3 4 int units_sold = 0; int units_sold = {0}; int units_sold{0}; int units_sold(0); 当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错\n1 2 3 long double Id = 3.1415926536; int a{Id}, b = {Id}; // 错误 ：转换未执行，因为存在丢失信息的危险 int c(ld), d = Id; // 正确：转换执行，且确实丢失了部分值 3.3 默认初始化 定义时没有指定初始值会被默认初始化，默认值到底是什么由变量类型决定\n在函数体内部的内置类型变量将不会被初始化, 函数体外的内置类型初始化为0，试图使用未定义的变量将发生错误。建议初始化每一个内置类型的变量。\n3.4 值初始化（类） 通常情况下，可以只提供Vector对象容纳的元素数量而不用略去初始值。此时库会创建一个值初始化的(value-initialized)元素初值，并把它赋给容器中的所有元素。这个 初值由vector对象中元素的类型决定。 限制：类中的元素必须支持默认初始化\n4、变量的声明（declaration） vs 定义（define） 为了支持分离式编译，C++将声明和定义区分开。声明使得名字为程序所知。定义负责创建与名字关联的实体。 extern：只是说明变量定义在其他地方。 只声明而不定义： 在变量名前添加关键字 extern，如extern int i;。但如果包含了初始值，就变成了定义：extern double pi = 3.14; 变量只能被定义一次，但是可以多次声明。定义只出现在一个文件中，其他文件使用该变量时需要对其声明。 名字的作用域（namescope）{} 第一次使用变量时再定义它。 嵌套的作用域 同时存在全局和局部变量时，已定义局部变量的作用域中可用::reused显式访问全局变量reused。 但是用到全局变量时，尽量不适用重名的局部变量。 5、变量命名规范 需体现实际意义 变量名用小写字母 自定义类名用大写字母开头：Sales_item 标识符由多个单词组成，中间须有明确区分：student_loan或studentLoan，不要用studentloan。 6、左值和右值 左值（l-value）可以出现在赋值语句的左边或者右边，比如变量； 右值（r-value）只能出现在赋值语句的右边，比如常量。 7、变量的作用域 C++作用域\n四、复合类型 复合类型\n五、const限定符 动机：希望定义一些不能被改变值的变量。 1、初始化和const const对象必须初始化，且不能被改变。 编译器将在编译过程中把用到const 变量的地方都替换成对应的值。 const变量默认不能被其他文件访问，非要访问，必须在指定const定义之前加extern。某些时候有这样种const变量，它的初始值不是个常量表达式，但又确实有必要在文件间共享。也就是说，只在一个文件中定义const,而在其他多个文件中声明并使用它。解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了： 1 2 3 4 // file_l.cc定义并初始化了一个常量，该常量能被其他文件访问 extern const int bufSize = fen(); // file_l.h 头丈件 extern const int bufSize; // 与\t.cc 中定义的 bufSize 是同一个 2、const的引用 [[复合类型#^d7c880|常量引用的特殊性]]\nreference to const（对常量的引用）：指向const对象的引用，如 const int ival=1; const int \u0026amp;refVal = ival;，可以读取但不能修改refVal。 临时量（temporary）对象：当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。 对临时量的引用是非法行为。 3、指针和const [[复合类型#^413a8b|常量指针的特殊性]]\npointer to const（指向常量的指针，简称常量指针）：不能用于改变其所指对象的值, 如 const double pi = 3.14; const double *cptr = \u0026amp;pi;。 const pointer：指针本身是常量（简称指针常量），也就是说指针固定指向该对象，（存放在指针中的地址不变，地址所对应的那个对象值可以修改）如 int i = 0; int *const ptr = \u0026amp;i; 4、顶层const与底层 顶层const：表示变量本身是个常量，对任何数据类型适用，如算数类型（int、double），类，指针。 底层const：表示指向的变量是个常量，用于指针和引用 六、处理类型 1、类型别名 传统别名：使用typedef来定义类型的同义词。 1 2 typedef double wages; typedef wages base,*p; //base = wages = double , p = wages * = double * 这里不仅有基本类型还包含声明符，需要理解[[复合类型#四、理解复合类型的声明|复合类型的声明]]\n新标准别名：别名声明（alias declaration）： using SI = Sales_item;（C++11） 指针、常量和类型别名\n1 2 3 4 5 6 7 8 9 // 对于复合类型（指针等）不能代回原式来进行理解 typedef char *pstring; // pstring是char*的别名 const pstring cstr = 0; // 指向char的常量指针 const pstring *ps; //ps是一个指针，他的对象是指向char的常量指针 // 如改写为const char *cstr = 0;不正确，为指向const char的指针 // 辅助理解（可代回后加括号） // const pstring cstr = 0;代回后const (char *) cstr = 0; // const char *cstr = 0;即为(const char *) cstr = 0; 2、auto类型说明符 c++11 auto类型说明符：让编译器自动推断类型。 一条声明语句只能有一个数据类型，所以一个auto声明多个变量时只能相同的变量类型(包括复杂类型\u0026amp;和*)。auto sz = 0, pi =3.14//错误 如何初始化的对象是引用类型，会根据引用变量的引用对象的值来推测，而非引用变量的类型，int i = 0, \u0026amp;r = i; auto a = r; 推断a的类型是int。 会忽略顶层const。const int ci = 1; const auto f = ci;推断类型是int，如果希望是顶层const需要自己加const；但是如果左值是一个引用变量，那么初始值中的顶层常量属性会被保存 1 2 3 4 5 6 7 8 9 10 11 12 int i = 0, \u0026amp;r = i; auto a = r; //a 是整型 const int ci = i, \u0026amp;cr = ci; auto b = ci; //b 是整型 auto c = cr; //c 是一个整型 auto d = \u0026amp;i; //d 是一个整型指针 auto e = \u0026amp;ci; //e 是一个指向整数常量的指针（对常量取地址是一种底层const） const auto f = ci; //ci的推演类型是int,f是cosnt int auto \u0026amp;g = ci; //g是一个整型常量引用，绑定到ci auto \u0026amp;h = 42; //错误：不能为非常量引用绑定到字面值 const auto \u0026amp;j = 42 //正确，这里是因为常量引用的特殊性，可以参考复合类型的笔记 3、decltype类型指示符 有时会遇到这种情况: 向往从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量（想用类型，不想用值）。 为了满足这一要求，C++1I新标准引入了第二种类型说明符decltype decltype：选择并返回操作数的数据类型，从表达式的类型推断出要定义的变量的类型。\n3.1 与auto的不同 decltype处理顶层const和引用的方式与auto有些许不同。 其一，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）:\n1 2 3 4 const int ci =0, \u0026amp;cj =ci; decltype(ci) x = 0 ; //x的类型是const int decltype(cj) y = x ; //y的类型是const int \u0026amp; decltype(cj) z; //错误，z是const int \u0026amp; ,需要初始化 其二，decltype的结果类型与表达式形式密切相关，如果对变量加括号（一层或者多层），因为变量是一种可以作为赋值语句左值的特殊表达式，编译器会因此将其认为是一个表达式\n1 2 decltype((i)) d; //错误，d是int\u0026amp;，必须初始化 decltype(i) e; //正确，e是一个未初始化的int 3.2 decltype和引用 如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的 类型。 1 2 3 4 5 6 decltype(f()) sum = x; // 推断sum的类型是函数f的返回类型。 int i = 42, *p = \u0026amp;i, \u0026amp;r = i ; decltype(r + 0) b; //正确，加法的结果是int,因此b是一个未初始化的int decltype(*p) c; //错误：c是int\u0026amp; , 必须初始化 decltype(\u0026amp;i) d; //d是 int **类型 因为r是一个引用，因此decltype (r)的结果是引用类型。如果想让结果类型是r所指 的类型，可以把r作为表达式的一部分，如r+0,显然这个表达式的结果将是一个具体值而非一个引用。 表达式的内容是解引用操作，则decltype将得到引用类型 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果 i 是 int，则表达式 i=x 的类型是 int\u0026amp;。 取地址运算符生成右值，所以decltype(\u0026amp;p)的结果是int ** ","pubDate":"0001-01-01","title":"【C++ Primer(edition 5) 01】变量和基本类型"},{"link":"https://cnjslw.github.io/posts/%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/","plain":"一、引用 1、左值引用 1.1、引用的定义 引用是一个对象的别名，引用类型引用（refer to）另外一种类型。如int \u0026amp;refVal = val;。 引用的类型要和与之绑定的对象(对象)严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起\n引用必须初始化。 引用和它的初始值是绑定在一起的，而不是拷贝。一旦定义就不能更改绑定为其他的对象 1.2、引用规则的两种例外情况 第一个例外 在初始化常量引用时允许用任意表达式作为初始值，只要表达式的结果能够转换为引用的类型即可，允许一个常量引用绑定非常量的对象，字面值，甚至一个表达式 ^d7c880\n1 2 3 4 5 int i = -42; const int \u0026amp;rl = i;\t//允许将 const int\u0026amp; 绑定到一个普通int对象上 const int \u0026amp;r2 = 42;\t//正确：rl是一个常量引用 const int \u0026amp;r3 = rl*2;\t//正确：r3是一个常量引用 int \u0026amp;r4 = rl*2;\t//\t错误：r4是一个普通的非常量引用 1 2 double dval = 3.14; const int \u0026amp;ri = dval; 理解这种例外的核心就是搞清楚当一个常量引用被绑定到另外一种类型上发生了什么。\n1 2 3 const int temp = dval; //由双精度浮点数生成一个临时的整型常量 const int \u0026amp;ri = temp; //让ri绑定这个临时量 在这种情况下，ri绑定了一个临时量(temporary)对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。c++程序员们常常把临时量对象简称为临时量。\n第二个例外 存在继承关系的类是一个例外，可以将基类的指针或者引用绑定到派生类对象上 可以将基类的指针或引用绑定到派生类对象上有一层极为至要的含义：当使用基类的 引用（或指针）时，实际我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。 ^9b1798\n1.3 sizeof()和引用 sizeof()取的是引用变量的类型大小\n3、为什么要有引用 避免无休止的拷贝，极大提高了性能\n二、指针 1、定义 指针是一种 \u0026ldquo;指向（point to）\u0026ldquo;另外一种类型的复合类型。也可以说是指向内存单元的特殊变量。指针的类型与所指向的对象类型必须一致\n1.1 声明指针 int *ip1;，从右向左读有助于阅读，ip1是指向int类型的指针。\n1.2 取变量地址 指针存放某个对象的地址，获取对象的地址： int i=42; int *p = \u0026amp;i;。 \u0026amp;是取地址符。\n1.3 利用指针访问对象 使用解引用符（*）来访问对象 指针访问对象： cout \u0026lt;\u0026lt; *p;\n1.4 sizeof()和指针 sizeof()用于普通变量是指变量类型的内存大小，即编译器为变量预留的内存空间大小。 但是，当用于指针变量时，取决于编译器和操作系统存储地址所需的内存空间，与指向什么类型的变量空间是没有关系的。\n2、指针操作 2.1 递增和递减 如果对指针执行递增或递减运算，编译器将认为要指向内存块中相邻的值（并假定这个值的 类型与前一个值相同）,而不是相邻的字节（除非值的长度刚好是1字节，如char）。 将指针递增或递减的结果 将指针递增或递减时，其包含的地址将增加或减少指向的数据类型的sizeof （并不一定是1字节）。这样，编译器将琉保指针不会指向数据的中间或末尾，而只会指向数据的开头。 如果声明了如下指针：\n1 Type* pType = Address; 则执行++piype后，pType 将包含（指向）Address + sizeoffiype。\n2.2 将关键字const用于指针 ![[变量和基本类型#3、指针和const|指针和const]]\n2.3 将指针传递给函数 3、指针定义的两种例外情况 指针的类型与所指向的对象类型必须一致这个规则有两种例外 第一种 允许令一个指向常量的指针指向一个非常量对象 ^413a8b\n1 2 3 const double *cptr ; double dval = 3.14 ; cptr = \u0026amp;dval ; 和常量引用一样，指向常量的指针也没有规定其所指的对象必须是个常量。所谓的指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过 其他途径改变。 可以这样想，所谓的常量引用和常量指针，不过是指针和引用的“自以为是”，他们觉得自己指向了常量，所以自觉的不去改变所指向的对象的值罢了。\n第二种 [[复合类型#^9b1798|继承关系中存在例外]]\n4、指针的值的四种状态 1.指向一个对象； 2.指向紧邻对象的下一个位置； 3.空指针； 4.无效指针。\n对无效指针的操作均会引发错误，第二种和第三种虽为有效的，但理论上是不被允许的\n5、空指针 空指针不指向任何对象。使用int *p=nullptr;来使用空指针。\n6、空类型指针 void*指针可以存放任意对象的地址。因无类型，仅操作内存空间，对所存对象无法访问。 利用void*指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void*指针。不能直接操作void*指针所指的对象，因为我们并不知道 这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。\n7、使用指针时常犯的错误 7.1 野指针 “野指针”则是不确定其具体指向的指针。“野指针”最常来自于未初始化的指针\n1 2 void *p; // 此时 p 是“野指针” 因为“野指针”可能指向任意内存段，因此它可能会损坏正常的数据，也有可能引发其他未知错误，所以C语言中的“野指针”危害性甚至比“悬空指针”还要严重。在实际的C语言程序开发中，定义指针时，一般都要尽量避免“野指针”的出现（赋初值）：\n1 void *p = NULL; 7.2 内存泄漏 这可能是C++应用程序最常见的问题之一：运行时间越长，占用的内存越多，系统越慢。如果在使用new动态分配的内存不再需要后，程序员没有使用配套的delete释放，通常就会出现这种情况。\n7.3 指向无效的内存单元 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { // uninitialized pointer (bad) int* pTemperature; cout \u0026lt;\u0026lt; \u0026#34;Is it sunny (y/n)?\u0026#34; \u0026lt;\u0026lt; endl; char Userinput = \u0026#39;y\u0026#39;; cin \u0026gt;\u0026gt; Userinput; if (Userinput == \u0026#39;y\u0026#39;) { pTemperature = new int; *pTemperature = 30; } // pTemperature contains invalid value if user entered \u0026#39;n\u0026#39; cout « \u0026#34;Temperature is: \u0026#39; « *pTemperature; // delete also being invoked for those cases new wasn\u0026#39;t done delete pTemperature; return 0; } 7.4 悬空指针 指针可以指向一块内存，如果这块内存稍后被操作系统回收（被释放），但是指针仍然指向这块内存，那么，此时该指针就是“悬空指针”\n三、指针与引用的不同 本质上： 引用本质是一个指针\n使用上： 指针与引用类似，都实现了对其他对象的间接访问。 然而指针与引用相比也有很多不同点。\n其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在==指针的生命周期内它可以先后指向几个不同的对象==，但是引用一旦初始化后就不可以再改变。\n其二，==指针无须在定义时赋初值==。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有个不确定的值。\n其三，作为参数传递时，指针是==拷贝==同样的地址，如果函数作用域中改变指针变量的地址，则不再影响实参。引用参数实质上==传递的是实参本身==，即传递进来的不是实参的一个拷贝，因此对形参的修改其实是对实参的修改，所以在用引用进行参数传递时，不仅节约时间，而且可以节约空间。\n四、理解复合类型的声明 变量的定义包括一个基本数据类型(base type) 和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。也就是说， 条定义语句可能定义出不同类型的变量：\n1 int i = 1024, *p = \u0026amp;i , \u0026amp;r = i; 甚至可以有多个声明符，组合出更为复杂的变量\n指向指针的指针\n1 int **p; 指向指针的引用 要理解变量到底是什么，最简单的方法就是==从右向左==阅读r的定义，距离变量名最近的符号对变量的类型有直接的影响\n1 2 3 4 5 6 int i = 42; int *p; int *\u0026amp;r = p; //r是一个引用变量，引用一个指向int型变量的指针变量 r = \u0026amp;i; *r=0; ","pubDate":"0001-01-01","title":"【C++ Primer(edition 5) 02】复合类型"}];
    var search_theEnd = "到底了";
    var search_nothing = "什么也没找到";
    var search_found = "找到";
    var search_result = "条结果";
    var search_results = "条结果";
    var enable_mermaid =  null 
</script>





        
    </body>
</html>

